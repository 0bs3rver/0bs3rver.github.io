<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>程序员的自我修养读书笔记-第一章 温故而知新 | 0bs3rver的小屋</title><meta name="description" content="程序员的自我修养读书笔记-第一章 温故而知新"><meta name="keywords" content="程序员的自我修养,读书笔记"><meta name="author" content="0bs3rver"><meta name="copyright" content="0bs3rver"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/坂本先生.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="程序员的自我修养读书笔记-第一章 温故而知新"><meta name="twitter:description" content="程序员的自我修养读书笔记-第一章 温故而知新"><meta name="twitter:image" content="http://yoursite.com/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="程序员的自我修养读书笔记-第一章 温故而知新"><meta property="og:url" content="http://yoursite.com/2020/11/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"><meta property="og:site_name" content="0bs3rver的小屋"><meta property="og:description" content="程序员的自我修养读书笔记-第一章 温故而知新"><meta property="og:image" content="http://yoursite.com/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/11/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"><link rel="prev" title="程序员的自我修养读书笔记-第二章 编译和链接" href="http://yoursite.com/2020/11/16/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"><link rel="next" title="double free与uaf" href="http://yoursite.com/2020/07/18/double%20free%E4%B8%8Euaf/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/坂本先生.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-温故而知新"><span class="toc-number">1.</span> <span class="toc-text">第一章 温故而知新</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#从-Hello-World-说起"><span class="toc-number">2.</span> <span class="toc-text">从 Hello World 说起</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#站得高，望得远"><span class="toc-number">3.</span> <span class="toc-text">站得高，望得远</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统做什么"><span class="toc-number">4.</span> <span class="toc-text">操作系统做什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#不要让CPU打盹"><span class="toc-number">4.1.</span> <span class="toc-text">不要让CPU打盹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设备驱动"><span class="toc-number">4.2.</span> <span class="toc-text">设备驱动</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存不够怎么办"><span class="toc-number">5.</span> <span class="toc-text">内存不够怎么办</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#直接分配"><span class="toc-number">5.1.</span> <span class="toc-text">直接分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分段"><span class="toc-number">5.2.</span> <span class="toc-text">分段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分页"><span class="toc-number">5.3.</span> <span class="toc-text">分页</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#众人拾柴火焰高"><span class="toc-number">6.</span> <span class="toc-text">众人拾柴火焰高</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程基础"><span class="toc-number">6.1.</span> <span class="toc-text">线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是线程"><span class="toc-number">6.1.1.</span> <span class="toc-text">什么是线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的访问权限"><span class="toc-number">6.1.2.</span> <span class="toc-text">线程的访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程调度与优先级"><span class="toc-number">6.1.3.</span> <span class="toc-text">线程调度与优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可抢占线程和不可抢占线程"><span class="toc-number">6.1.4.</span> <span class="toc-text">可抢占线程和不可抢占线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux的多线程"><span class="toc-number">6.1.5.</span> <span class="toc-text">Linux的多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全"><span class="toc-number">6.2.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#竞争与原子操作"><span class="toc-number">6.2.1.</span> <span class="toc-text">竞争与原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步与锁"><span class="toc-number">6.2.2.</span> <span class="toc-text">同步与锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重入（Reentrant）与线程安全"><span class="toc-number">6.2.3.</span> <span class="toc-text">可重入（Reentrant）与线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过度优化"><span class="toc-number">6.2.4.</span> <span class="toc-text">过度优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程内部情况"><span class="toc-number">6.3.</span> <span class="toc-text">多线程内部情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一对一模型"><span class="toc-number">6.3.1.</span> <span class="toc-text">一对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多对一模型"><span class="toc-number">6.3.2.</span> <span class="toc-text">多对一模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多对多模型"><span class="toc-number">6.3.3.</span> <span class="toc-text">多对多模型</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">0bs3rver的小屋</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">程序员的自我修养读书笔记-第一章 温故而知新</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-11-13 23:21:09"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-11-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-11-13 23:24:58"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-11-13</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="第一章-温故而知新"><a href="#第一章-温故而知新" class="headerlink" title="第一章 温故而知新"></a>第一章 温故而知新</h1><h1 id="从-Hello-World-说起"><a href="#从-Hello-World-说起" class="headerlink" title="从 Hello World 说起"></a>从 Hello World 说起</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;studio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(“Hello World\n”);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于下列问题，能立刻反应出清晰又明确的答案吗？</p>
<blockquote>
<p>希望我看完后可以，以下为我的第一反应答案</p>
</blockquote>
<ul>
<li>程序为什么要被编译器编译了之后才可以运行？<br>因为程序不能被CPU直接识别。</li>
<li>编译器在把C语言转换成可以执行的机器码的过程中做了什么？怎么做的？<br>识别程序文法并翻译成汇编语言，然后再转化成机器码。</li>
<li>最后编译出来的可执行文件里面是什么？除了机器码还有什么？它们怎么存放的？它怎么实现的？<br>里面是机器码、魔数、各种表、字符串等。利用表存放在可执行文件的各个地方。</li>
<li><code>#include&lt;studio.h&gt;</code>是什么意思？把studio.h包含进来意味着什么？它们怎么存放的？<br>include关键字用于导入文件。包含进来意味着导入的文件名为studio.h。存放在c语言环境中，导入进来后直接在该代码行位置展开。</li>
<li>不同的编译器（Microsoft VC、GCC）和不同的硬件平台（x86、SPARC、MIPS、ARM），以及不同的操作系统（Windows、Linux、UNIX、Solaris），最终编译出来的结果一样吗？为什么？<br>编译器可能一样，硬件平台不一样，操作系统不一样。因为不同硬件对机器码的识别不同，不同操作系统的可执行文件格式不一样。</li>
<li>Hello World 程序是怎么运行起来的？它从哪儿开始执行，到哪儿结束？main函数之前发生了什么？main函数结束以后又发生了什么？<br>经过编译，链接之后可以执行。从libc_start_main开始。main函数之前经过了各种初始化，main函数结束之后经历了内存的资源的释放操作。</li>
<li>如果没有操作系统，Hello World可以运行吗？如果要在一台没有操作系统的机器上运行Hello World需要什么？应该怎么实现？<br>不可以直接运行。需要直接调配硬件资源去执行自己的程序。</li>
<li>printf是怎么实现的？它为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？<br>printf是通过向一块内存内写入字符串来向终端中输出字符的。</li>
<li>Hello World程序在运行时，它在内存中是什么样子的？<br>代码段、数据段并链接到了系统中的库。</li>
</ul>
<h1 id="站得高，望得远"><a href="#站得高，望得远" class="headerlink" title="站得高，望得远"></a>站得高，望得远</h1><p>计算机软件体系结构采用一种层的结构，有一句名言：</p>
<p><strong>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”</strong></p>
<p>每个层次之间都需要相互通信，既然要通信就必须有一个通信的协议，我们一般将其称为<strong>接口（Interface）</strong>，接口的下面那层是接口的提供者，由它定义接口；接口的上面那层是接口的使用者，它使用该接口来实现所需要的功能。除了硬件和应用程序，其他都是所谓的中间层，每个中间层都是对它下面的那层的包装和扩展。</p>
<p>从整个层次结构上看，开发工具和应用程序是属于同一个层次的，因为它们都使用操作系统<strong>应用程序编程接口（Application Programming Interface）</strong>。</p>
<h1 id="操作系统做什么"><a href="#操作系统做什么" class="headerlink" title="操作系统做什么"></a>操作系统做什么</h1><p>操作系统的一个功能是提供抽象的接口，另外一个主要功能是管理硬件资源。</p>
<h2 id="不要让CPU打盹"><a href="#不要让CPU打盹" class="headerlink" title="不要让CPU打盹"></a>不要让CPU打盹</h2><ul>
<li>多道程序：当某个程序暂时无须使用CPU时，监控程序就把另外的正在等待CPU 资源的程序启动，使得CPU能够充分的利用起来。</li>
<li>分时系统：每个程序运行一段时间以后都主动让出CPU给其他程序，使得一段时间内每个程序都有机会运行一小段时间。</li>
<li>多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以<strong>进程（Process）</strong>的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，CPU由操作系统统一进行分配，且操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。</li>
</ul>
<h2 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h2><p>操作系统作为硬件层的上层，它是对硬件的管理和抽象。</p>
<p>由操作系统中的硬件驱动程序来完成繁琐的硬件细节。</p>
<h1 id="内存不够怎么办"><a href="#内存不够怎么办" class="headerlink" title="内存不够怎么办"></a>内存不够怎么办</h1><p>如何将计算机上有限的物理内存分配给多个程序使用？</p>
<h2 id="直接分配"><a href="#直接分配" class="headerlink" title="直接分配"></a>直接分配</h2><p>例如我们由128MB内存，程序A运行需要10MB，程序B运行需要100MB，如果我们要同时运行A和B，就将内存的前10MB分配给程序A，10MB-110MB分配给程序B。<br>问题：</p>
<ul>
<li>地址空间不隔离</li>
<li>内存使用效率低</li>
<li>程序运行的地址不稳定</li>
</ul>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>基本思路是把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间。程序中只用管虚拟空间，而实际的地址映射和转换由操作系统和硬件完成。</p>
<p>解决了上文的第一个和第三个问题。</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分页的基本方法是把地址空间人为地等分成固定大小的页，每一页的大小由硬件决定，或硬件支持多种大小的页，由操作系统决定页的大小。</p>
<p>我们把进程的虚拟地址空间按页分割，把常用的数据和代码页装载到内存中，把不常用的代码和数据保存在磁盘里，当需要用到的时候再把它从磁盘里取出来即可。</p>
<p>虚拟存储的实现需要依靠硬件的支持，对于不同的CPU来说是不同的。但是几乎所有硬件都采用一个叫<strong>MMU（Memory Management Unit）</strong>的部件来进行页映射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU —Virtual Address—&gt; MMU —Physical Address—&gt; Physical Memory</span><br></pre></td></tr></table></figure>

<p>在页映射模式下，CPU发出的是Virtual Address，即我们的程序看到的是虚拟地址，经过MMU转换以后就变成了Physical Address。</p>
<h1 id="众人拾柴火焰高"><a href="#众人拾柴火焰高" class="headerlink" title="众人拾柴火焰高"></a>众人拾柴火焰高</h1><h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p><strong>线程（Thread）</strong>，有时被称为<strong>轻量级进程（Lightweight Process，LWP）</strong>，是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。</p>
<p>一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）。<br>使用多线程的原因：</p>
<ul>
<li>某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程可以有效利用等待时间。</li>
<li>某个操作（常常是计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li>
<li>程序逻辑本身就要求并发操作，例如一个多端下载软件（Bittorrent）。</li>
<li>多CPU或多核计算机，本身具备同时执行多个线程的能力，单线程程序无法发挥计算机的全部计算能力。</li>
<li>相对于多进程应用，多线程在数据共享方面效率要高很多。</li>
</ul>
<h3 id="线程的访问权限"><a href="#线程的访问权限" class="headerlink" title="线程的访问权限"></a>线程的访问权限</h3><p>线程的访问非常自由，它可以访问进程内存里的所有数据，甚至包括其他线程的堆栈（如果它知道其他线程的堆栈地址），但实际运用中线程也拥有自己的私有存储空间：</p>
<ul>
<li><p>栈（尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的数据）。</p>
</li>
<li><p>线程局部存储（Thread Local Storage，TLS）。线程局部存储是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。</p>
</li>
<li><p>寄存器（包括PC寄存器），寄存器是执行流的基本数据，因此为线程私有。</p>
<p>从C语言的角度看，数据在线程之间是否私有如下所示：</p>
<table>
<thead>
<tr>
<th align="center">线程私有：</th>
<th align="center">线程之间共享：</th>
</tr>
</thead>
<tbody><tr>
<td align="center">局部变量</td>
<td align="center">全局变量</td>
</tr>
<tr>
<td align="center">函数的参数</td>
<td align="center">堆上的数据</td>
</tr>
<tr>
<td align="center">TLS数据</td>
<td align="center">函数里的静态变量</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">程序代码，任何线程都有权利读取并执行任何代码</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">打开的文件，A线程打开的文件可以由B线程读写</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="线程调度与优先级"><a href="#线程调度与优先级" class="headerlink" title="线程调度与优先级"></a>线程调度与优先级</h3><p>在线程数量小于等于处理器数量时（并且操作系统支持多处理器），线程的并发是真正的并发，不同的线程运行在不同的处理器上，彼此之间互不相干。<br>在单处理器对应多线程的情况下，并发是一种模拟出来的状态。操作系统会让这些多线程程序轮流执行，每次仅执行一小段时间，这样每个线程就“看起来”在同时执行。这样的一个不断在处理器傻姑娘切换不同线程的行为称之为<strong>线程调度（Thread Schedule）</strong>。在线程调度中，线程通常拥有至少三种状态：</p>
<ul>
<li><strong>运行（Running）</strong>：此时线程正在执行。</li>
<li><strong>就绪（Ready）</strong>：此时线程可以立刻运行，但CPU已经被占用。</li>
<li><strong>等待（Waiting）</strong>：此时线程正在等待某一事件（通常是I/O或者同步）发生，无法执行。</li>
</ul>
<p>处于运行中线程又一段可以执行的时间，这段时间称为<strong>时间片（Time Slice）</strong>，当时间片用尽的时候，该进程将进入就绪状态。</p>
<p><img src="/" class="lazyload" data-src="https://space.0bs3rver.workers.dev/0bs3rver/Picture/master//blogimg/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB-1-1.png"  alt=""></p>
<p>现在主流的调度方式都带有<strong>优先级调度（Priority Schedule）</strong>和<strong>轮转法（Round Robin）</strong>的痕迹。所谓轮转法，就是将各个线程轮流执行一小段时间。优先级调度则决定了线程按照什么顺序轮流执行。在具有优先级调度的系统中，线程都拥有各自的<strong>线程优先级（Thread Priority）</strong>，具有高优先级的线程会更早的执行。</p>
<p>一般把频繁等待的线程称之为<strong>IO密集型线程（IO Bound Thread）</strong>，而把很少等待的线程称为<strong>CPU密集型线程（CPU Bound Thread）</strong>。IO密集型线程总是比CPU密集型线程容易得到优先级的提升。</p>
<p>在优先级调度下，存在一种<strong>饿死（Starvation）</strong>的现象，一个线程被饿死，是说他的优先级较低，在它执行之前，总是有较高优先级的线程试图执行，因此这个低优先级线程始终无法执行。</p>
<p>线程的优先级改变一般有三种方式：</p>
<ul>
<li>用户执行优先级</li>
<li>根据进入等待状态的频繁程度提升或降低优先级</li>
<li>长时间得不到执行而被提升优先级</li>
</ul>
<h3 id="可抢占线程和不可抢占线程"><a href="#可抢占线程和不可抢占线程" class="headerlink" title="可抢占线程和不可抢占线程"></a>可抢占线程和不可抢占线程</h3><p>线程在用尽时间片之后会被强制剥夺继续执行的权利，而进入就绪状态，这个过程叫做<strong>抢占（Preemption）</strong>，即之后执行别的线程抢占了当前线程。</p>
<h3 id="Linux的多线程"><a href="#Linux的多线程" class="headerlink" title="Linux的多线程"></a>Linux的多线程</h3><p>在Linux内核中并不存在真正意义上的线程概念，Linux将所有的执行实体（无论是线程还是进程）都称为<strong>任务（Task）</strong>，每一个任务概念上都类似于一个单线程的进程，具有内存空间、执行实体、文件资源等。Linux下不同的任务之间可以选择共享内存空间，因而在实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就成了这个进程里的线程。</p>
<table>
<thead>
<tr>
<th align="center">系统调用</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fork</td>
<td align="center">复制当前进程</td>
</tr>
<tr>
<td align="center">exec</td>
<td align="center">使用新的可执行映像覆盖当前的可执行映像</td>
</tr>
<tr>
<td align="center">clone</td>
<td align="center">创建子进程并从指定位置开始执行</td>
</tr>
</tbody></table>
<p>fork函数产生一个和当前进程完全一样的新进程，并和当前函数一样从fork函数里返回，但不同的是本任务的fork函数将返回新任务pid，而新任务的fork将返回0。fork并不复制原任务的内存空间，而是和原任务一起共享一个<strong>写时复制（Cpoy on Write，COW）</strong>的内存空间。所谓写时复制，指的是两个任务可以同时自由地读取内存，但任意一个任务试图对内存进行修改时，内存都会复制一份提供给修改方单独使用，以免影响到其他的任务使用。</p>
<p>fork只能产生本任务的镜像，所以要使用exec配合才能够启动别的新任务。exec可以用新的可执行映像替换当前的可执行映像。</p>
<p>而如果要产生新线程，可以用clone。clone可以产生一个新的任务，从指定的位置开始执行，并且（可选的）共享当前进程的内存空间和文件等，如此就可以在实际效果上产生一个新线程。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="竞争与原子操作"><a href="#竞争与原子操作" class="headerlink" title="竞争与原子操作"></a>竞争与原子操作</h3><p>如果多线程同时访问一个共享数据并进行操作（例如自增），就可能产生错误的值，因为这个操作被编译为汇编代码后不止一条指令，因此在执行的时候可能执行了一半就被调度系统打断，去执行别的代码。我们把单指令的操作称为<strong>原子的（Atomic）</strong>，因为无论如何，单条指令的执行是不会被打断的。</p>
<p>但是面对复杂的操作，原子操作指令就力不从心了，这个时候我们就需要更加通用的手段：锁。</p>
<h3 id="同步与锁"><a href="#同步与锁" class="headerlink" title="同步与锁"></a>同步与锁</h3><p>为了避免多个线程同时读写同一个数据而产生不可预料的后果，我们需要将各个线程对同一个数据的访问<strong>同步（Synchronization）</strong>，就是说在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问，相当于对数据的访问被原子化了。</p>
<p>同步的最常见方式是用<strong>锁（Lock）</strong>。锁是一种非强制机制，每一个线程在访问数据或资源之前首先试图<strong>获取（Acquire）</strong>锁，并在访问结束之后<strong>释放（Release）</strong>锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。</p>
<p><strong>二元信号量（Binary Semaphore）</strong>是最简单的一种锁，它只有两种状态：占用与非占用。它适合只能被唯一一个线程独占访问的资源，当二元信号量处于非占用状态时，第一个试图获取该二元信号量的线程会获得该锁，并将二元信号量重置为占用状态，此后其他的所有试图获取该二元信号量的线程将会等待，直到该锁被释放。</p>
<p>对于运行多个线程并发访问的资源，多元信号量简称<strong>信号量（Semaphore）</strong>，一个初始值为N的信号量允许N个线程并发访问。线程访问资源的时候首先获取信号量：</p>
<ul>
<li>将信号量的值减一</li>
<li>如果信号量的值小于0，则进入等待状态，否则继续执行</li>
</ul>
<p>访问完资源后，线程释放信号量：</p>
<ul>
<li>将信号量的值加一</li>
<li>如果信号量的值小于1，唤醒一个等待中的线程。</li>
</ul>
<p><strong>互斥量（Mutex）</strong>和二元信号量类似，资源仅同时允许一个线程访问。但信号量可用被系统中的一个线程获取之后由另一个线程释放。而互斥量则要求哪个线程获取量互斥量，哪个线程就要负责释放这个锁。</p>
<p><strong>临界区（Critical Section）</strong>是比互斥量更加严格的同步手段。互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或信号量，另一个进程试图获取该锁是合法的，但是临界区的作用范围仅限于本进程，其他的进程无法获取该锁。</p>
<p><strong>读写锁（Read-Write Lock）</strong>有两种获取方式，<strong>共享的（Shared）</strong>或<strong>独占的（Exclusive）</strong>。</p>
<table>
<thead>
<tr>
<th align="center">读写锁状态</th>
<th align="center">以共享方式获取</th>
<th align="center">以独占方式获取</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自由</td>
<td align="center">成功</td>
<td align="center">成功</td>
</tr>
<tr>
<td align="center">共享</td>
<td align="center">成功</td>
<td align="center">等待</td>
</tr>
<tr>
<td align="center">独占</td>
<td align="center">等待</td>
<td align="center">等待</td>
</tr>
</tbody></table>
<p><strong>条件变量（Condition Variable）</strong>作为一种同步手段，作用类似于一个栅栏。线程可以等待条件变量，一个条件变量可以被多个线程等待；线程也可以唤醒条件变量，此时某个或所有等待此条件变量的线程都会被唤醒并继续支持。</p>
<h3 id="可重入（Reentrant）与线程安全"><a href="#可重入（Reentrant）与线程安全" class="headerlink" title="可重入（Reentrant）与线程安全"></a>可重入（Reentrant）与线程安全</h3><p>一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。一个函数要被重入，只有两种情况：</p>
<ul>
<li>多个线程同时执行这个函数</li>
<li>函数自身（可能是经过多层调用之后）调用自身</li>
</ul>
<p>一个函数被称为可重入的，表明该函数被重入之后不会产生任何不良后果，必须具有以下几个特点：</p>
<ul>
<li>不使用任何（局部）静态或全局的非const变量</li>
<li>不返回任何（局部）静态或全局的非const变量的指针</li>
<li>仅依赖与调用方提供的参数</li>
<li>不依赖任何单个资源的锁（mutex等）</li>
<li>不调用任何不可重入的函数</li>
</ul>
<h3 id="过度优化"><a href="#过度优化" class="headerlink" title="过度优化"></a>过度优化</h3><p>编译器为了提高效率可能会把值放到寄存器中、交换毫不相干的两条相邻指令的执行顺序，CPU的动态调度为了提高效率也可能交换指令的顺序。</p>
<p>我们可以使用volatile关键字试图阻止过度优化，volatile可以：</p>
<ul>
<li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回</li>
<li>阻止编译器调整操作volatile变量的指令顺序</li>
</ul>
<p>而如果需要阻止CPU换序，通常操作是调用CPU提供的一条常常被称为barrier的指令，一条barrier指令会阻止CPU将该指令之前的指令交换到barrier之后，反之依然。</p>
<h2 id="多线程内部情况"><a href="#多线程内部情况" class="headerlink" title="多线程内部情况"></a>多线程内部情况</h2><p>线程的并发执行是由多处理器或操作系统调度来实现的。用户实际使用的是存在于用户态的用户线程，并不一定在操作系统内核里对应同等数量的内核线程（注：这里的内核线程和Linux内核里的Kernel_thread并不是一回事）。</p>
<h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p>对于直接支持线程的系统，一对一模型始终是最简单的模型。一个用户使用的线程就唯一对应一个内核使用的线程（反过来不一定）。这样用户线程就有了和内核线程一样的优点，线程之间的并发是真正的并发，一个线程因为某原因阻塞时，其他线程执行不会受到影响。</p>
<p>缺点：</p>
<ul>
<li>由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制</li>
<li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降</li>
</ul>
<h3 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h3><p>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对于一对一模型，多对一模型的线程切换要快速许多，同时拥有近乎无限制的线程数量。</p>
<p>缺点：</p>
<ul>
<li>如果其中一个用户线程阻塞，那么所有的线程都将无法执行，因为此时内核里的线程也随之阻塞了</li>
<li>在多处理器系统上，处理器的增多对多对一模型的线程性能不会有明显的帮助</li>
</ul>
<h3 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h3><p>多对多模型是将多个用户线程映射到少数但不只一个内核线程上</p>
<p>特点：</p>
<ul>
<li>一个用户线程阻塞并不会使得所有的用户线程阻塞，因为此时还有别的线程可以被调度来执行</li>
<li>对用户线程的数量没什么限制</li>
<li>在多处理器系统上，多对多模型的线程也能得到一定的性能提升，不过提升幅度不如一对一模型高</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">0bs3rver</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/11/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/">http://yoursite.com/2020/11/13/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">0bs3rver的小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/">程序员的自我修养</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/11/16/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">程序员的自我修养读书笔记-第二章 编译和链接</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/18/double%20free%E4%B8%8Euaf/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">double free与uaf</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/11/16/程序员的自我修养读书笔记-第二章 编译和链接/" title="程序员的自我修养读书笔记-第二章 编译和链接"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-11-16</div><div class="relatedPosts_title">程序员的自我修养读书笔记-第二章 编译和链接</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 0bs3rver</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>